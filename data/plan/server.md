RULE EMAS
1,SELALU GUNAKAN BAHASA INDONESIA YANG SANTAI
2,HINDARI MEMBERIKAN HARD CODE DALAM MEMBERIKKAN KODE, NAMUN JIKA HARUS MAKA SELALU GUNAKAN BAHASA INGRIS DIDALAM CODE
3,SELALU BERIKAN FULL CODE PADA FILE YANG DI PERBAIKI khusus kode kamus (bahsa jangan berikan full cukup kekurangan ya saja)
4,HAK KAMU HANYA MENEMBAHKAN KODE BUKAN MENGURANGI, JADI JIKA ADA KODE YANG NGGAK DI ANGAP PENTIK BERIKAN KOMENT, KAMU DI HARAMKAN MENGURANGI ATAU MENGHAPUS KODE WALAU 1 HURUF
5.PADA HARD CODE SEPERTI LOG DAN CATATAN ATAU LAINYA HARUS GUNAKAN BAHASA INGGRIS
6.INGAT RULE NO 2 HINDARI MEMBERIKAN HARDCODE , JIKA MEMANG HARUS MAKA HARDCODE SEPERTI MENU,TOMBOL,LOG DLL HARUS DALAM BAHASA INGGRIS, SAMBIL JALAN KITA RUBAH YANG SUDAH TERLANJUR MENGUNAKAN BAHASA INDONESIA MENJADI BAHASA INGGRIS
7.GUI DILARANG KERAS BERHUBUNGAN DENGAN KERNEL, INI SANGAT DI HARAMKAN NAMUN HARUS MELALUI API
8.GOL KITA AGAR FLOWORK BERUBAH MENJADI SERVER DAN AGAR USER BISA MEMBUAT TEMPLATE/GUI MENGUNAKAN Tkinter,Qt,wxWidgets,GTK,HTML,Vue,js,React,Angular,Svelte,Electron,Tauri,Flutter,React Native,Kivy
9.DENGAN TUJUAN DI ATAS MAKA DILARANG KERAS MEMBUAT CODE YANG TERIKAT DENGAN Tkinter AGAR TUJAUN TERSEBUT TERCAPAI
10, DAN GOL KITA LAINYA ADALAH MENJADIKAN FLOWORKS Arsitektur Microservices DIMANA SETIAP SERVICE KITA AKAN BUAT TERPISAH SESUAI DENGAN KATEGORYNYA AGAR TEAM MUDAH MENGEMBANGKANYA


RULE UNTUK MODUL/PLUGIN/WIDGET
 1. SETIAP MODUL WAJIB BISA MEMBACA OUTPUT APA SAJA YANG ADA DI MODUL SEBELUMNYA ,NAMUN KITA JUGA AKAN MENYEDIAKAN INPUT DI MODUL ITU SENDIRI SEBAGAI ALTERNATIF JIKA DIA BERDIRI SENDIRI TANPA MODUL AWAL SEBELUM DIA,  DAN MODUL BISA MEMILIH DARI OUTPUT MODUL SEBELUMNYA MANA YANG AKAN DI PILIH
 2. DI DALAM MODUL WAJIB ADA TIRE, SESUAIKAN DENGAN RULE KITA YANG ADA DI PRICE PAGE
 3. PADA HARDCORE MISAL PADA MANIFEST, LOG, ATAU APAPUN HARUS GUNAKAN BAHASA INGRIS, IDENYA HINDARI HARDCODE
 4. PADA MODUL WAJIB ADA get_data_preview
 5. UNTUK MENEGAKAN PRINSIP MODULAR DAN PLUG AND PLAY MAKA DALAM 1 MODUL WAJIB HANYA MEMILIKI 1 FUNGSI
 6. OUTPUT PORT HARUS OTOMATIS MEMBUAT / MENYESUAIKAN ISI PORT YANG ADA CONTOH SEMPURNA ADA DI MODUL static_data_provider_module
 7. Jika modul gagal,plugin mereka harus mengembalikan payload error, bukan raise exception



#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\addon_integrity.json
# JUMLAH BARIS : 1
#######################################################################

```json
{}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\backup.py
# JUMLAH BARIS : 24
#######################################################################

```py
import os
import logging
from tools.backup_system.archiver import Archiver
from tools.guardian_angel.guardian import GuardianAngel
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] [%(levelname)s] %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
def main():
    """
    The main entry point to start the backup guardian angel.
    This script's single responsibility is to launch the system.
    """
    project_root = os.getcwd()
    archiver_instance = Archiver(project_root=project_root)
    guardian = GuardianAngel(project_root=project_root, archiver_instance=archiver_instance)
    guardian.start()
if __name__ == "__main__":
    main()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\clean.py
# JUMLAH BARIS : 78
#######################################################################

```py
import os
import shutil
class ProjectCleaner:
    """
    Handles the logic for cleaning up general project cache files and folders.
    """
    def __init__(self, project_folder, report_callback=print):
        self.project_folder = project_folder
        self.report = report_callback
        self.top_level_folders_deleted = 0
        self.cache_folders_deleted = 0
        self.files_deleted = 0
    def run_cleanup(self):
        """Executes the entire cleanup process."""
        self._delete_top_level_folders()
        self._walk_and_clean()
        self._report_summary()
    def _delete_top_level_folders(self):
        folders_to_delete = ['build', 'dist']
        for folder_name in folders_to_delete:
            folder_path = os.path.join(self.project_folder, folder_name)
            if os.path.isdir(folder_path):
                try:
                    shutil.rmtree(folder_path)
                    self.top_level_folders_deleted += 1
                    self.report(f"[DELETED] Top-level folder: {folder_path}", "SUCCESS") # English Log
                except OSError as e:
                    self.report(f"[ERROR] Failed to delete folder {folder_path}: {e}", "ERROR") # English Log
    def _walk_and_clean(self):
        for root, dirs, files in os.walk(self.project_folder, topdown=False):
            dirs[:] = [d for d in dirs if d not in ['build', 'dist']]
            if '__pycache__' in dirs:
                pycache_folder_path = os.path.join(root, '__pycache__')
                try:
                    shutil.rmtree(pycache_folder_path)
                    self.cache_folders_deleted += 1
                    self.report(f"[DELETED] Cache folder: {pycache_folder_path}", "SUCCESS") # English Log
                except OSError as e:
                    self.report(f"[ERROR] Failed to delete folder {pycache_folder_path}: {e}", "ERROR") # English Log
            for file_name in files:
                if file_name.endswith(('.pyc', '.log')):
                    file_path = os.path.join(root, file_name)
                    try:
                        os.remove(file_path)
                        self.files_deleted += 1
                        self.report(f"[DELETED] File: {file_path}", "SUCCESS") # English Log
                    except OSError as e:
                        self.report(f"[ERROR] Failed to delete file {file_path}: {e}", "ERROR") # English Log
    def _report_summary(self):
        self.report("\n--- CLEANUP PROCESS FINISHED ---", "INFO") # English Hardcode
        self.report(f"Total build/dist folders deleted: {self.top_level_folders_deleted}", "INFO") # English Hardcode
        self.report(f"Total __pycache__ folders deleted: {self.cache_folders_deleted}", "INFO") # English Hardcode
        self.report(f"Total .pyc and .log files deleted: {self.files_deleted}", "INFO") # English Hardcode
        self.report("Your project is now cleaner and ready for a new build!", "SUCCESS") # English Hardcode
def main():
    """
    Main execution block for when this script is run directly from the console.
    """
    project_folder = os.getcwd()
    print(f"This will clean up cache, logs, and build folders inside: {project_folder}") # English Hardcode
    confirmation = input("Are you sure you want to continue? (y/n): ") # English Hardcode
    if confirmation.lower() != 'y':
        print("Cleanup cancelled by user.") # English Hardcode
        return
    def console_reporter(message, level="INFO"):
        print(message)
    cleaner = ProjectCleaner(project_folder, console_reporter)
    cleaner.run_cleanup()
if __name__ == "__main__":
    main()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\cleaner_tool.py
# JUMLAH BARIS : 91
#######################################################################

```py
import os
import shutil
class ArtifactCleaner:
    """
    Handles the logic for aggressively cleaning specific build artifacts
    from component folders to force a complete rebuild.
    """
    def __init__(self, project_folder, report_callback=print):
        self.project_folder = project_folder
        self.report = report_callback
        self.component_base_dirs = ['modules', 'plugins', 'widgets', 'triggers', 'ai_providers', 'formatters']
        self.files_to_delete_exact = ['.vendor_hash', 'build_fingerprint.json']
        self.files_to_delete_endswith = ['.pyi', '.pyd', '.original','.service', '.kernel', '.aola', '.ai', '.flow', '.teetah','.aola_flowork','.module.flowork','.plugin.flowork','.widget.flowork','.trigger.flowork','.scanner.flowork']
        self.folders_to_delete = ['vendor', 'vendor']
        self.folders_to_delete_endswith = ['.py.tmp.build', '.build']
        self.deleted_files = 0
        self.deleted_folders = 0
        self.deleted_pycache_folders = 0
    def run_cleanup(self):
        """Executes the entire aggressive cleanup process."""
        self.report("Scanning component directories for artifacts to clean...", "INFO") # English Log
        self._clean_component_artifacts()
        self.report("\nCleaning up general Python cache (__pycache__)...", "INFO") # English Log
        self._clean_pycache()
        self._report_summary()
    def _clean_component_artifacts(self):
        for base_dir in self.component_base_dirs:
            full_base_path = os.path.join(self.project_folder, base_dir)
            if not os.path.isdir(full_base_path):
                continue
            for component_name in os.listdir(full_base_path):
                component_path = os.path.join(full_base_path, component_name)
                if not os.path.isdir(component_path):
                    continue
                for root, dirs, files in os.walk(component_path, topdown=False):
                    for dir_name in list(dirs):
                        path_to_delete = os.path.join(root, dir_name)
                        if dir_name in self.folders_to_delete or any(dir_name.endswith(p) for p in self.folders_to_delete_endswith):
                            self._delete_folder(path_to_delete)
                    for file_name in files:
                        if file_name in self.files_to_delete_exact or any(file_name.endswith(p) for p in self.files_to_delete_endswith):
                            if file_name == '__init__.pyi': continue
                            self._delete_file(os.path.join(root, file_name))
    def _clean_pycache(self):
        for root, dirs, files in os.walk(self.project_folder, topdown=False):
            if '__pycache__' in dirs:
                self._delete_folder(os.path.join(root, '__pycache__'), is_pycache=True)
    def _delete_folder(self, path, is_pycache=False):
        try:
            shutil.rmtree(path)
            if is_pycache: self.deleted_pycache_folders += 1
            else: self.deleted_folders += 1
            self.report(f"[DELETED] Folder: {os.path.relpath(path, self.project_folder)}", "SUCCESS") # English Log
        except OSError as e:
            self.report(f"[ERROR] Failed to delete folder {path}: {e}", "ERROR") # English Log
    def _delete_file(self, path):
        try:
            os.remove(path)
            self.deleted_files += 1
            self.report(f"[DELETED] File: {os.path.relpath(path, self.project_folder)}", "SUCCESS") # English Log
        except OSError as e:
            self.report(f"[ERROR] Failed to delete file {path}: {e}", "ERROR") # English Log
    def _report_summary(self):
        self.report("\n--- CLEANUP PROCESS FINISHED ---", "INFO") # English Hardcode
        self.report(f"Total artifact folders deleted: {self.deleted_folders}", "INFO") # English Hardcode
        self.report(f"Total artifact files deleted: {self.deleted_files}", "INFO") # English Hardcode
        self.report(f"Total __pycache__ folders deleted: {self.deleted_pycache_folders}", "INFO") # English Hardcode
        self.report("Your components are now clean and ready for a fresh build!", "SUCCESS") # English Hardcode
def main():
    """Main execution block for when this script is run directly from the console."""
    project_folder = os.getcwd()
    print("--- Flowork Build Artifact Cleaner (Aggressive Mode) ---") # English Hardcode
    print(f"This script will clean build artifacts to force recompilation inside: {project_folder}") # English Hardcode
    confirm = input("Are you sure you want to continue? (y/n): ") # English Hardcode
    if confirm.lower() != 'y':
        print("Cleaning process cancelled by user.") # English Hardcode
        return
    def console_reporter(message, level="INFO"):
        print(message)
    cleaner = ArtifactCleaner(project_folder, console_reporter)
    cleaner.run_cleanup()
if __name__ == "__main__":
    main()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\core_integrity.json
# JUMLAH BARIS : 61
#######################################################################

```json
{
    "DEBUG.bat": "69c7f4ded0607d021484959b077a0fd7b4afc973499a75e854e8a83893d4118d",
    "ai_providers/text/gemini_provider/core/GeminiConnection.cp310-win_amd64.pyd": "816bf96638204fcac8ddcf59d874f88144d9d4288fb5ce0bb75a32ba59f8d8ec",
    "clean.py": "3860ba201d07d20bc83a3354f2fc6085e59e80b1761db2082ea32bd998c243e7",
    "flowork_kernel/api_client.cp310-win_amd64.pyd": "2240b9f1b52fca42d9504952a0674f4c7891f7d7c9f81ab62cdb82bb65cfab2d",
    "flowork_kernel/api_contract.cp310-win_amd64.pyd": "0b166967254d10b45ea341372e1ba27e08bd7158c81a46ea35aca6262faf690b",
    "flowork_kernel/core/permission_hook.cp310-win_amd64.pyd": "37f8cb68f1720649ca73750a454f29bf4994a05a856239297e0ea9b5be58d3df",
    "flowork_kernel/execution/CheckpointManager.cp310-win_amd64.pyd": "eddb0915e66cacb499b358ad55ce45987e8c49ebfc0c5e97c1882aff8aaad39f",
    "flowork_kernel/execution/LoopHandler.cp310-win_amd64.pyd": "41d6f9f57dfa2cc31c99489de21f8aaab5f2455e23efaa32a404874e614d0d9e",
    "flowork_kernel/execution/RetryHandler.cp310-win_amd64.pyd": "53a12e291e2478e70ee44088f59c3a9bef0c715a4abc1764b9ea2456dd555ef8",
    "flowork_kernel/execution/VariableResolver.cp310-win_amd64.pyd": "22459d7c44d3945eb94a13a6d49ac3b631094e46888cc4ded770d431fb41fa4d",
    "flowork_kernel/kernel.cp310-win_amd64.pyd": "cb967d900cedd08ac5337f1a57187a1306a80520805020df1ae9a2c928214067",
    "flowork_kernel/services.json": "cdd1fdc81d5e32e06e58f8448b28e31bb97aa8e2d08cf52a075428390beeff03",
    "flowork_kernel/services/agent_executor_service/agent_executor_service.cp310-win_amd64.pyd": "64513e661a05858973d956eb8833b5a0fc2ac5ba40722e0acd079d2cdcc12852",
    "flowork_kernel/services/agent_manager_service/agent_manager_service.cp310-win_amd64.pyd": "62422638c6744c3228a982ab5ec2e5b50655026dee6dd2309b3e4d89e5f09986",
    "flowork_kernel/services/ai_analyzer_service/ai_analyzer_service.cp310-win_amd64.pyd": "0c5cded4fc134bdc9bd3b44f2b53ec094c19f7207ccc2a24993688f2c50a0649",
    "flowork_kernel/services/ai_architect_service/ai_architect_service.cp310-win_amd64.pyd": "d534e095e33c37a48a504cc0d421ef2672f975b818cdaa0377bb7fed69e0932a",
    "flowork_kernel/services/ai_provider_manager_service/ai_provider_manager_service.cp310-win_amd64.pyd": "d35d87ed67b41ba7c8baac2409d89be90425666879cf67fb98d8d90b4e2a9f0f",
    "flowork_kernel/services/ai_training_service/ai_training_service.cp310-win_amd64.pyd": "66db180d1fcb1dbf058393eea7d690212be16b740a1d774f51456b5443306fac",
    "flowork_kernel/services/api_server_service/api_server_service.cp310-win_amd64.pyd": "feb6669b0690bb9920ee9d7892930db5bbd5d979136368f665c53f52132abdd2",
    "flowork_kernel/services/auto_compiler_service/auto_compiler_service.cp310-win_amd64.pyd": "298515d7e5dc7af37b42c997ae4c2e76cd2ae461099ec9c37dedc1e7063dcdaf",
    "flowork_kernel/services/base_service.cp310-win_amd64.pyd": "a9f80d52c66aa4da55dbe7c679e80e1e1382726ddece66193c096bc2ca97a1b1",
    "flowork_kernel/services/behavior_manager_service/behavior_manager_service.cp310-win_amd64.pyd": "5546bdf7cca72375c137c71372b986e4c2adb257e76b21d485232a69b8d2df28",
    "flowork_kernel/services/community_addon_service/community_addon_service.cp310-win_amd64.pyd": "a14624470dc9fa97c54d005c52d47b34820e57cf76acd55005ba437b3e644d72",
    "flowork_kernel/services/database_service/database_service.cp310-win_amd64.pyd": "1b983941034c8f61819548add17241948ce9887b0015a3f2fb551fc4d1e4fbc3",
    "flowork_kernel/services/dataset_manager_service/dataset_manager_service.cp310-win_amd64.pyd": "a603a41e3ba424367bd773b55b9cde8d8ccc8542f2c4cc76c1ea8269eb2afe60",
    "flowork_kernel/services/event_bus_service/event_bus_service.cp310-win_amd64.pyd": "84aa09acb1f84552bc6e72d35bfc583c577ded23b5b8217b232be46654f400ee",
    "flowork_kernel/services/integrity_checker_service/integrity_checker_service.cp310-win_amd64.pyd": "462a2448f62f553addbc046ee75f1926f6a1a447568c593796531000a6501672",
    "flowork_kernel/services/license_manager_service/license_manager_service.cp310-win_amd64.pyd": "bf97524f1148c52c1c23a14fd49dac2ede6d9776669570a9edacf66bc1e83266",
    "flowork_kernel/services/localization_manager_service/localization_manager_service.cp310-win_amd64.pyd": "3525a482054a3500d3d784d7b7cd87a79d338e832a524a8f9028efe9c8cd7d15",
    "flowork_kernel/services/model_converter_service/model_converter_service.cp310-win_amd64.pyd": "694ec857c7dba756674cee46fe70df48be2783221ccf8f9ca8f98ae604d25d3e",
    "flowork_kernel/services/module_manager_service/module_manager_service.cp310-win_amd64.pyd": "456b9a4bc54388aa3e867abed935dece56722d72de19fb24a7b5f1653ee13f75",
    "flowork_kernel/services/permission_manager_service/permission_manager_service.cp310-win_amd64.pyd": "f20f88d155e167f4ed117b10866ae0f681651eba72cc55dddffe3353efbbfe5a",
    "flowork_kernel/services/prompt_manager_service/prompt_manager_service.cp310-win_amd64.pyd": "bf4a777aa623dea6c5720219087785111a2cd28caef49cecc5fe6bce2f80a32e",
    "flowork_kernel/services/scheduler_manager_service/scheduler_manager_service.cp310-win_amd64.pyd": "11c433ef6c469434280bd99d1feb26a5342325ae6df79a4e8bdd079955e857c8",
    "flowork_kernel/services/screen_recorder_service/screen_recorder_service.cp310-win_amd64.pyd": "2bdd24e3d4796d1d6934a65b34dc4e71d497d2efe8f1705400d444e17c8725d2",
    "flowork_kernel/services/semantic_search_service/semantic_search_service.cp310-win_amd64.pyd": "e83c9fa5f39c895e5704eb1f260ba242439944f21bf7bdf23e1986c3b36ecec5",
    "flowork_kernel/services/startup_service/startup_service.cp310-win_amd64.pyd": "5bfde53851e47df03d1e05ded184e6b89b9e9346e12cff0e614af22329c38e36",
    "flowork_kernel/services/state_manager_service/state_manager_service.cp310-win_amd64.pyd": "64cb5c03a414411ea09a0647235a087b102ed7737cde36427e89769829cf8749",
    "flowork_kernel/services/tab_manager_service/tab_manager_service.cp310-win_amd64.pyd": "743cc437bff377dff0c139a06ff0433f2f91d032cae1b28061d1fc75f7cc18f4",
    "flowork_kernel/services/trigger_manager_service/trigger_manager_service.cp310-win_amd64.pyd": "5910f0697ef42ef970907b4e3f432e56618d085623effa49d5d0c808362f2576",
    "flowork_kernel/services/update_service/update_service.cp310-win_amd64.pyd": "7879c4d8938070453fb5650be66037ee02b19f5e5a9d2de6cd109392bd100655",
    "flowork_kernel/services/variable_manager_service/variable_manager_service.cp310-win_amd64.pyd": "b5d92c534f4f6cc906f36200688e22c30dc3047a074a405e6803f8095dddd547",
    "flowork_kernel/services/widget_manager_service/widget_manager_service.cp310-win_amd64.pyd": "a593366217048886ec9944f96b75acef4167630cdf83a6ae9defce1e3ffec94b",
    "flowork_kernel/services/workflow_executor_service/workflow_executor_service.cp310-win_amd64.pyd": "ed94cbb7c83eb04be1c9b9baf688fd0e9a05ec143bc2fdf259cf0a80a4041479",
    "flowork_kernel/ui_shell/authentication_dialog.cp310-win_amd64.pyd": "b5d0d9f07e3e6b7cdb6d02fd293ef73053d851bf1716523752da8aafd9023b42",
    "flowork_kernel/ui_shell/main_window.cp310-win_amd64.pyd": "2da5653ac169f499fc728a7e538e15c020e6ec52a87d799678927f19e7ff9c97",
    "flowork_kernel/ui_shell/ui_components/menubar_manager.cp310-win_amd64.pyd": "3dd8a7b33af387485961ad87342236210d4caa43c8537f383c5312ad9f8ec12e",
    "launcher.py": "cd9905544aa8b991131fc3dd2d9633975a48e20c988bd0c398ef7dc408f3a17f",
    "main.py": "e6668e4b7406141d0ff079b013d45e88c002a23176136b4c95170eb165a926fd",
    "plugins/flowork_core_ui/core_ui_provider.py": "442db43f3845ace7b3772b0f12b90e2f288d581e6b7cd97ad6d65605e12c0bc1",
    "plugins/flowork_core_ui/marketplace_page.cp310-win_amd64.pyd": "69415f2f768502892d0c7dd340d059538ae855d1d6e8d6f9a8e0396874daed1a",
    "plugins/flowork_core_ui/pricing_page.cp310-win_amd64.pyd": "6e45a661823c25cbe48f2033bfdd6ec533f3bf6697653473674198c3e1bd63e7",
    "plugins/flowork_core_ui/settings_components/license_management_frame.cp310-win_amd64.pyd": "1a0f8aaef57b5ecfc3c660aeb996a0bd6db954c48802816657dc1886d9785e06",
    "pre_launcher.py": "9a20c8416dfe363d96ab83bb2420afcba836aeae56d16d6b3e16128518174873",
    "scripts/bootstrap.py": "74d6b01e8d2e87687e4fdb0658660cc5d4cb77615c46612c03e18f2fe55f499c",
    "scripts/dependency_audit.py": "135bce7f0025f7a7998d662357aa362e2234de2eb43e9b1bfbd8287c9d0d8b78",
    "scripts/generate_docs.py": "a8ea0d26076afaac1a2d3eeecfd78d8a8a86fef93767a565469067b895ed8356",
    "scripts/setup.py": "308ee819ea5c72722b54371f7d458922c6efceffcf48259c40aae0144eb6f119",
    "teetah.gif": "0b5ebd13411445ca82fe734f9133bcf3e26c4c90da648f00be30af55f2f8ce1d"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\file_fingerprints.json
# JUMLAH BARIS : 263
#######################################################################

```json
{
    "CODE_OF_CONDUCT.md": "1f16cc91967554e005ac9bfb30d190633e9a783d03846e62d014f70475adb968",
    "CONTRIBUTING.md": "d3b7deb12e8f5a222d910eb89fa0da0d28d27ff269d53044fc0ab060e14921b2",
    "DEBUG.bat": "69c7f4ded0607d021484959b077a0fd7b4afc973499a75e854e8a83893d4118d",
    "LICENSE.md": "5665397c65a2d9aa20181d81f52a6268f473cf0fd4c7f1ab62fb1281b4ed3248",
    "README.md": "64c3d3d5732c76abe2cd179e144db15a063516630b3221199ca8cd6faec5b8df",
    "addon_integrity.json": "44136fa355b3678a1146ad16f7e8649e94fb4fc21fe77e8310c060f61caaff8a",
    "ai_providers/BaseAIProvider.py": "d27fa48ccae7476a05bff0f88434c470be28233e86dcd982cfbdc411432ad3d2",
    "ai_providers/text/chatgpt_provider/core/ChatGPTConnection.py": "fc95db2ee6f788201df4487ebad1ff85e9459aa688cdb8febeacc3b9bcbcb2c7",
    "ai_providers/text/chatgpt_provider/provider.awenkaudico": "89e6ce605efc8c9f8b26646b012517cd880acaa46a82b4f0c2b3f7aa2878d9a3",
    "ai_providers/text/chatgpt_provider/provider.py": "8bf1dcf4aa5db379bfc56a89afb59dd6db75bc1d2c3cc12384e7623dbc441acb",
    "ai_providers/text/gemini_provider/core/GeminiChatSession.py": "fb8aa36019eb1b3e00931eda7da7023c04b5efc90a6d4a5d370bb8aab9039a78",
    "ai_providers/text/gemini_provider/core/GeminiConnection.cp310-win_amd64.pyd": "816bf96638204fcac8ddcf59d874f88144d9d4288fb5ce0bb75a32ba59f8d8ec",
    "ai_providers/text/gemini_provider/core/GeminiConnection.py": "0a8f88fe07ddc7af8bb1c02267f518a28e26df66e04e170874909db2d1492e9d",
    "ai_providers/text/gemini_provider/provider.awenkaudico": "276b7e7233c2aac1aad39789e4bce510739ec2af0927e547d0291e2681cdf8c5",
    "ai_providers/text/gemini_provider/provider.py": "50dec50cab8a75bceda957d4da44b405ccfd87d63ea19072d7a91a6e6213e2db",
    "clean.py": "3860ba201d07d20bc83a3354f2fc6085e59e80b1761db2082ea32bd998c243e7",
    "core_integrity.json": "acdd6c322866d14f96de8ee9680fc79b229f6dd77b1f554f5922029421eb0207",
    "core_services/core_lifecycle.flowork": "c3a027955bde8d0dfd74d1e2af3df33a95f226a0023d18a3960120ef13579713",
    "core_services/formatter_manager.flowork": "c830d0659ad94939b3708215c96d8906ec939e512014f5b75454f791dd9b91ee",
    "core_services/preset_manager.flowork": "9b5919af072d0ecc7e35a4284348f17f7debf9ecfdfdc2c8ea1cb9f3d8bd51ab",
    "core_services/theme_manager.flowork": "ae8fd2b8d938de40919fe5b626ff0936966c780a4d727519c3b73a19efea56a0",
    "file_fingerprints.json": "521ae6b9b6ce25e73925339616328ec5104d81aaa97d4f32dc66b99eb15cc97f",
    "flowork-icon.ico": "fac8ffb9d26961d2cb73c10e2486821df2fdea637304bd11436f39c895996acc",
    "flowork_cli/__main__.py": "dceb9989e232e8e33879cc8232867c9bb166dcec43cab87efb81fdadae1f387c",
    "flowork_cli/cli.py": "734b7ee66545ee774ff3b41be89ae43c51bcebda7b06d4cd027216a97f3bfce9",
    "flowork_cli/core/api_client.py": "c10be3e9bb241a9fef4737d4f22cf8b76a48bd14edb6cdda7cab974a1ab71828",
    "flowork_kernel/api_client.cp310-win_amd64.pyd": "2240b9f1b52fca42d9504952a0674f4c7891f7d7c9f81ab62cdb82bb65cfab2d",
    "flowork_kernel/api_client.py": "2e2aa7898104246a5e7107c16b62e915765e65e099cd20fb4d239b769d299b8c",
    "flowork_kernel/api_contract.cp310-win_amd64.pyd": "0b166967254d10b45ea341372e1ba27e08bd7158c81a46ea35aca6262faf690b",
    "flowork_kernel/api_contract.py": "caec59c33ac4ea99cd70d739488b19629aa533b71ecece4f0034940d926cc886",
    "flowork_kernel/core/permission_hook.cp310-win_amd64.pyd": "37f8cb68f1720649ca73750a454f29bf4994a05a856239297e0ea9b5be58d3df",
    "flowork_kernel/core/permission_hook.py": "2354ea5785bd2671f5aa9a19c4f8589fb487aa1d96aea16d1b22c0c23b567560",
    "flowork_kernel/exceptions.py": "40e5f69b963199b69b7843a01fc9ed0c5fe72154d6fd90826959cc80b6ba8805",
    "flowork_kernel/execution/CheckpointManager.cp310-win_amd64.pyd": "eddb0915e66cacb499b358ad55ce45987e8c49ebfc0c5e97c1882aff8aaad39f",
    "flowork_kernel/execution/CheckpointManager.py": "4047881e50e5b364d71717be2a616a6fbb322234198182e25420ce6b35c1c066",
    "flowork_kernel/execution/LoopHandler.cp310-win_amd64.pyd": "41d6f9f57dfa2cc31c99489de21f8aaab5f2455e23efaa32a404874e614d0d9e",
    "flowork_kernel/execution/LoopHandler.py": "80832573f64effdfdec071cf8d830f8889bc17b1f2f7273eb1c013865446469a",
    "flowork_kernel/execution/RetryHandler.cp310-win_amd64.pyd": "53a12e291e2478e70ee44088f59c3a9bef0c715a4abc1764b9ea2456dd555ef8",
    "flowork_kernel/execution/RetryHandler.py": "df0723651ba1f5dc06f94c252a0cd72db6d89852315a4c5336a254cb02221c39",
    "flowork_kernel/execution/VariableResolver.cp310-win_amd64.pyd": "22459d7c44d3945eb94a13a6d49ac3b631094e46888cc4ded770d431fb41fa4d",
    "flowork_kernel/execution/VariableResolver.py": "5712717d1823b1471ae6a85f05b60db62849702d596fada6e5e19cebe5b6a559",
    "flowork_kernel/factories/ParserFactory.py": "9d2029c4440cde7c77c1f7ace1075c82c6541ac3a4fc9f2fd7aa2529ecd86c36",
    "flowork_kernel/kernel.py": "cecb8453f94781be83fdab050bec3973f7f9459b345e0db6783d982ff6d4b9d9",
    "flowork_kernel/models/AgentModel.py": "704d08dde02a1b677a0fa05d271d79d785c1d586826c741dc85acff428573c99",
    "flowork_kernel/models/ConnectionModel.py": "74aec8eab752665ea5f54c20128d217ccdc6f7dde7b5a40c6842f90e9374d8e8",
    "flowork_kernel/models/ManifestModel.py": "764a84fbad52a82a52adb9bc7334b090bfc2bedd07bb1d849bbcee8faddbf8f4",
    "flowork_kernel/models/NodeModel.py": "1a4682d2a8b35de693a947598f9eafa70bc510257b87353a9489983e2f7942ea",
    "flowork_kernel/models/WorkflowPayloadModel.py": "3442aad1d3868203e803a4914dc47243e3499d108cce21c42b26084cc204706b",
    "flowork_kernel/services/agent_executor_service/agent_executor_service.cp310-win_amd64.pyd": "64513e661a05858973d956eb8833b5a0fc2ac5ba40722e0acd079d2cdcc12852",
    "flowork_kernel/services/agent_executor_service/agent_executor_service.py": "284c130caccb45ba83ed9dfb9e228da962adf2b35eb42c8f511d3eab5c131a9b",
    "flowork_kernel/services/agent_manager_service/agent_manager_service.cp310-win_amd64.pyd": "62422638c6744c3228a982ab5ec2e5b50655026dee6dd2309b3e4d89e5f09986",
    "flowork_kernel/services/agent_manager_service/agent_manager_service.py": "c271c253494be4d80cdb05293b7f939a7c394a1b473c108d621bd84d88eaf554",
    "flowork_kernel/services/ai_analyzer_service/ai_analyzer_service.cp310-win_amd64.pyd": "0c5cded4fc134bdc9bd3b44f2b53ec094c19f7207ccc2a24993688f2c50a0649",
    "flowork_kernel/services/ai_analyzer_service/ai_analyzer_service.py": "f20da21d7850cf33e72435cdbc8147a808f4404e1f8525e76f58474232cfc586",
    "flowork_kernel/services/ai_architect_service/ai_architect_service.cp310-win_amd64.pyd": "d534e095e33c37a48a504cc0d421ef2672f975b818cdaa0377bb7fed69e0932a",
    "flowork_kernel/services/ai_architect_service/ai_architect_service.py": "9c046f1456b0fb446a5cac1ffb4ef6dcebd59ea57814ea5fba7f0d113a0e965a",
    "flowork_kernel/services/ai_provider_manager_service/ai_provider_manager_service.cp310-win_amd64.pyd": "d35d87ed67b41ba7c8baac2409d89be90425666879cf67fb98d8d90b4e2a9f0f",
    "flowork_kernel/services/ai_provider_manager_service/ai_provider_manager_service.py": "b09bfbfa855931e72ade2bca6fc007dd6125854003e0f1d5d5a5bd4167d25807",
    "flowork_kernel/services/ai_training_service/ai_training_service.cp310-win_amd64.pyd": "66db180d1fcb1dbf058393eea7d690212be16b740a1d774f51456b5443306fac",
    "flowork_kernel/services/ai_training_service/ai_training_service.py": "a2c3e936010a3c61631c41f4362d89b14f61ec5c02dc8efd2970c818ce61075a",
    "flowork_kernel/services/api_server_service/api_server_service.cp310-win_amd64.pyd": "feb6669b0690bb9920ee9d7892930db5bbd5d979136368f665c53f52132abdd2",
    "flowork_kernel/services/api_server_service/api_server_service.py": "6202dcd3e3c0d5fb89a53c44a4978beefcabb74b3eefe01cc254b07309d0895d",
    "flowork_kernel/services/api_server_service/routes/agent_routes.py": "fbbbf42b6ad565f6fce18a8ba393754b96086a1c76a2f78f7ff8c04b560efa18",
    "flowork_kernel/services/api_server_service/routes/base_api_route.py": "0415c382d525902209e4486d71e1e3163866e05da735b22af7e93744337ed288",
    "flowork_kernel/services/api_server_service/routes/component_routes.py": "58ac639709e4457e8a2310986ab1542ed85335b03f7d38036f58fb58abc8349e",
    "flowork_kernel/services/api_server_service/routes/dataset_routes.py": "4c2032152e4e23f94883659115fec33359feb37d5ea8660673c9423a405fe7d2",
    "flowork_kernel/services/api_server_service/routes/execution_routes.py": "894a97c1b97b81f0986bacdba2b0baf238218a280deb6c581af48c568072fad7",
    "flowork_kernel/services/api_server_service/routes/license_routes.py": "bc0f8935cf61e7dbaeff944223d963bd5b9b522fe1d316732dddca0aaa3a9193",
    "flowork_kernel/services/api_server_service/routes/model_routes.py": "cc018cdab467f627a18e6826e155fa078254b6e70830fea30d3680f8cadb5878",
    "flowork_kernel/services/api_server_service/routes/preset_routes.py": "0dd4e6a88a61485758d7534eea6caa98a70c5c0358e98ba99aa66c43de93edea",
    "flowork_kernel/services/api_server_service/routes/prompt_routes.py": "158b8f3fc7bb89f3dee0f18472a94eec93db15da61e31ae189c828c8f0ce5a9a",
    "flowork_kernel/services/api_server_service/routes/settings_routes.py": "d72dd59856319ede9ebdb872d76eb4759a560a28c2a5b53a2c8adf5eba6786e9",
    "flowork_kernel/services/api_server_service/routes/system_routes.py": "5740713aa724e2c289e5f9afb70b310ec66e1e04c1a5e8fcc69af5772d66d209",
    "flowork_kernel/services/api_server_service/routes/training_routes.py": "a583e9b52ce1fa9359c6bd95e42c2f2e2d1194b05f9317920cfd2a4cba78c60a",
    "flowork_kernel/services/api_server_service/routes/trigger_routes.py": "61590770b27431906b4128ecce1df523332f3ef38d6e5cd3f2441ec4dfa5d397",
    "flowork_kernel/services/api_server_service/routes/ui_state_routes.py": "eb4d79758b22de6f2d597107097d849b1789cd471387713671ca10ed5543e270",
    "flowork_kernel/services/api_server_service/routes/variable_routes.py": "f81d8a314596a7880310bd9fa6498d3b16469f87e8adb4acade2e956ca043240",
    "flowork_kernel/services/auto_compiler_service/auto_compiler_service.py": "08c70d39bd89f147f95565f323066fff1eb4432b3e0776abfaa39d276a1c5efc",
    "flowork_kernel/services/base_service.cp310-win_amd64.pyd": "a9f80d52c66aa4da55dbe7c679e80e1e1382726ddece66193c096bc2ca97a1b1",
    "flowork_kernel/services/base_service.py": "14e78e3fea31a140bc538df50098ced8a75f2009c09d704667690c89e80c8313",
    "flowork_kernel/services/behavior_manager_service/behavior_handlers.py": "48faeff24fe4dbfa35cd62ecad806c22d83cbfb4d4e3423e440bb6581c9ec743",
    "flowork_kernel/services/behavior_manager_service/behavior_manager_service.cp310-win_amd64.pyd": "5546bdf7cca72375c137c71372b986e4c2adb257e76b21d485232a69b8d2df28",
    "flowork_kernel/services/behavior_manager_service/behavior_manager_service.py": "d5febc0f252a347f8d46f28f852a6697f68fb476f49d20e7c034db220b6b0e11",
    "flowork_kernel/services/community_addon_service/community_addon_service.cp310-win_amd64.pyd": "a14624470dc9fa97c54d005c52d47b34820e57cf76acd55005ba437b3e644d72",
    "flowork_kernel/services/community_addon_service/community_addon_service.py": "b0c1e892173ffaf11335ed1ec6821113468ca441f8cde8bfb4da81d12acb0909",
    "flowork_kernel/services/database_service/database_service.cp310-win_amd64.pyd": "1b983941034c8f61819548add17241948ce9887b0015a3f2fb551fc4d1e4fbc3",
    "flowork_kernel/services/database_service/database_service.py": "e2991bf49aac0e1df195536b31c41b734df56b83c90ca47ecbe30e091b47b343",
    "flowork_kernel/services/dataset_manager_service/dataset_manager_service.cp310-win_amd64.pyd": "a603a41e3ba424367bd773b55b9cde8d8ccc8542f2c4cc76c1ea8269eb2afe60",
    "flowork_kernel/services/dataset_manager_service/dataset_manager_service.py": "02862f84580ecefdc8a3c9ab7d2c009f2913c1e548c8b0d7493a651f58892e1a",
    "flowork_kernel/services/documentation_service/documentation_service.py": "e707ac66a103acd86fc1515664148ef6b2f05f3a3f07886cdd9e0950f75c139f",
    "flowork_kernel/services/event_bus_service/event_bus_service.cp310-win_amd64.pyd": "84aa09acb1f84552bc6e72d35bfc583c577ded23b5b8217b232be46654f400ee",
    "flowork_kernel/services/event_bus_service/event_bus_service.py": "360bbd1c16433418dfbb206ae3d686c8d45e19368582e3192320d17caf84aa15",
    "flowork_kernel/services/integrity_checker_service/integrity_checker_service.py": "7ecccc447122583fb5f4143ee8e235eb30e9da9f1c2846b789c85d2d9cf09d84",
    "flowork_kernel/services/license_manager_service/license_manager_service.cp310-win_amd64.pyd": "bf97524f1148c52c1c23a14fd49dac2ede6d9776669570a9edacf66bc1e83266",
    "flowork_kernel/services/license_manager_service/license_manager_service.py": "02502cf84530811f0a28704ce9344f179e238bfd01d5733a623aceea0abd4293",
    "flowork_kernel/services/localization_manager_service/localization_manager_service.cp310-win_amd64.pyd": "3525a482054a3500d3d784d7b7cd87a79d338e832a524a8f9028efe9c8cd7d15",
    "flowork_kernel/services/localization_manager_service/localization_manager_service.py": "6f10e4743cbb1b58e1d9ba381a0124a0fc095a307be441858330473cb375977b",
    "flowork_kernel/services/model_converter_service/model_converter_service.cp310-win_amd64.pyd": "694ec857c7dba756674cee46fe70df48be2783221ccf8f9ca8f98ae604d25d3e",
    "flowork_kernel/services/model_converter_service/model_converter_service.py": "cd3a4651830b4764ad84c89c8b6a183c44791cc6f8f47248a5cbdacd77f1680f",
    "flowork_kernel/services/module_manager_service/module_manager_service.py": "cb00e841c388cebdacdcd77758743418b844a3727f24a08b4cf255fa43f5cb4c",
    "flowork_kernel/services/permission_manager_service/permission_manager_service.cp310-win_amd64.pyd": "f20f88d155e167f4ed117b10866ae0f681651eba72cc55dddffe3353efbbfe5a",
    "flowork_kernel/services/permission_manager_service/permission_manager_service.py": "a63922c5b17a039de5c83e0f992ec55c72eada179fab978cc6d6eb5c2b2e2470",
    "flowork_kernel/services/prompt_manager_service/prompt_manager_service.cp310-win_amd64.pyd": "bf4a777aa623dea6c5720219087785111a2cd28caef49cecc5fe6bce2f80a32e",
    "flowork_kernel/services/prompt_manager_service/prompt_manager_service.py": "7cc88dda192572a9a104e605b0b36a781f492d443d82d47453a3b3dfa0bff074",
    "flowork_kernel/services/scheduler_manager_service/scheduler_manager_service.cp310-win_amd64.pyd": "11c433ef6c469434280bd99d1feb26a5342325ae6df79a4e8bdd079955e857c8",
    "flowork_kernel/services/scheduler_manager_service/scheduler_manager_service.py": "c31f1800bc941c32c6b96c3df12e5e29655d3219e5dbb74c49499bf17ce26caf",
    "flowork_kernel/services/screen_recorder_service/screen_recorder_service.cp310-win_amd64.pyd": "2bdd24e3d4796d1d6934a65b34dc4e71d497d2efe8f1705400d444e17c8725d2",
    "flowork_kernel/services/screen_recorder_service/screen_recorder_service.py": "a14522109c46b9808f1abd292c87fb5ee80cfb9060443f9d2000155cec3c5407",
    "flowork_kernel/services/semantic_search_service/semantic_search_service.cp310-win_amd64.pyd": "e83c9fa5f39c895e5704eb1f260ba242439944f21bf7bdf23e1986c3b36ecec5",
    "flowork_kernel/services/semantic_search_service/semantic_search_service.py": "441d0a149229e44ea936b02e8c1a9a51893ebeb75d353c40247333df4525c1f4",
    "flowork_kernel/services/startup_service/startup_service.cp310-win_amd64.pyd": "5bfde53851e47df03d1e05ded184e6b89b9e9346e12cff0e614af22329c38e36",
    "flowork_kernel/services/startup_service/startup_service.py": "ce2ddd047e0e249b2f6bf3158cd506c9cc8710b29cb611b6faf2dec5f46b7ccd",
    "flowork_kernel/services/state_manager_service/state_manager_service.cp310-win_amd64.pyd": "64cb5c03a414411ea09a0647235a087b102ed7737cde36427e89769829cf8749",
    "flowork_kernel/services/state_manager_service/state_manager_service.py": "faca7d4f57fa524ebafeca77f356d58de3e0fd28c10deb526c931d9022240e17",
    "flowork_kernel/services/tab_manager_service/tab_manager_service.cp310-win_amd64.pyd": "743cc437bff377dff0c139a06ff0433f2f91d032cae1b28061d1fc75f7cc18f4",
    "flowork_kernel/services/tab_manager_service/tab_manager_service.py": "29e56bd412f6080248684f37e2016e4c69ea174cd857a59c44d899b3a161e825",
    "flowork_kernel/services/trigger_manager_service/trigger_manager_service.cp310-win_amd64.pyd": "5910f0697ef42ef970907b4e3f432e56618d085623effa49d5d0c808362f2576",
    "flowork_kernel/services/trigger_manager_service/trigger_manager_service.py": "737616a63b9dadced4825042ffbc7b1ec6cb521a30a42757fa3ea097b0e5dc11",
    "flowork_kernel/services/update_service/update_service.py": "c911c9477091e3c75e781d299ee1a0233bad2a5a6592e58a2fb469270de8817f",
    "flowork_kernel/services/variable_manager_service/variable_manager_service.cp310-win_amd64.pyd": "b5d92c534f4f6cc906f36200688e22c30dc3047a074a405e6803f8095dddd547",
    "flowork_kernel/services/variable_manager_service/variable_manager_service.py": "999d1e67150b5c1029a5a20fe9290752cb84f3ea8a8654f162271f8a7add8f80",
    "flowork_kernel/services/widget_manager_service/widget_manager_service.cp310-win_amd64.pyd": "a593366217048886ec9944f96b75acef4167630cdf83a6ae9defce1e3ffec94b",
    "flowork_kernel/services/widget_manager_service/widget_manager_service.py": "20420ce58116464278d5663eee9aefb1d5adf320290611edfe8f41dc32b12614",
    "flowork_kernel/services/workflow_executor_service/workflow_executor_service.cp310-win_amd64.pyd": "ed94cbb7c83eb04be1c9b9baf688fd0e9a05ec143bc2fdf259cf0a80a4041479",
    "flowork_kernel/services/workflow_executor_service/workflow_executor_service.py": "5fdd78558b1b94fe51b433ecfba378c4e93afe572943456247bd4ff064908866",
    "flowork_kernel/ui_shell/authentication_dialog.cp310-win_amd64.pyd": "b5d0d9f07e3e6b7cdb6d02fd293ef73053d851bf1716523752da8aafd9023b42",
    "flowork_kernel/ui_shell/authentication_dialog.py": "5ce610362e2f08d7a2c37e20af812a82864e49198c87dfd55e917e59cc863d1c",
    "flowork_kernel/ui_shell/canvas_components/connection_manager.py": "1f802784a6fb71eaf24bc6068cde57f56b7b852d6d3f5cebb8e7904330a0ca9d",
    "flowork_kernel/ui_shell/canvas_components/interaction_manager.py": "eb18afb225ad66926f62feabc28d6e04489ac5bc595c8984a3537bd3cb9457f5",
    "flowork_kernel/ui_shell/canvas_components/interactions/canvas_navigation_handler.py": "f0bbe3cd3bbb52eb3b0a241cbe3ac3334947ca4d748d1677bfe917ae9b0633d3",
    "flowork_kernel/ui_shell/canvas_components/interactions/connection_interaction_handler.py": "4c0387ccfcc2e339732f01e8ab56b01e2a975e0ba70fe4c32614301c7b154962",
    "flowork_kernel/ui_shell/canvas_components/interactions/node_interaction_handler.py": "83b9ff785951eb7229e7828422523c3c35841e3c1a78e6cca93332fbc6080911",
    "flowork_kernel/ui_shell/canvas_components/node_manager.py": "b194aeb5d8fa5c53e40e8950e3c37daa14f4c22d509dd9e1bc92f88913b56213",
    "flowork_kernel/ui_shell/canvas_components/properties_manager.py": "c3ce83fa98ef88daef7eeb33065c9599fafeaf20d4d07b4509a94eb6cf105b1b",
    "flowork_kernel/ui_shell/canvas_components/visual_manager.py": "eddc03bab0e53a59254d2301fa6bf62166e19b29dafff46584aab783d844bf4c",
    "flowork_kernel/ui_shell/canvas_manager.py": "877e0476bd2fc2736767747eedcbc630c5bd29482550aaaa6e71613d41ecca4d",
    "flowork_kernel/ui_shell/components/InfoLabel.py": "b5f8d7ffe96e5b5b1b7b514ea5fd6291db95c3dbaac73e1712905fe0a889b073",
    "flowork_kernel/ui_shell/components/LabelledCombobox.py": "d3006fa75024ebcb8d137bda60b0c790fdceb7dc3ee6fc6637884c8ca3b667c4",
    "flowork_kernel/ui_shell/components/PropertyField.py": "7dec22602bb64d2ed3d626229695a9c085ed99e5681828f650b86dfd616d7416",
    "flowork_kernel/ui_shell/components/Separator.py": "ae9ec83479a362d776359c488fb24a1ea034f6082b727ecc9200a557c7e43ee3",
    "flowork_kernel/ui_shell/custom_tab.py": "bfc2a43dd717fb8fc90f2be55f3565425d9bd84f13778d4a592c7ea5c88f2cdf",
    "flowork_kernel/ui_shell/custom_widgets/DualListbox.py": "61add54ea9edb5a1a4ba7b2841741dd7e32aadc51dcdbd55d5b70c4edbb96322",
    "flowork_kernel/ui_shell/custom_widgets/StandardButtons.py": "5bfeb8d9aac9c6e95cd0554601e3af8ffa90769091895616a04e7eb09d17dedb",
    "flowork_kernel/ui_shell/custom_widgets/draggable_notebook.py": "d74533ed09f8716b04ef72bf67845064404bcc35da50f37895adb4bb132618cd",
    "flowork_kernel/ui_shell/custom_widgets/scrolled_frame.py": "97b856a1355c96c1c746dab3e32dd64c9fdd095f7e12326724ccf32fd135f701",
    "flowork_kernel/ui_shell/custom_widgets/tooltip.py": "f6075c7786e1e8ff0fbb219c604c4f59c126c4fe1d3f675563dd8513d40cd399",
    "flowork_kernel/ui_shell/dashboard_frame.py": "584eb22465a71115c2d8e99cd12770849acd351bea706f08f4d7070ff36f89a5",
    "flowork_kernel/ui_shell/dashboard_manager.py": "9227aba41629f30b9e4d1cb2f02ba91fb0d0db503d43915928df0e1fadccb9ca",
    "flowork_kernel/ui_shell/dashboard_tab.py": "4402522e725cc3bcd71d01bd3b8271bff679402e7514c67a71c99472d1b25d0e",
    "flowork_kernel/ui_shell/lifecycle/AppLifecycleHandler.py": "84027187dab32ebd4bfd0b56f54ec48aa5d44f7ccae0bea66af8ccab4c0af7af",
    "flowork_kernel/ui_shell/main_window.cp310-win_amd64.pyd": "2da5653ac169f499fc728a7e538e15c020e6ec52a87d799678927f19e7ff9c97",
    "flowork_kernel/ui_shell/main_window.py": "2c2c77c27cd6a300e1dbc1f40e8ece2f3a6f40fa9d6e3d1003b9a52021aa8e65",
    "flowork_kernel/ui_shell/node_properties_popup.py": "59667750afbce8affd31abfb05af211851f6baee3249adb29eec1961f3507fb4",
    "flowork_kernel/ui_shell/popups/NotificationManager.py": "b3de16b0efc369d82630142b5cc99f5186aa08780e37d3ec2ce8e40415a8e383",
    "flowork_kernel/ui_shell/popups/NotificationToast.py": "64f35f9671d28e577f187132a4b7403343c190d2da69f78c0599ae4574e99509",
    "flowork_kernel/ui_shell/popups/PopupManager.py": "e2ebc5fb67c85f5f68a8ab065dabba1e7295b6577855670f049bec741d258fab",
    "flowork_kernel/ui_shell/popups/approval_popup.py": "a670d55c1992e39f5770ac70613d1908773a49ff601aba22c684fc203745e88e",
    "flowork_kernel/ui_shell/popups/forced_update_popup.py": "b2bd5299438d13103bb83b7088657776058f8752bca0b5b97b7cbaf3e1e1486a",
    "flowork_kernel/ui_shell/popups/license_popup.py": "dbe01fad5e223fb00347e88b49836729fa991ab68a4cf7eb7eb0b46471da1675",
    "flowork_kernel/ui_shell/properties_popup.py": "addf1c61f899ac1972e169a6cd556202d7858f148b122c28281d25f23214513b",
    "flowork_kernel/ui_shell/shared_properties.py": "260fb9e6bd701d4ffa5c89fb230407ac3bc037d8f0db444d7e43495552633537",
    "flowork_kernel/ui_shell/ui_components/controllers/TabActionHandler.py": "d73803e049e4419aa03e7b807d81ffd8e97dc9ee40e4efbd2de8b5c68c00d020",
    "flowork_kernel/ui_shell/ui_components/menubar_manager.cp310-win_amd64.pyd": "3dd8a7b33af387485961ad87342236210d4caa43c8537f383c5312ad9f8ec12e",
    "flowork_kernel/ui_shell/ui_components/menubar_manager.py": "2aa8607089b48651bdf54496bd56e3383f478b5efe706f19692bec9db3210c55",
    "flowork_kernel/ui_shell/ui_components/tab_manager.py": "ec95606b43427a7f2ecf4253d5bd2e14579aef61652652c4ada984e5608c8c6f",
    "flowork_kernel/ui_shell/version_manager_popup.py": "6e12e51a4e2ab321a58d81c4567c78717e882b287e47f4dae098f7cb530c4300",
    "flowork_kernel/ui_shell/workflow_editor_tab.py": "5d893d48d9946e2f740457c7eb06b5aa3799b728dff06b62abef17af1e7c850c",
    "flowork_kernel/utils/condition_evaluator.py": "f666076f5c2208b755d50fca84a0404a8473ba1c3c07c3d5139fc2e713ecb166",
    "flowork_kernel/utils/file_helper.py": "fb5c30055f4bdc8436f3a479f1054b0808e519135ed96c14d6112f088cc46c2c",
    "flowork_kernel/utils/payload_helper.py": "5b3fa614f1c21a0da8dd024e814d55865b90513e8bcd61139fbd8cf34817668f",
    "flowork_kernel/utils/performance_logger.py": "ed128903aeeb2826e3a52938c318c256eb1de20548f6c3b565b8852283061e88",
    "flowork_kernel/utils/type_converter.py": "955191b97f8c19584ec03345bbbe6d19873cdf93f4a851c4681e80275c78b472",
    "flowork_kernel/webhook_server.py": "9c5039ea9c65cfc3e14294a497f242923e014c9bf3e4cd3e3848d6797bbc5219",
    "flowork_kernel/workers/ai_worker.py": "e0f24d9debdd033d03044ffad40bf186d620b5dd8e993a95166ee46fb6bdd368",
    "formatters/csv_formatter/formatter.py": "4b53e720dc4209d24644203a249fc85d2135416f1c5fcaa5e9b6ad1a53be4e8c",
    "generated_services/formatter_manager_service/service.py": "50f0beb498dfec07bda74f490ab9c067b72c4caafe78fd79139d11bcadeffd98",
    "generated_services/preset_manager_service/service.py": "11d530dac07d50ff8b9cb19208db6b615776818d0a2a7f17e0b7dbc8e20621ac",
    "generated_services/theme_manager_service/service.py": "d493c7cb6fd9b12f92e0bc534d9608bed99e4b60dc5019c88de34491b3bf4867",
    "launcher.py": "cd9905544aa8b991131fc3dd2d9633975a48e20c988bd0c398ef7dc408f3a17f",
    "logo.png": "c63c4148a02962b7f80f14701faa7529dafd3b49eecbcfe65683acc3e49004db",
    "main.py": "e6668e4b7406141d0ff079b013d45e88c002a23176136b4c95170eb165a926fd",
    "plugins/flowork_core_ui/ai_architect_page.py": "98b6942578e96cb75dfdc6aaf99b080cfaf74fc6c8d26b018560429b145b788b",
    "plugins/flowork_core_ui/ai_trainer_page.py": "baf1790face7fa195da328b0cde77c45650ce1faaea3b8ad556894aebf77d22d",
    "plugins/flowork_core_ui/components/recorder_control_panel.py": "301bcd096d0fe9f60a1a7f4fb2523b5f5a4d06a5cd0a8663cfa7f98f6b7cfdfb",
    "plugins/flowork_core_ui/core_editor_page.py": "6907924e13501ff4bfd18f57edd2a65d564db72e2cbef2b865d76745e9be2c7c",
    "plugins/flowork_core_ui/core_ui_provider.awenkaudico": "b424e1b8f4e4871f242519793986f5d69f7820f308ba1280af7cd5229163153d",
    "plugins/flowork_core_ui/core_ui_provider.py": "442db43f3845ace7b3772b0f12b90e2f288d581e6b7cd97ad6d65605e12c0bc1",
    "plugins/flowork_core_ui/generator_components/base_component.py": "450c0a29edf395e8a5eb813d063522cf0728850934a16d0a5d9b739c6df52855",
    "plugins/flowork_core_ui/generator_components/checkbox.py": "8b8fd521fa1267fa283a1b4950668b532b71af6f6122d66f53b2145d3110d455",
    "plugins/flowork_core_ui/generator_components/dropdown.py": "f50b5ac8ba7bb6d4cf06efeb4cc686d9f810a3fa942c4dc464d723fdb9cd5ca1",
    "plugins/flowork_core_ui/generator_components/file_path.py": "a46d64b581fa757f62b287bc067f1bd8286384fbb1ee03e2239e202cb16364da",
    "plugins/flowork_core_ui/generator_components/info_label.py": "6350efa329e3ddebd9ba410c8e265c817dfc0e265d93dcec751980005377e7c1",
    "plugins/flowork_core_ui/generator_components/logic_builder_canvas.py": "52fa9f1f4980ec85549ce70cb5482f6ef3aba02fb4c96475434419d892aa9a7a",
    "plugins/flowork_core_ui/generator_components/separator.py": "46ffb6a63cacecfdafc9ff233a83be702c9cc8390a9c8fe1711ec8b9975ac62f",
    "plugins/flowork_core_ui/generator_components/text_input.py": "74da67e28a292b2bdee5e40aa861c10f47303a34df80a2073df27ad397770243",
    "plugins/flowork_core_ui/generator_components/textarea.py": "ef92a94fb32988f5ba2d850b366612c59319caff86d0be4ccbf1bb8ff666972e",
    "plugins/flowork_core_ui/generator_page.py": "e8f61b2ba2bf9640b72ece645b5a1a9eb22fc0fe459f4cea584aed15d242bf82",
    "plugins/flowork_core_ui/marketplace_page.cp310-win_amd64.pyd": "69415f2f768502892d0c7dd340d059538ae855d1d6e8d6f9a8e0396874daed1a",
    "plugins/flowork_core_ui/marketplace_page.py": "877969d70a2d0fd7a333e1cb8062dc88b76163018721c8d4e627577450b5cb4d",
    "plugins/flowork_core_ui/model_converter_page.py": "f12c772d50f6a2230ce935eaccdd6f85ec3dce51d85f4e028ef8094446efe550",
    "plugins/flowork_core_ui/pricing_page.cp310-win_amd64.pyd": "6e45a661823c25cbe48f2033bfdd6ec533f3bf6697653473674198c3e1bd63e7",
    "plugins/flowork_core_ui/pricing_page.py": "7dff67b4013cbece9c239ae1371e96e06b16ff88f609bb5bd758fd60a70e5166",
    "plugins/flowork_core_ui/prompt_manager_page.py": "4ef2ee0ae70278200e36c7f443c1df50bcb1cf4cc3fae58f8b2b4d4c2bbd3be6",
    "plugins/flowork_core_ui/settings_components/agent_dialog.py": "643bf55061f700a3eaacc1c808b8cc34b83fc93e645bf3085514568ecf83acbd",
    "plugins/flowork_core_ui/settings_components/ai_model_manager_frame.py": "060e0ca6cf27557f4019551223f5f353f48968b603a0a387e01a2277bba0bea1",
    "plugins/flowork_core_ui/settings_components/ai_provider_settings_frame.py": "472e383ab156270a106d49fe78c649100d5b7c084aa99a09866c9c3d6c72e7c5",
    "plugins/flowork_core_ui/settings_components/error_handler_frame.py": "8b5dc984e992030cafb913fae4c86a71d925692187212ccab657cf33cb3c1f6b",
    "plugins/flowork_core_ui/settings_components/general_settings_frame.py": "955c8dcd0951612ad9d10f09bd9da80f72b558e2ddd64e48659deea28b1006e8",
    "plugins/flowork_core_ui/settings_components/license_management_frame.cp310-win_amd64.pyd": "1a0f8aaef57b5ecfc3c660aeb996a0bd6db954c48802816657dc1886d9785e06",
    "plugins/flowork_core_ui/settings_components/license_management_frame.py": "4d6b37e56c8b08ba77705c17de8d36a9f6332d807ec5e6db42920bb7e0deaf53",
    "plugins/flowork_core_ui/settings_components/notification_settings_frame.py": "8c0391abcbb9a44c1b75baf9ef7c3da081ed235d5523796c18fe2424003a0839",
    "plugins/flowork_core_ui/settings_components/recorder_settings_frame.py": "080b31f0f753b40354a8bb6196f4db663d7933887d39d5e03804f45940663fc8",
    "plugins/flowork_core_ui/settings_components/variable_dialog.py": "93f91610547c2c3033293ca26c601b009028cce1661de982d899f1b362630568",
    "plugins/flowork_core_ui/settings_components/variable_manager_frame.py": "54cb799e694b18340486ae32faac212aeb3e8db8e41d5df6ed618bd4cfe36ac4",
    "plugins/flowork_core_ui/settings_components/webhook_settings_frame.py": "287a104ff4b307940e60783de0853928c3d9aa39a02aa71d95bf5a3bb6cd6a6d",
    "plugins/flowork_core_ui/settings_tab.py": "9100329b37679338484db015a6246dc6ffb697b553ecde8ea38bf436feae71d8",
    "plugins/flowork_core_ui/template_manager_page.py": "ec9924eb4fef6243a110cab58f5f3f22c2e2f7c2854c064d350dc3cf5e46dd16",
    "plugins/flowork_core_ui/trigger_manager_page.py": "a9da9a4f7bf64eb172c8342681ca8c18da38dbb7217bda10d98ee21b4e08fa6d",
    "plugins/flowork_core_ui/upload_dialog.py": "bfa37fa4e8910af26cf81b1b2709b09e5018e6dbfc07767608a449bc227f63ac",
    "plugins/image_generator_tools/processor.awenkaudico": "73f739bb367bb3f19a418b034baab2493f3a85a687b13a277aa14aab5d56e781",
    "plugins/image_generator_tools/processor.py": "08251c7c90575ddaba207adf9e1ad8fb5fb90be077698d03bf6524d11dc70ec3",
    "plugins/system_diagnostics_plugin/diagnostics_page.py": "8bcc01d4b5b9f57634196abbe25c6eb0fd163154f77589275742650b2eca36d2",
    "plugins/system_diagnostics_plugin/license_and_integrity_scan.py": "962034f5c37ce14d7bfbf7f2eba5d2846ac59e242770bcb0a35819517178d41d",
    "plugins/system_diagnostics_plugin/processor.awenkaudico": "88f2d9973077df47723a811b6d96d98a4b2ef76b59a883357b0297b8e5acf69e",
    "plugins/system_diagnostics_plugin/processor.py": "80c5fccd455ce6ae5ab0befd1ca967e9cd0153c4e418a5a8a6a552b0b65e972f",
    "plugins/system_diagnostics_plugin/scanners/ai_copilot_health_scan.py": "a9af8c30c71e59e839342dd087767d2f9968abbfef0f22f9596c9491e7b2e9a5",
    "plugins/system_diagnostics_plugin/scanners/base_scanner.py": "01fb5495a9c2a307b4683881d72a477433f599c5a8bfcc2d2d7ca4760ed010cc",
    "plugins/system_diagnostics_plugin/scanners/cache_integrity_scan.py": "569069b657e26c67ca1f4e6018bebd411a7d4e7ad3b3a1d9e254052a4305ebec",
    "plugins/system_diagnostics_plugin/scanners/core_compiler_health_scan.py": "ecd5784405648cbb51b188b0ad9f4eb0115ba58e0fe68bc1a71240c2fc2a4993",
    "plugins/system_diagnostics_plugin/scanners/core_integrity_scan.py": "8c2f889d428dccb37b6e6d3e580e99197b2503b0a002fe3f9d8e63ca84742fdb",
    "plugins/system_diagnostics_plugin/scanners/data_preview_readiness_scan.py": "f4eb483ef32ce1806aea505e8d36fb2638c4052cba8d31abd839d87e97b8ace2",
    "plugins/system_diagnostics_plugin/scanners/manifest_completeness_scan.py": "7d53b81bea621fb233badbf14faeba5c4b4f6ceb8506f63eea82d35e4963cf42",
    "plugins/system_diagnostics_plugin/scanners/manifest_mismatch_scan.py": "9fb8a5cad43ed11044d42df0968969091d9b81625eac7f0949955f3405b9eac8",
    "plugins/system_diagnostics_plugin/scanners/marketplace_integrity_scan.py": "31229a809de95592025018109808c6d8c2e8d070d6b1e95b919aaa3203853312",
    "plugins/system_diagnostics_plugin/scanners/phase_one_integrity_scan.py": "2aaa991fa7c76b5d37df429120955dc0231135a43fa2248a642dfb5ba8fc296c",
    "plugins/system_diagnostics_plugin/scanners/tier_attribute_scan.py": "48d14a0874a6d91c5bb08d821e06c80290eb41148b6e6883fedd3949ce2b0d57",
    "pre_launcher.py": "a82b077eb380e10d83fa24c8720790463bac8d8fd7c79510ed3bf6125d185564",
    "requirements.txt": "1ae38cc32abe3e761f9c21d0e8169b177515bd7dcd0347f0ce317aa535d81d09",
    "scripts/bootstrap.py": "74d6b01e8d2e87687e4fdb0658660cc5d4cb77615c46612c03e18f2fe55f499c",
    "scripts/dependency_audit.py": "135bce7f0025f7a7998d662357aa362e2234de2eb43e9b1bfbd8287c9d0d8b78",
    "scripts/generate_docs.py": "a8ea0d26076afaac1a2d3eeecfd78d8a8a86fef93767a565469067b895ed8356",
    "scripts/setup.py": "308ee819ea5c72722b54371f7d458922c6efceffcf48259c40aae0144eb6f119",
    "teetah.gif": "0b5ebd13411445ca82fe734f9133bcf3e26c4c90da648f00be30af55f2f8ce1d",
    "tools/auto_refactor/refactor_engine.py": "9838520c4e719cc35b4c3512518e64c6368bff4949e6f99045cd210fbaaaf361",
    "tools/guardian_angel/event_handler.py": "2a5f1c92b21b7d7f175d7fe6976dbe90e8aa000540cdec20c0f1236f1fe35fcb",
    "tools/guardian_angel/guardian.py": "3309d6d57a0e4214da864edc6c318debbb9e0b8131687631f6b7110699ba0776",
    "triggers/cron_trigger/config_ui.py": "f580fa1aa05b62842281df219d2cf1cc85dc6441d9ad79c105f2c418cb074282",
    "triggers/event_bus_trigger/config_ui.py": "20324127521280f345c710aa90732cf6114029d14c5097789b5fbdf894465ec0",
    "triggers/event_bus_trigger/listener.awenkaudico": "e498da92fc75f345bf97a491eb0a78231ee858459fe3dbed8eb39f8a277a235a",
    "triggers/event_bus_trigger/listener.build/scons-debug.py": "9bd0682e32a75815a6be720db985978068bd1224ed459f766b5b95823330cd53",
    "triggers/event_bus_trigger/listener.py": "a01fa9588f537adaf2d0e62d9889d8d9f074a6bcb50fb7a49ae85dd38c4f18ef",
    "triggers/file_system_trigger/config_ui.py": "e4552ceb057f35185d080bb66ef8d518850a0cdbc380d5841f6be89ecdb6a37c",
    "triggers/file_system_trigger/listener.awenkaudico": "aa4b76032aa8429bd80ab911543f68d8925aa824ea35829420e0d31c6c8efecc",
    "triggers/file_system_trigger/listener.build/scons-debug.py": "5cd5961608ea3855c916815eda80b8856771a1c39c7182822f0b05cd82bbde50",
    "triggers/file_system_trigger/listener.py": "c65e6015ea8a5f05140b2e7b1e43b55717768ef48a4c1426a874244ce6225be0",
    "triggers/process_trigger/config_ui.py": "1f17519f6ac0f49cceff7c850a3f67c61ccd71cd04fc154baa14a66d4d1b4cce",
    "triggers/process_trigger/listener.awenkaudico": "4ca2caad70056fefa43b87958dbbff09ed5c91b2d0bc1c9c1dba53b872311c2c",
    "triggers/process_trigger/listener.build/scons-debug.py": "bc57ac227756c82a8c5b78e25fe5f4565b5d0751bb3764aa4b60031244c59c83",
    "triggers/process_trigger/listener.cp310-win_amd64.pyd": "5647f05ec18958947d32874eeb788fa396a05d0bab7c1b71f112ceb7e9b31eee",
    "triggers/process_trigger/listener.py": "26a22cb4316a3d13d3c5e7260516b50bbe308713e8263d5f624c98b7b2c8bd6f",
    "webhook.py": "31ed0d8a24cae86759b5243ea0bcb5b51d3c73b72a4603621d6d6a17cbc5e8d4"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\main.py
# JUMLAH BARIS : 68
#######################################################################

```py
import sys
import os
PROJECT_ROOT_FOR_LOGGER = os.path.dirname(os.path.abspath(__file__))
project_root_for_path = os.path.dirname(os.path.abspath(__file__))
libs_path = os.path.join(project_root_for_path, 'libs')
if project_root_for_path not in sys.path:
    sys.path.insert(0, project_root_for_path)
if libs_path not in sys.path:
    sys.path.insert(0, libs_path)
import logging
import datetime
import queue
import time
from importlib.machinery import SourcelessFileLoader, ExtensionFileLoader
import importlib.metadata
if project_root_for_path not in sys.path:
    sys.path.insert(0, project_root_for_path)
log_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'logs')
os.makedirs(log_dir, exist_ok=True)
log_file = os.path.join(log_dir, f"flowork_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
if __name__ == "__main__":
    project_root_path = os.path.dirname(os.path.abspath(__file__))
    PID_FILE = os.path.join(project_root_path, "server.pid")
    from flowork_kernel.core.permission_hook import PermissionHook
    sys.meta_path.insert(1, PermissionHook())
    kernel = None
    try:
        with open(PID_FILE, "w") as f:
            f.write(str(os.getpid()))
        from flowork_kernel.kernel import Kernel
        kernel = Kernel(project_root_path)
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
            ]
        )
        logging.info("Starting Flowork application...") # English Log
        kernel.start_all_services()
        kernel.write_to_log("Flowork Server is now running. Press Ctrl+C to stop.", "SUCCESS") # English Log
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            kernel.write_to_log("Server shutdown requested by user (Ctrl+C).", "INFO") # English Log
    except Exception as e:
        print(f"FATAL SERVER ERROR: {e}") # English Log
        logging.critical(f"A fatal error occurred during server startup: {e}", exc_info=True) # English Log
        sys.exit(1)
    finally:
        if kernel:
            kernel.write_to_log("Initiating graceful shutdown of all services.", "INFO") # English Log
            kernel.stop_all_services()
        if os.path.exists(PID_FILE):
            try:
                os.remove(PID_FILE)
            except OSError as e:
                print(f"Could not remove PID file: {e}")
        print("Flowork Server has been shut down.") # English Log
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\run_server.bat
# JUMLAH BARIS : 40
#######################################################################

```bat
@echo off
REM =================================================================
REM  File: run_server.bat
REM  Description: Starts FLOWORK server with LIVE console logging
REM               AND complete file logging using PowerShell.
REM  Version: 3.0 (FINAL)
REM =================================================================

SET "LOG_FILE=server.log"

REM --- Membuat file log baru dengan header timestamp ---
(
    echo =================================================================
    echo  LOG SESSION STARTED AT: %DATE% %TIME%
    echo =================================================================
    echo.
) > %LOG_FILE%

ECHO [INFO] Starting FLOWORK Server...
ECHO [INFO] Live output is shown below. A complete log is also being saved to %LOG_FILE%
ECHO -----------------------------------------------------------------
ECHO.

REM --- Menjalankan perintah utama dan 'membelah' outputnya ---
REM Output akan tampil di CMD ini DAN ditambahkan ke file log.
powershell -Command "& {poetry run python main.py 2>&1 | Tee-Object -FilePath '%LOG_FILE%' -Append}"

ECHO.
ECHO -----------------------------------------------------------------
ECHO [INFO] Server process has been terminated.
(
    echo.
    echo -----------------------------------------------------------------
    echo [INFO] Server process terminated.
    echo =================================================================
    echo  LOG SESSION ENDED AT: %DATE% %TIME%
    echo =================================================================
) >> %LOG_FILE%

pause
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\START.bat
# JUMLAH BARIS : 44
#######################################################################

```bat
@echo off
TITLE FLOWORK Server - Live Log

:: ==================================================================
:: == KONFIGURASI: Sesuaikan waktu tunggu jika server lambat.
::    Untuk komputer kebanyakan, 10 detik sudah lebih dari cukup.
set WAIT_SECONDS=25
:: ==================================================================

ECHO ==================================================================
ECHO ==            FLOWORK Unified Server Launcher (v.Ultimate)        ==
ECHO ==================================================================
ECHO.

ECHO [INFO] Preparing the environment...
ECHO [INFO] Project Root: %~dp0
ECHO [INFO] Checking Python version used by Poetry:
poetry run python --version
ECHO.

REM --- Beri jeda waktu yang bisa dikonfigurasi agar server punya waktu untuk siap ---
ECHO [INFO] Waiting for %WAIT_SECONDS% seconds to allow the server to initialize...
timeout /t %WAIT_SECONDS% /nobreak >nul

REM --- Buka browser setelah menunggu ---
ECHO [INFO] Opening Server Control Panel in browser...
ECHO [INFO] If you see an error, increase WAIT_SECONDS at the top of this script.
start http://127.0.0.1:8989/

ECHO.
ECHO ==================================================================
ECHO ==                 LIVE SERVER LOG STARTED                      ==
ECHO ==   (Log ini juga disimpan secara lengkap di server.log)       ==
ECHO ==================================================================
ECHO.

REM --- Jalankan server dengan perintah PowerShell yang canggih untuk menambahkan timestamp di setiap baris ---
powershell -Command "& {poetry run python main.py 2>&1 | ForEach-Object { '[{0}] {1}' -f (Get-Date -Format 'HH:mm:ss'), $_ } | Tee-Object -FilePath 'server.log' -Append}"

ECHO.
ECHO ==================================================================
ECHO ==                  SERVER PROCESS TERMINATED                   ==
ECHO ==================================================================
pause
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\webhook.py
# JUMLAH BARIS : 29
#######################################################################

```py
import requests
import json
preset_name = "test-webhook"
url = f"http://localhost:8989/webhook/{preset_name}"
payload = {
    "message_from_webhook": "Hello from the Python script!",
    "data_source": "Automated Test"
}
headers = {
    "Content-Type": "application/json"
}
try:
    print(f"Sending POST request to: {url}")
    print(f"With data: {json.dumps(payload, indent=2)}")
    response = requests.post(url, data=json.dumps(payload), headers=headers)
    print(f"\nStatus Code: {response.status_code}")
    print("Server Response:")
    print(response.json())
except requests.exceptions.ConnectionError as e:
    print(f"\n[ERROR] Failed to connect to the server. Make sure the Flowork application is running.")
    print(f"Details: {e}")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\ai_providers\BaseAIProvider.py
# JUMLAH BARIS : 43
#######################################################################

```py
from abc import ABC, abstractmethod
class BaseAIProvider(ABC):
    """
    The abstract base class (contract) that all AI Providers must implement.
    [UPGRADED] Now holds its own manifest data.
    [UPGRADED V2] Now includes a standard readiness check method.
    """
    def __init__(self, kernel, manifest: dict):
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        self.manifest = manifest
    @abstractmethod
    def get_provider_name(self) -> str:
        """
        Returns the display name of the provider.
        """
        raise NotImplementedError
    @abstractmethod
    def generate_response(self, prompt: str) -> dict:
        """
        Processes a prompt and returns a standardized dictionary.
        """
        raise NotImplementedError
    @abstractmethod
    def is_ready(self) -> tuple[bool, str]:
        """
        Checks if the provider is properly configured and ready to accept requests.
        Returns a tuple of (is_ready: bool, message: str).
        """
        raise NotImplementedError
    def get_manifest(self) -> dict:
        """
        Returns the manifest data for this provider.
        """
        return self.manifest
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\ai_providers\text\chatgpt_provider\manifest.json
# JUMLAH BARIS : 17
#######################################################################

```json
{
    "id": "chatgpt_provider",
    "name": "OpenAI ChatGPT Provider",
    "version": "1.0",
    "author": "AWENK AUDICO",
    "description": "Provides connectivity and chat functionality with OpenAI's GPT models.",
    "type": "AI_PROVIDER",
    "entry_point": "provider.ChatGPTProvider",
    "category": "text",
    "requires_variables": [
        {
            "name": "OPENAI_API_KEY",
            "description": "Your API Key from OpenAI Platform to access GPT models.",
            "is_secret": true
        }
    ]
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\ai_providers\text\chatgpt_provider\provider.py
# JUMLAH BARIS : 39
#######################################################################

```py
from flowork_kernel.core import build_security
from flowork_kernel.api_contract import BaseAIProvider
from .core.ChatGPTConnection import ChatGPTConnection
class ChatGPTProvider(BaseAIProvider):
    """
    Provides a connection to OpenAI's ChatGPT models.
    """
    def __init__(self, kernel, manifest: dict):
        build_security.perform_runtime_check(__file__)
        super().__init__(kernel, manifest)
        self.connection = ChatGPTConnection(self.kernel)
    def get_provider_name(self) -> str:
        return "OpenAI ChatGPT"
    def is_ready(self) -> tuple[bool, str]:
        """Checks if the OpenAI API key is configured."""
        if self.connection.configure():
            return (True, "")
        else:
            return (False, "ChatGPT Provider is not configured. Check for a valid OPENAI_API_KEY in Settings.")
    def generate_response(self, prompt: str) -> dict:
        """
        Processes a prompt using ChatGPT and returns a standardized dictionary.
        """
        is_ready, message = self.is_ready()
        if not is_ready:
            return {"type": "text", "data": f"ERROR: {message}"}
        response_dict = self.connection.get_chat_completion(prompt)
        if "error" in response_dict:
            return {"type": "text", "data": f"CHATGPT_API_ERROR: {response_dict['error']}"}
        else:
            return {"type": "text", "data": response_dict['data']}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\ai_providers\text\chatgpt_provider\core\ChatGPTConnection.py
# JUMLAH BARIS : 57
#######################################################################

```py
import openai
class ChatGPTConnection:
    """Handles the connection and authentication to the OpenAI API."""
    def __init__(self, kernel):
        self.kernel = kernel
        self.is_configured = False
        self.client = None
    def configure(self):
        """
        Configures the openai library with the API key from Variable Manager.
        Returns True on success, False on failure.
        """
        if self.is_configured:
            return True
        variable_manager = self.kernel.get_service("variable_manager")
        if not variable_manager:
            self.kernel.write_to_log("Cannot configure ChatGPT: VariableManager service not available.", "CRITICAL") # English Log
            return False
        api_key = variable_manager.get_variable("OPENAI_API_KEY")
        if not api_key:
            self.kernel.write_to_log("OPENAI_API_KEY not found in Variable Manager.", "ERROR") # English Log
            return False
        try:
            self.client = openai.OpenAI(api_key=api_key)
            self.is_configured = True
            self.kernel.write_to_log("OpenAI (ChatGPT) has been configured successfully.", "SUCCESS") # English Log
            return True
        except Exception as e:
            self.kernel.write_to_log(f"Failed to configure OpenAI client: {e}", "ERROR") # English Log
            return False
    def get_chat_completion(self, prompt: str) -> dict:
        """
        Sends a prompt to the OpenAI API and gets a response.
        Returns a dictionary with either 'data' or 'error'.
        """
        if not self.is_configured or not self.client:
            return {"error": "OpenAI client is not configured."}
        try:
            response = self.client.chat.completions.create(
                model="gpt-3.5-turbo", # You can change the model here
                messages=[
                    {"role": "system", "content": "You are a helpful assistant."},
                    {"role": "user", "content": prompt}
                ]
            )
            return {"data": response.choices[0].message.content}
        except Exception as e:
            self.kernel.write_to_log(f"OpenAI API request failed: {e}", "ERROR") # English Log
            return {"error": str(e)}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\ai_providers\text\gemini_provider\manifest.json
# JUMLAH BARIS : 17
#######################################################################

```json
{
    "id": "gemini_provider",
    "name": "Google Gemini AI Provider",
    "version": "1.0",
    "author": "AWENK AUDICO",
    "description": "Menyediakan konektivitas dan fungsionalitas chat dengan model AI Google Gemini.",
    "type": "AI_PROVIDER",
    "entry_point": "provider.GeminiProvider",
    "category": "text",
    "requires_variables": [
        {
            "name": "GEMINI_API_KEY",
            "description": "API Key Anda dari Google AI Studio untuk mengakses model Gemini.",
            "is_secret": true
        }
    ]
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\ai_providers\text\gemini_provider\provider.py
# JUMLAH BARIS : 65
#######################################################################

```py
from flowork_kernel.core import build_security
from flowork_kernel.core import build_security
from flowork_kernel.core import build_security
from flowork_kernel.core import build_security
from flowork_kernel.api_contract import BaseAIProvider
from .core.GeminiConnection import GeminiConnection
import google.generativeai as genai
class GeminiProvider(BaseAIProvider):
    TIER = "basic"
    """
    Provides a connection to Google's Gemini AI models.
    """
    def __init__(self, kernel, manifest: dict):
        build_security.perform_runtime_check(__file__)
        build_security.perform_runtime_check(__file__)
        build_security.perform_runtime_check(__file__)
        build_security.perform_runtime_check(__file__)
        super().__init__(kernel, manifest)
        self.connection = GeminiConnection(self.kernel)
        self.chat_sessions = {}
    def get_provider_name(self) -> str:
        return self.loc.get("gemini_provider_name", fallback="Google Gemini")
    def is_ready(self) -> tuple[bool, str]:
        """Checks if the Gemini API key is configured."""
        if self.connection.configure():
            return (True, "")
        else:
            return (False, self.loc.get('gemini_provider_err_not_configured', fallback="Gemini Provider is not configured. Check for a valid GEMINI_API_KEY in Settings."))
    def generate_response(self, prompt: str) -> dict:
        is_ready, message = self.is_ready()
        if not is_ready:
            return {"type": "text", "data": f"ERROR: {message}"}
        prompt_lower = prompt.lower()
        response_type = "text"
        keyword_map = {
            "audio_file": ["musik", "lagu", "sound", "audio"],
            "image_url": ["gambar", "lukisan", "image", "foto"],
            "code": ["kode", "script", "program"],
            "json": ["analisa", "data", "csv", "json"]
        }
        for r_type, keywords in keyword_map.items():
            if any(keyword in prompt_lower for keyword in keywords):
                response_type = r_type
                break
        try:
            model = genai.GenerativeModel('gemini-1.5-flash-latest')
            generation_prompt = prompt
            if response_type != "text":
                generation_prompt = self.loc.get(
                    'gemini_text_generation_prompt_wrapper',
                    fallback="Generate a text response for this request: '{prompt}'",
                    prompt=prompt
                )
            response = model.generate_content(generation_prompt)
            return { "type": response_type, "data": response.text }
        except Exception as e:
            return { "type": "text", "data": f"GEMINI_API_ERROR: {e}" }
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\ai_providers\text\gemini_provider\core\GeminiChatSession.py
# JUMLAH BARIS : 27
#######################################################################

```py
import google.generativeai as genai
class GeminiChatSession:
    """Manages the state of a single, continuous chat session with a Gemini model."""
    def __init__(self, model_name="gemini-pro"):
        self.model = genai.GenerativeModel(model_name)
        self.chat_session = self.model.start_chat(history=[])
    def send_message(self, prompt: str) -> str:
        """
        Sends a message to the ongoing chat session and returns the model's response.
        """
        try:
            response = self.chat_session.send_message(prompt)
            return response.text
        except Exception as e:
            return f"Error during chat: {e}"
    @property
    def history(self):
        """Returns the current chat history."""
        return self.chat_session.history
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\ai_providers\text\gemini_provider\core\GeminiConnection.py
# JUMLAH BARIS : 37
#######################################################################

```py
import google.generativeai as genai
class GeminiConnection:
    """Handles the connection and authentication to the Google AI API."""
    def __init__(self, kernel):
        self.kernel = kernel
        self.is_configured = False
    def configure(self):
        """
        Configures the genai library with the API key from Variable Manager.
        Returns True on success, False on failure.
        """
        if self.is_configured:
            return True
        variable_manager = self.kernel.get_service("variable_manager")
        if not variable_manager:
            self.kernel.write_to_log("Cannot configure Gemini: VariableManager service not available.", "CRITICAL") # English Log
            return False
        api_key = variable_manager.get_variable("GEMINI_API_KEY")
        if not api_key:
            self.kernel.write_to_log("GEMINI_API_KEY not found in Variable Manager.", "ERROR")
            return False
        try:
            genai.configure(api_key=api_key)
            self.is_configured = True
            self.kernel.write_to_log("Google AI (Gemini) has been configured successfully.", "SUCCESS")
            return True
        except Exception as e:
            self.kernel.write_to_log(f"Failed to configure Gemini: {e}", "ERROR")
            return False
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\ai_providers\text\gemini_provider\locales\en.json
# JUMLAH BARIS : 3
#######################################################################

```json
{
    "gemini_text_generation_prompt_wrapper": "Generate a text response for this request: '{prompt}'"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\ai_providers\text\gemini_provider\locales\id.json
# JUMLAH BARIS : 3
#######################################################################

```json
{
    "gemini_text_generation_prompt_wrapper": "Hasilkan respons teks untuk permintaan ini: '{prompt}'"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_cli\cli.py
# JUMLAH BARIS : 37
#######################################################################

```py
import sys
import argparse
from .core.api_client import ApiClient
def main():
    """
    The main function for the CLI.
    Now includes argument parsing for different commands.
    """
    parser = argparse.ArgumentParser(description="Flowork Command-Line Interface")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    parser_status = subparsers.add_parser("status", help="Check the connection status to the Flowork API server.")
    args = parser.parse_args()
    print("--- Flowork CLI Initializing ---")
    api = ApiClient()
    if args.command == "status":
        print("Attempting to connect to Flowork server...")
        success, response = api.get_server_status()
        if success:
            server_status = response.get('status', 'unknown')
            kernel_version = response.get('version', 'N/A')
            print(f"✅ Connection successful!")
            print(f"   Server Status: {server_status}")
            print(f"   Kernel Version: {kernel_version}")
        else:
            print(f"❌ Connection failed: {response}")
            sys.exit(1)
    else:
        print("No command provided. Use 'status' to check server connection.")
        print("Example: poetry run python -m flowork_cli status")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_cli\__main__.py
# JUMLAH BARIS : 11
#######################################################################

```py
from . import cli
if __name__ == "__main__":
    cli.main()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_cli\core\api_client.py
# JUMLAH BARIS : 38
#######################################################################

```py
import requests
import json
import os
class ApiClient:
    """
    A client to interact with the local Flowork API server.
    This version is completely decoupled from the kernel.
    """
    def __init__(self, base_url="http://localhost:8989/api/v1"):
        self.base_url = base_url
    def _handle_response(self, response):
        """A helper to handle JSON responses and potential errors."""
        if 200 <= response.status_code < 300:
            if response.status_code == 204 or not response.content:
                return True, {}
            return True, response.json()
        else:
            try:
                error_data = response.json()
                message = error_data.get("error", "Unknown API error")
            except json.JSONDecodeError:
                message = response.text
            return False, message
    def get_server_status(self):
        """Pings the server to check if it's alive."""
        try:
            response = requests.get(f"{self.base_url}/status", timeout=3)
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}"
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\api_contract.py
# JUMLAH BARIS : 94
#######################################################################

```py
import ttkbootstrap as ttk
from typing import Dict, Any, List
from tkinter import StringVar
from abc import ABC, abstractmethod
class FloworkException(Exception):
    """Base exception for all custom errors in the application."""
    pass
class PermissionDeniedError(FloworkException):
    """Raised when an action is attempted without the required license tier or permission."""
    pass
class BaseDashboardWidget(ttk.Frame):
    """
    Client-side base class for all dashboard widgets.
    Provides a consistent structure and initialization.
    """
    def __init__(self, parent, coordinator_tab, kernel, widget_id: str, **kwargs):
        super().__init__(parent, **kwargs)
        self.parent = parent
        self.coordinator_tab = coordinator_tab
        self.kernel = kernel
        self.loc = self.kernel.loc
        self.api_client = self.kernel.api_client
        self.widget_id = widget_id
    def on_widget_load(self):
        """Called by DashboardManager when the widget is created and displayed."""
        pass
    def on_widget_destroy(self):
        """Called by DashboardManager just before the widget is destroyed."""
        pass
    def refresh_content(self):
        """Called when a global UI refresh is requested."""
        pass
class IDataPreviewer(ABC):
    """
    An optional interface for modules that can provide a real-time preview
    of their potential output data based on their current configuration.
    This is the foundation for the "Data Canvas" feature.
    """
    @abstractmethod
    def get_data_preview(self, config: Dict[str, Any]) -> Any:
        """
        Executes a limited, sample version of the module's logic to return a data preview.
        This method MUST NOT have side effects and should return quickly.
        Args:
            config: The current configuration values from the properties UI.
        Returns:
            A sample of the data the module would produce (e.g., a list of dicts, a string).
        """
        raise NotImplementedError
class LoopConfig:
    """
    Data structure for defining looping configuration for a step.
    This is used within module properties or as part of the node data.
    """
    LOOP_TYPE_COUNT = "count"
    LOOP_TYPE_CONDITION = "condition"
    def __init__(self, loop_type: str = LOOP_TYPE_COUNT, iterations: int = 1, condition_var: str = None, condition_op: str = None, condition_val: Any = None,
                 enable_sleep: bool = False, sleep_type: str = "static", static_duration: int = 1, random_min: int = 1, random_max: int = 5):
        self.loop_type = loop_type
        self.iterations = iterations
        self.condition_var = condition_var
        self.condition_op = condition_op
        self.condition_val = condition_val
        self.enable_sleep = enable_sleep
        self.sleep_type = sleep_type
        self.static_duration = static_duration
        self.random_min = random_min
        self.random_max = random_max
class EnumVarWrapper:
    """
    Wrapper for a StringVar that handles conversion between UI labels (which are localized)
    and internal values for enum-type properties.
    """
    def __init__(self, string_var: StringVar, label_to_value_map: Dict[str, str], value_to_label_map: Dict[str, str]):
        self.sv = string_var
        self.label_to_value_map = label_to_value_map
        self.value_to_label_map = value_to_label_map
    def get(self):
        """Returns the actual internal value."""
        return self.label_to_value_map.get(self.sv.get(), self.sv.get())
    def set(self, value):
        """Sets the StringVar based on the provided internal value."""
        self.sv.set(self.value_to_label_map.get(value, value))
    def trace_add(self, mode, callback):
        """Passes the trace call to the underlying StringVar."""
        self.sv.trace_add(mode, callback)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\api_key.json
# JUMLAH BARIS : 1
#######################################################################

```json
{"api_key": "I652SAQD77"}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\backup.py
# JUMLAH BARIS : 47
#######################################################################

```py
import os
import sys
def main():
    """
    Scans the project directory for all .py files, formats them into a markdown file,
    and saves it as backup.md. This script is designed to package the current
    state of the code for analysis or sharing.
    """
    project_root = os.getcwd()
    output_filename = "GUI.md"
    ignore_dirs = {'.venv', '__pycache__', 'python','vendor'}
    all_content = []
    print("[INFO] Starting code backup process...") # English Log
    for root, dirs, files in os.walk(project_root, topdown=True):
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
        for file in sorted(files):
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                relative_path = os.path.relpath(file_path, project_root)
                print(f"[INFO] Processing: {relative_path}") # English Log
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                        line_count = len(content.splitlines())
                    header = (
                        f"\n\n"
                    )
                    formatted_content = f"```py\n{content}\n```"
                    all_content.append(header + formatted_content)
                except Exception as e:
                    print(f"[ERROR] Could not process file {relative_path}: {e}") # English Log
    try:
        with open(output_filename, 'w', encoding='utf-8') as f:
            f.write("\n\n".join(all_content))
        print(f"\n[SUCCESS] Backup complete! All code saved to '{output_filename}'") # English Log
    except Exception as e:
        print(f"\n[FATAL] Failed to write backup file: {e}") # English Log
if __name__ == "__main__":
    main()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\exceptions.py
# JUMLAH BARIS : 38
#######################################################################

```py
"""
Central repository for all custom Flowork exceptions for the GUI Client.
This allows for specific error handling and clearer debugging on the client-side.
"""
class FloworkException(Exception):
    """Base exception for all custom errors in the application."""
    pass
class PresetNotFoundError(FloworkException):
    """Raised when a specified workflow preset cannot be found."""
    pass
class ModuleValidationError(FloworkException):
    """Raised when a module's property validation fails."""
    pass
class ApiKeyMissingError(FloworkException):
    """Raised when a required API key is not found in the Variable Manager."""
    pass
class DependencyError(FloworkException):
    """Raised when installing a module's requirements.txt fails."""
    pass
class SignatureVerificationError(FloworkException):
    """Raised when a digital signature from an online resource is invalid."""
    pass
class MandatoryUpdateRequiredError(FloworkException):
    """Raised by the StartupService when a mandatory update is detected."""
    def __init__(self, message, update_info=None):
        super().__init__(message)
        self.update_info = update_info or {}
class PermissionDeniedError(FloworkException):
    """Raised when an action is attempted without the required license tier or permission."""
    pass
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\fix_imports.py
# JUMLAH BARIS : 75
#######################################################################

```py
import os
import re
def fix_imports_in_file(file_path):
    """Reads a file, fixes imports based on new rules, and writes it back."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
    except Exception:
        return 0
    new_lines = []
    changes_made = 0
    for line in lines:
        stripped_line = line.strip()
        if stripped_line.startswith('#'):
            new_lines.append(line)
            continue
        match1 = re.match(r"^\s*from\s+flowork_gui\.([\w.]+)\s+import\s+.*", stripped_line)
        if match1:
            corrected_import = stripped_line.replace("flowork_gui.", "", 1)
            new_lines.append(f"# {stripped_line} # (PERBAIKAN OTOMATIS v2)\n")
            new_lines.append(f"{corrected_import}\n")
            changes_made += 1
            continue
        match2 = re.match(r"^\s*from\s+flowork_kernel\.ui_shell\.([\w.]+)\s+import\s+.*", stripped_line)
        if match2:
            corrected_import = stripped_line.replace("flowork_kernel.ui_shell", "views", 1)
            new_lines.append(f"# {stripped_line} # (PERBAIKAN OTOMATIS v2)\n")
            new_lines.append(f"{corrected_import}\n")
            changes_made += 1
            continue
        new_lines.append(line)
    if changes_made > 0:
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.writelines(new_lines)
            print(f"  - Patched {changes_made} import(s) in: {os.path.basename(file_path)}")
            return changes_made
        except Exception:
            return 0
    return 0
def main():
    """Main function to run the import fixer."""
    project_root = os.path.dirname(os.path.abspath(__file__))
    print("\n--- Starting Automatic Import Fixer Script v2.0 ---")
    print(f"Scanning project root: {project_root}\n")
    total_files_patched = 0
    total_fixes_made = 0
    for root, _, files in os.walk(project_root):
        if '__pycache__' in root or '.venv' in root:
            continue
        for file in files:
            if file.endswith(".py"):
                file_path = os.path.join(root, file)
                if os.path.basename(file_path) == "fix_imports.py":
                    continue
                fixes = fix_imports_in_file(file_path)
                if fixes > 0:
                    total_files_patched += 1
                    total_fixes_made += fixes
    print("\n--- Doctor Script v2.0 Finished ---")
    if total_fixes_made > 0:
        print(f"✅ Success! Made {total_fixes_made} fixes across {total_files_patched} files.")
        print("All import paths should now be corrected.")
    else:
        print("✅ No incorrect imports found. Everything looks good!")
if __name__ == "__main__":
    main()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\gui_config.json
# JUMLAH BARIS : 3
#######################################################################

```json
{
    "server_url": "http://127.0.0.1:8989"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\main_gui.py
# JUMLAH BARIS : 243
#######################################################################

```py
import tkinter as tk
from tkinter import ttk
import threading
import subprocess
import os
import sys
import time
import traceback
import json
import ttkbootstrap as ttk
import websocket
def ensure_required_files_exist():
    """
    Checks for and creates necessary __init__.py files AND other critical files like exceptions.py.
    This makes the GUI package truly self-healing and robust against missing files.
    """
    print("[INFO] Verifying project structure and required files...") # English Log
    try:
        project_root = os.path.dirname(os.path.abspath(__file__))
        required_package_dirs = [
            ".", "api_client", "core", "utils", # Root level packages
            "views", "views/canvas_components", "views/canvas_components/interactions",
            "views/components", "views/custom_widgets", "views/lifecycle", "views/popups",
            "views/ui_components", "views/ui_components/controllers",
            "plugins", "plugins/flowork_core_ui", "plugins/flowork_core_ui/components",
            "plugins/flowork_core_ui/generator_components", "plugins/flowork_core_ui/settings_components",
            "plugins/metrics_dashboard", "plugins/metrics_logger_plugin",
            "plugins/system_diagnostics_plugin", # <-- INI YANG KURANG KEMARIN
            "widgets", "widgets/canvas_area", "widgets/data_canvas_widget",
            "widgets/dataset_manager_widget", "widgets/logic_toolbox_widget", "widgets/log_viewer_widget",
            "widgets/plugin_toolbox_widget", "widgets/prompt_sender_widget", "widgets/widget_toolbox"
        ]
        for rel_dir in required_package_dirs:
            dir_path = os.path.join(project_root, rel_dir.replace('/', os.sep)) # Handle path separators
            init_path = os.path.join(dir_path, "__init__.py")
            if not os.path.exists(init_path):
                os.makedirs(dir_path, exist_ok=True)
                with open(init_path, 'w') as f: pass
                print(f"  -> [AUTO-FIX] Created missing package file: {os.path.join(os.path.basename(project_root), rel_dir, '__init__.py')}") # English Log
        exceptions_file_path = os.path.join(project_root, "exceptions.py")
        if not os.path.exists(exceptions_file_path):
            print(f"  -> [AUTO-FIX] Critical file 'exceptions.py' not found. Creating it now...") # English Log
            exceptions_content = '''"""
Central repository for all custom Flowork exceptions for the GUI Client.
"""
class FloworkException(Exception): pass
class PermissionDeniedError(FloworkException): pass
'''
            with open(exceptions_file_path, 'w', encoding='utf-8') as f:
                f.write(exceptions_content)
    except Exception as e:
        print(f"  -> [ERROR] Could not perform self-healing setup: {e}") # English Log
ensure_required_files_exist()
project_root_for_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
if project_root_for_path not in sys.path:
    sys.path.insert(0, project_root_for_path)
from flowork_gui.api_client.client import ApiClient
from flowork_gui.views.ui_components.menubar_manager import MenubarManager
from flowork_gui.views.ui_components.tab_manager import UITabManager
from flowork_gui.views.custom_widgets.draggable_notebook import DraggableNotebook
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__)))
PID_FILE = os.path.join(project_root, "pre_launcher.pid")
GIF_PATH = os.path.join(project_root, "teetah.gif")
DEV_MODE_FILE = os.path.join(project_root, "devmode.on")
API_KEY_FILE = os.path.join(os.path.dirname(__file__), "api_key.json")
DEV_MODE_PUBLIC_KEY = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAysqZG2+F82W0TgLHmF3Y
0GRPEZvXvmndTY84N/wA1ljt+JxMBVsmcVTkv8f1TrmFRD19IDzl2Yzb2lgqEbEy
GFxHhudC28leDsVEIp8B+oYWVm8Mh242YKYK8r5DAvr9CPQivnIjZ4BWgKKddMTd
harVxLF2CoSoTs00xWKd6VlXfoW9wdBvoDVifL+hCMepgLLdQQE4HbamPDJ3bpra
pCgcAD5urmVoJEUJdjd+Iic27RBK7jD1dWDO2MASMh/0IyXyM8i7RDymQ88gZier
U0OdWzeCWGyl4EquvR8lj5GNz4vg2f+oEY7h9AIC1f4ARtoihc+apSntqz7nAqa/
sQIDAQAB
-----END PUBLIC KEY-----"""
class ApplicationWindow(ttk.Window):
    def __init__(self, api_client):
        super().__init__(themename="darkly")
        self.api_client = api_client
        self.withdraw()
        self.title("FLOWORK GUI") # English Hardcode
        self.tab_manager = None
        self.menubar_manager = None
        self.websocket_thread = None
        self.websocket_connection = None
        self.preloader = ttk.Toplevel(self)
        self.preloader.overrideredirect(True)
        self.preloader.attributes('-topmost', True)
        width, height = 300, 180
        screen_width, screen_height = self.winfo_screenwidth(), self.winfo_screenheight()
        x, y = (screen_width // 2) - (width // 2), (screen_height // 2) - (height // 2)
        self.preloader.geometry(f'{width}x{height}+{x}+{y}')
        self.preloader.config(bg="#2c3e50")
        preloader_style = ttk.Style()
        preloader_style.configure("Preload.TLabel", background="#2c3e50", foreground="#ecf0f1", font=("Helvetica", 11))
        logo_label = ttk.Label(self.preloader, style="Preload.TLabel")
        logo_label.pack(pady=(20, 10))
        try:
            self.logo_photo = tk.PhotoImage(file=GIF_PATH)
            logo_label.config(image=self.logo_photo)
        except Exception:
            logo_label.config(text="Teetah") # Fallback text
        self.status_label = ttk.Label(self.preloader, text="Initializing GUI...", style="Preload.TLabel") # English Hardcode
        self.status_label.pack(pady=(5, 20), fill="x", padx=10)
    def update_status(self, text):
        if self.preloader.winfo_exists():
            self.status_label.config(text=text)
    def close_preloader(self):
        if self.preloader.winfo_exists():
            self.preloader.destroy()
    def initialize_main_ui(self):
        self.close_preloader()
        class TempLoc:
            def __init__(self):
                self.language_map = {"en": "English", "id": "Bahasa Indonesia"}
            def get(self, key, fallback=None, **kwargs):
                if fallback is None:
                    return f"[{key}]"
                return fallback.format(**kwargs)
            def get_available_languages_display(self):
                return list(self.language_map.values())
        self.loc = TempLoc()
        self.title(self.loc.get('app_title', fallback="FLOWORK - API Driven"))
        self.geometry("1280x800")
        self.menubar_manager = MenubarManager(self, self.api_client, self.loc)
        self.menubar_manager.build_menu()
        self.create_main_widgets()
        self.tab_manager = UITabManager(self, self.notebook, self.api_client, self.loc)
        self.notebook.set_close_tab_command(lambda tab_id: self.tab_manager.close_tab(tab_id))
        self.tab_manager.load_session_state()
        self.deiconify()
        self._start_websocket_thread()
    def _start_websocket_thread(self):
        if self.websocket_thread and self.websocket_thread.is_alive():
            return
        self.websocket_thread = threading.Thread(target=self._maintain_websocket_connection, daemon=True)
        self.websocket_thread.start()
    def _maintain_websocket_connection(self):
        ws_url = self.api_client.base_url.replace("http", "ws") + "/ws/status"
        print(f"Attempting to connect to WebSocket at: {ws_url}") # English Log
        while True:
            try:
                ws = websocket.create_connection(ws_url)
                self.websocket_connection = ws
                print("WebSocket connection established successfully.") # English Log
                while True:
                    ws.recv()
            except websocket.WebSocketConnectionClosedException:
                print("WebSocket connection closed. Reconnecting in 5 seconds...") # English Log
            except ConnectionRefusedError:
                print("WebSocket connection refused. Server might be down. Retrying in 5 seconds...") # English Log
            except Exception as e:
                print(f"An unexpected WebSocket error occurred: {e}. Retrying in 5 seconds...") # English Log
            self.websocket_connection = None
            time.sleep(5)
    def create_main_widgets(self):
        tab_bar_frame = ttk.Frame(self)
        tab_bar_frame.pack(fill='x', padx=5, pady=(5, 0))
        ttk.Button(tab_bar_frame,
                   text=self.loc.get('save_session_button', fallback="Save Session & Layout"),
                   style="info.TButton").pack(side="right", anchor='n', pady=2, padx=(2, 0))
        ttk.Button(tab_bar_frame,
                   text=self.loc.get('clear_cache_button', fallback="Clear Cache"),
                   style="secondary.TButton").pack(side="right", anchor='n', pady=2, padx=(2, 0))
        ttk.Button(tab_bar_frame, text=self.loc.get('clear_layout_button', fallback="Clear Layout"),
                   style="danger.TButton").pack(side="right", anchor='n', pady=2, padx=(2, 0))
        add_button = ttk.Button(tab_bar_frame, text="+", width=2,
                                command=lambda: self.tab_manager.add_new_workflow_tab(),
                                style="success.TButton")
        add_button.pack(side="right", anchor="n", pady=2, padx=(2, 0))
        self.notebook = DraggableNotebook(self, loc=self.loc)
        self.notebook.pack(expand=True, fill="both", padx=5, pady=(0, 5))
    def check_server_status(self):
        pass
def _validate_dev_mode():
    if not os.path.exists(DEV_MODE_FILE):
        return False
    try:
        with open(DEV_MODE_FILE, 'r', encoding='utf-8') as f:
            content = f.read().strip()
        if content == DEV_MODE_PUBLIC_KEY.strip():
            print("DEV MODE VALIDATED: Key matches.") # English log
            return True
        else:
            print("DEV MODE FAILED: Key does not match.") # English log
            return False
    except Exception as e:
        print(f"DEV MODE FAILED: Error reading file - {e}") # English log
        return False
def connect_to_server_task(app_window):
    try:
        is_dev_mode = _validate_dev_mode()
        if is_dev_mode:
            app_window.update_status("DEVELOPMENT MODE ACTIVE") # English Hardcode
            time.sleep(1)
        api_client = app_window.api_client
        max_retries = 10
        retry_delay = 2
        for attempt in range(max_retries):
            app_window.update_status(f"Connecting to server at {api_client.base_url}...\n(Attempt {attempt + 1}/{max_retries})")
            status = api_client.get_server_status()
            if status and status.get("status") == "ok":
                api_key = status.get("api_key")
                if api_key:
                    api_client.api_key = api_key
                    with open(API_KEY_FILE, 'w', encoding='utf-8') as f:
                        json.dump({"api_key": api_key}, f)
                    print(f"[INFO] Secure API key received and set for this session.") # English Log
                app_window.update_status("Connection successful!\nLaunching main window...") # English Hardcode
                time.sleep(1)
                app_window.after(100, app_window.initialize_main_ui)
                return
            time.sleep(retry_delay)
        error_message = (f"Failed to connect to the server at {api_client.base_url} after {max_retries} attempts.\n\n"
                         f"Please ensure the FLOWORK server is running and the URL in 'gui_config.json' is correct.")
        raise ConnectionError(error_message)
    except Exception as e:
        error_message = f"A fatal error occurred:\n{e}" # English Hardcode
        app_window.update_status(error_message)
        print(traceback.format_exc())
        time.sleep(15)
        app_window.destroy()
if __name__ == "__main__":
    try:
        with open(PID_FILE, "w", encoding="utf-8") as f:
            f.write(str(os.getpid()))
        client = ApiClient()
        app = ApplicationWindow(api_client=client)
        threading.Thread(target=connect_to_server_task, args=(app,), daemon=True).start()
        app.mainloop()
    finally:
        if os.path.exists(PID_FILE):
            try:
                os.remove(PID_FILE)
            except OSError:
                pass
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\run_gui.bat
# JUMLAH BARIS : 62
#######################################################################

```bat
#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\Users\User\Desktop\flowork_gui\run_gui.bat
# JUMLAH BARIS : 53
#######################################################################

@echo off
REM =================================================================
REM  File: run_gui.bat
REM  Description: Installs dependencies and starts the STANDALONE FLOWORK GUI.
REM  Version: 7.0 (Self-installing)
REM =================================================================

REM COMMENT: The current directory IS the GUI project directory.
SET "GUI_PROJECT_DIR=%~dp0"
SET "LOG_FILE=%GUI_PROJECT_DIR%gui.log"

REM --- (DIHAPUS SEMENTARA) Pembuatan header log akan dihandle oleh Python ---
REM (
REM     echo =================================================================
REM     echo  LOG SESSION STARTED AT: %DATE% %TIME%
REM     echo =================================================================
REM     echo.
REM ) > "%LOG_FILE%"

ECHO [INFO] Preparing FLOWORK GUI Environment...
ECHO [INFO] Syncing dependencies from pyproject.toml. This may take a moment on first run...

REM ADDED: The crucial step to install GUI-specific dependencies.
poetry install --no-root
IF %ERRORLEVEL% NEQ 0 (
    ECHO [FATAL] Failed to install GUI dependencies using Poetry.
    pause
    exit /b
)

ECHO [INFO] Starting FLOWORK GUI (Standalone)...
ECHO [INFO] Environment is ready.
ECHO [INFO] A complete log is being saved to %LOG_FILE%
ECHO -----------------------------------------------------------------
ECHO.

REM --- (PERBAIKAN) Menjalankan Python secara langsung, tanpa Tee-Object ---
REM --- Python script will now handle its own logging. ---
REM powershell -Command "& {poetry run python main_gui.py 2>&1 | Tee-Object -FilePath '%LOG_FILE%' -Append}"
poetry run python main_gui.py

ECHO.
ECHO -----------------------------------------------------------------
ECHO [INFO] GUI process has been terminated.
(
    echo.
    echo -----------------------------------------------------------------
    echo [INFO] GUI process terminated.
    echo =================================================================
    echo  LOG SESSION ENDED AT: %DATE% %TIME%
    echo =================================================================
) >> "%LOG_FILE%"

pause
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\api_client\client.py
# JUMLAH BARIS : 241
#######################################################################

```py
import requests
import json
import os
import threading
import time
GUI_CONFIG_FILE = os.path.join(os.path.dirname(__file__), "..", "gui_config.json")
API_KEY_FILE = os.path.join(os.path.dirname(__file__), "..", "api_key.json")
class ApiClient:
    """
    Handles all HTTP communication with the FLOWORK server kernel.
    (REFACTORED) Now reads the server URL from a config file to be fully portable.
    """
    def __init__(self, kernel=None):
        self.base_url = self._load_server_url()
        self.api_key = self._load_api_key()
        self.marketplace_repo_owner = "FLOWORK-gif" # This could be configurable in the future
        self.marketplace_repo_name = "addon"
        self.marketplace_branch = "main"
        self.cache = {}
        self.cache_lock = threading.Lock()
        print(f"ApiClient initialized for server at {self.base_url}") # English Log
    def _load_server_url(self):
        """
        ADDED: Loads the server URL from gui_config.json.
        Creates a default if it doesn't exist.
        """
        default_url = "http://127.0.0.1:8989"
        try:
            if os.path.exists(GUI_CONFIG_FILE):
                with open(GUI_CONFIG_FILE, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                    url = config.get("server_url")
                    if url:
                        return url.rstrip('/') # Ensure no trailing slash
            with open(GUI_CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump({"server_url": default_url}, f, indent=4)
            return default_url
        except (IOError, json.JSONDecodeError) as e:
            print(f"[API_CLIENT_ERROR] Could not read or create gui_config.json: {e}. Using default URL.") # English Log
            return default_url
    def _load_api_key(self):
        """Loads the API key from a local JSON file."""
        try:
            if os.path.exists(API_KEY_FILE):
                with open(API_KEY_FILE, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    key = data.get("api_key")
                    if key:
                        print("[INFO] Secure API key loaded from local file.") # English Log
                        return key
        except (IOError, json.JSONDecodeError) as e:
            print(f"[API_CLIENT_WARNING] Could not read API key file: {e}") # English Log
        return None
    def _get_auth_headers(self):
        """Helper function to create authentication headers."""
        if not self.api_key:
            print("[API_CLIENT_WARNING] API Key is not set. Authenticated requests will fail.") # English Log
            return {}
        return {"X-API-Key": self.api_key}
    def get_server_status(self):
        """Example endpoint to check if the server is alive. This is a public endpoint."""
        try:
            response = requests.get(f"{self.base_url}/api/v1/status", timeout=2)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            status_code = e.response.status_code if hasattr(e, 'response') and e.response is not None else "N/A"
            print(f"[API_CLIENT_ERROR] Failed to get server status ({status_code}): {e}") # English Log
            return {"status": "error", "message": str(e)}
    def _make_request(self, method, endpoint, **kwargs):
        """Makes an authenticated request to the server."""
        url = f"{self.base_url}/api/v1{endpoint}"
        headers = self._get_auth_headers()
        if not self.api_key:
            return False, {"status": "error", "message": "Authentication failed: API Key is missing."}
        if 'headers' in kwargs:
            kwargs['headers'].update(headers)
        else:
            kwargs['headers'] = headers
        try:
            response = requests.request(method, url, **kwargs)
            response.raise_for_status()
            if response.status_code == 204 or not response.content:
                return True, {"status": "success", "data": {}}
            return True, response.json()
        except requests.exceptions.HTTPError as e:
            error_message = f"{e.response.status_code} Client Error: {e.response.reason} for url: {e.response.url}"
            try:
                error_detail = e.response.json().get('detail', error_message)
                return False, {"status": "error", "message": error_detail}
            except json.JSONDecodeError:
                return False, {"status": "error", "message": error_message}
        except requests.exceptions.RequestException as e:
            print(f"[API_CLIENT_ERROR] Request failed for {endpoint}: {e}") # English Log
            return False, {"status": "error", "message": str(e)}
    def get_menubar(self):
        """Fetches the dynamic menubar structure from the server."""
        return self._make_request('GET', '/ui/menubar')
    def get_tab_session(self):
        """Fetches the list of open tabs from the last session from the server."""
        return self._make_request('GET', '/uistate/session/tabs')
    def save_tab_session(self, tabs_data: list):
        """Saves the current list of open tabs to the server."""
        return self._make_request('POST', '/uistate/session/tabs', json=tabs_data)
    def get_presets(self):
        """Fetches a list of all available presets."""
        return self._make_request('GET', '/presets')
    def get_components(self, component_type: str, component_id: str = None):
        """Fetches a list of components (modules, widgets, etc.) or a single one by ID."""
        endpoint = f"/{component_type}"
        if component_id:
            endpoint += f"/{component_id}"
        return self._make_request('GET', endpoint)
    def get_dashboard_layout(self, tab_id: str):
        """Fetches the dashboard layout for a specific tab."""
        return self._make_request('GET', f"/uistate/dashboards/{tab_id}")
    def save_dashboard_layout(self, tab_id: str, layout_data: dict):
        """Saves the dashboard layout for a specific tab."""
        return self._make_request('POST', f"/uistate/dashboards/{tab_id}", json=layout_data)
    def list_datasets(self):
        """Fetches a list of all available datasets from the server."""
        return self._make_request('GET', '/datasets')
    def get_prompts(self):
        """Fetches all prompt templates."""
        return self._make_request('GET', '/prompts')
    def get_prompt(self, prompt_id: str):
        """Fetches a single prompt template by its ID."""
        return self._make_request('GET', f'/prompts/{prompt_id}')
    def create_prompt(self, prompt_data: dict):
        """Creates a new prompt template."""
        return self._make_request('POST', '/prompts', json=prompt_data)
    def update_prompt(self, prompt_id: str, prompt_data: dict):
        """Updates an existing prompt template."""
        return self._make_request('PUT', f'/prompts/{prompt_id}', json=prompt_data)
    def delete_prompt(self, prompt_id: str):
        """Deletes a prompt template."""
        return self._make_request('DELETE', f'/prompts/{prompt_id}')
    def get_trigger_rules(self):
        """Fetches all configured trigger rules from the server."""
        return self._make_request('GET', '/triggers/rules') # COMMENT: The original endpoint was incorrect. This is the correct one.
    def get_trigger_definitions(self):
        """Fetches all available trigger types (definitions) from the server."""
        return self._make_request('GET', '/triggers/definitions')
    def update_trigger_rule(self, rule_id: str, rule_data: dict):
        """Updates an existing trigger rule on the server."""
        return self._make_request('PUT', f'/triggers/rules/{rule_id}', json=rule_data)
    def create_trigger_rule(self, rule_data: dict):
        """Creates a new trigger rule on the server."""
        return self._make_request('POST', '/triggers/rules', json=rule_data)
    def delete_trigger_rule(self, rule_id: str):
        """Deletes a trigger rule from the server."""
        return self._make_request('DELETE', f'/triggers/rules/{rule_id}')
    def reload_triggers(self):
        """Tells the server to reload all active triggers."""
        return self._make_request('POST', '/triggers/actions/reload')
    def generate_workflow(self, user_prompt: str):
        """Sends a prompt to the AI Architect to generate a workflow."""
        return self._make_request('POST', '/ai/architect/generate', json={"prompt": user_prompt})
    def add_new_workflow_tab_with_data(self, workflow_data, tab_title):
        """A special client-side function to signal the main app to create a new tab."""
        print(f"SIGNAL: Request to create new tab '{tab_title}' with provided data.")
    def get_all_settings(self):
        """Fetches all kernel settings."""
        return self._make_request('GET', '/settings')
    def save_settings(self, settings_data: dict):
        """Saves all kernel settings."""
        return self._make_request('PATCH', '/settings', json=settings_data)
    def get_variables(self):
        """Fetches all user-defined variables."""
        return self._make_request('GET', '/variables')
    def update_variable(self, name: str, value, is_secret: bool, is_enabled: bool, mode: str):
        """Creates or updates a user-defined variable."""
        payload = {"value": value, "is_secret": is_secret, "is_enabled": is_enabled, "mode": mode}
        return self._make_request('PUT', f'/variables/{name}', json=payload)
    def update_variable_state(self, name: str, is_enabled: bool):
        """Updates only the enabled/disabled state of a variable."""
        return self._make_request('PATCH', f'/variables/{name}/state', json={"enabled": is_enabled})
    def delete_variable(self, name: str):
        """Deletes a user-defined variable."""
        return self._make_request('DELETE', f'/variables/{name}')
    def trigger_scan_by_api(self):
        """Triggers the diagnostics scanner via an API call."""
        return self._make_request('POST', '/system/run-diagnostics')
    def get_job_status(self, job_id: str):
        """Gets the status of a long-running job."""
        return self._make_request('GET', f'/system/jobs/{job_id}')
    def get_marketplace_ads(self):
        """Fetches marketplace ad data directly from GitHub."""
        cache_key = "marketplace_ads"
        with self.cache_lock:
            if cache_key in self.cache:
                cached_data, timestamp = self.cache[cache_key]
                if time.time() - timestamp < 3600: # Cache for 1 hour
                    return True, cached_data
        url = f"https://raw.githubusercontent.com/{self.marketplace_repo_owner}/{self.marketplace_repo_name}/{self.marketplace_branch}/ads.json"
        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            data = response.json()
            with self.cache_lock:
                self.cache[cache_key] = (data, time.time())
            return True, data
        except requests.exceptions.RequestException as e:
            return False, f"Network error fetching ads: {e}" # English Log
        except json.JSONDecodeError:
            return False, "Failed to parse ads.json." # English Log
    def get_marketplace_index(self, component_type: str):
        """Fetches a component index directly from the GitHub repository."""
        cache_key = f"marketplace_index_{component_type}"
        with self.cache_lock:
            if cache_key in self.cache:
                cached_data, timestamp = self.cache[cache_key]
                if time.time() - timestamp < 3600: # Cache for 1 hour
                    return True, cached_data
        folder_map = {
            "modules": "modules", "plugins": "plugins", "widgets": "widgets", "presets": "presets",
            "triggers": "triggers", "ai_providers": "ai_providers", "ai_models": "ai_models"
        }
        folder_name = folder_map.get(component_type)
        if not folder_name: return False, f"Unknown component type for marketplace: {component_type}" # English Hardcode
        url = f"https://raw.githubusercontent.com/{self.marketplace_repo_owner}/{self.marketplace_repo_name}/{self.marketplace_branch}/{folder_name}/index.json"
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 404: return True, []
            response.raise_for_status()
            data = response.json()
            with self.cache_lock:
                self.cache[cache_key] = (data, time.time())
            return True, data
        except requests.exceptions.RequestException as e:
            return False, f"Network error fetching marketplace index: {e}" # English Log
        except json.JSONDecodeError:
            return False, f"Failed to parse marketplace index.json for {component_type}." # English Hardcode
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\components\main_window.py
# JUMLAH BARIS : 28
#######################################################################

```py
import tkinter as tk
from tkinter import ttk
class MainWindow(tk.Tk):
    def __init__(self, api_client):
        super().__init__()
        self.api_client = api_client
        self.title("FLOWORK GUI - API Driven")
        self.geometry("800x600")
        self.create_widgets()
        self.check_server_status()
    def create_widgets(self):
        self.label = ttk.Label(self, text="Connecting to FLOWORK Server...", font=("Helvetica", 16))
        self.label.pack(pady=50, padx=20)
    def check_server_status(self):
        status_data = self.api_client.get_server_status()
        if status_data and status_data.get("status") == "ok":
            self.label.config(text=f"Server Status: {status_data.get('message', 'Connected')}", foreground="green")
        else:
            message = status_data.get('message', 'Connection failed')
            self.label.config(text=f"Server Status: Error - {message}", foreground="red")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\core\build_security.py
# JUMLAH BARIS : 17
#######################################################################

```py
import os
import sys
OFFICIAL_BUILD_SIGNATURE = ""
def perform_runtime_check(module_file_path):
    """
    (COMMENT) This security check is currently disabled as per user request.
    The function is kept to prevent import errors but does nothing.
    """
    pass
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\modules\debug_popup_module\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "e76740630c62aea72978c15ce2736ae6ed967d0e8825e887232a9d45d26c044d",
    "manifest_hash": "ed9c11131141c527b51d94df24d59803316f0447e343393b1168ea41af9d8192",
    "timestamp": 1757229737.2058835
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\modules\debug_popup_module\manifest.json
# JUMLAH BARIS : 19
#######################################################################

```json
{
    "id": "debug_popup_module",
    "name": "Tampilkan Output (Popup)",
    "icon_file": "icon.png",
    "author": "AWENK AUDICO",
    "email": "Contributor@teetah.art",
    "website": "www.teetah.art",
    "description": "Menampilkan seluruh isi variabel (payload) yang diterima dari node sebelumnya dalam sebuah jendela popup. Sangat berguna untuk debugging.",
    "type": "LOGIC",
    "entry_point": "processor.DebugPopupModule",
    "properties": [],
    "permissions": [
        "ui_interaction"
    ],
    "requires_services": [
        "logger",
        "kernel"
    ]
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\modules\debug_popup_module\processor.py
# JUMLAH BARIS : 31
#######################################################################

```py
from api_contract import BaseModule # PENAMBAHAN OTOMATIS
import json
class DebugPopupModule(BaseModule):
    TIER = "free"
    def __init__(self, module_id, services):
        super().__init__(module_id, services)
        self._active_popups = {}
    def _show_popup_on_ui_thread(self, node_instance_id, title, data_string):
        if node_instance_id in self._active_popups and self._active_popups[node_instance_id].winfo_exists():
            self._active_popups[node_instance_id].destroy()
            self.logger("An existing debug popup for this node was found and automatically closed.", "INFO") # English Log
        pass # ADDED: Added pass to prevent syntax error after commenting out.
    def execute(self, payload, config, status_updater, ui_callback, mode='EXECUTE'):
        node_instance_id = config.get('__internal_node_id', self.module_id)
        status_updater("Preparing popup...", "INFO") # English Log
        try:
            payload_str = json.dumps(payload, indent=4, ensure_ascii=False, default=str)
        except Exception:
            payload_str = str(payload)
        popup_title = "Debug Output From Previous Node" # English Hardcode
        ui_callback(self._show_popup_on_ui_thread, node_instance_id, popup_title, payload_str)
        status_updater("Popup displayed", "SUCCESS") # English Log
        return payload
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\modules\debug_popup_module\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "e76740630c62aea72978c15ce2736ae6ed967d0e8825e887232a9d45d26c044d",
    "manifest_hash": "ed9c11131141c527b51d94df24d59803316f0447e343393b1168ea41af9d8192",
    "timestamp": 1757204599.5532389
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\modules\prompt_receiver_module\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "74fd3ca76ff3fe670750ff67abe16cf6c5f10364f6e89e62142a9627121615da",
    "manifest_hash": "43fb8a4d923c07b6c540459a76259e108870ea3d9b5188643d16630d45dcde6e",
    "timestamp": 1757229796.787274
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\modules\prompt_receiver_module\manifest.json
# JUMLAH BARIS : 34
#######################################################################

```json
{
    "id": "prompt_receiver_module",
    "name": "Prompt Receiver",
    "version": "1.0",
    "icon_file": "icon.gif",
    "author": "AWENK AUDICO",
    "email": "sahidinaola@gmail.com",
    "website": "www.teetah.art",
    "description": "Receives a prompt from a UI widget via an event and passes it to the next node.",
    "type": "CONTROL_FLOW",
    "entry_point": "processor.PromptReceiverModule",
    "tier": "free",
    "requires_input": false,
    "requires_services": [
        "logger",
        "loc",
        "kernel",
        "event_bus",
        "workflow_executor_service"
    ],
    "output_ports": [
        {
            "name": "output",
            "display_name": "Output"
        }
    ],
    "output_schema": [
        {
            "name": "data.prompt",
            "type": "string",
            "description": "The text prompt received from the sender widget."
        }
    ]
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\modules\prompt_receiver_module\processor.py
# JUMLAH BARIS : 97
#######################################################################

```py
from flowork_gui.core import build_security # PENAMBAHAN: Importing from the new local GUI path.
import ttkbootstrap as ttk
from tkinter import StringVar
from flowork_gui.api_contract import BaseDashboardWidget # PENAMBAHAN: This should likely be a BaseModule equivalent in the GUI, but using a known base class for now.
class BaseModule:
    def __init__(self, module_id, services): self.module_id = module_id; self.services = services; self.logger=lambda *args:None; self.event_bus = services.get('event_bus'); self.kernel=services.get('kernel')
class IExecutable: pass
class IConfigurableUI: pass
class IDataPreviewer: pass
class PromptReceiverModule(BaseModule, IExecutable, IConfigurableUI, IDataPreviewer):
    """
    Listens for a specific event containing a prompt and then triggers the
    workflow execution from this node onwards.
    """
    TIER = "free"
    def __init__(self, module_id, services):
        build_security.perform_runtime_check(__file__)
        super().__init__(module_id, services)
        self.parent_frame_for_clipboard = None
        self.node_instance_id = None
    def on_canvas_load(self, node_id: str):
        """
        Called by the CanvasManager right after this node is placed on the canvas.
        This is the perfect moment to start listening for events.
        """
        self.node_instance_id = node_id
        event_name = f"PROMPT_FROM_WIDGET_{self.node_instance_id}"
        subscriber_id = f"prompt_receiver_{self.node_instance_id}"
        self.event_bus.subscribe(
            event_name=event_name,
            subscriber_id=subscriber_id,
            callback=self._handle_prompt_event
        )
        self.logger(f"Receiver node '{self.node_instance_id}' is now listening for event '{event_name}'.", "SUCCESS")
    def execute(self, payload, config, status_updater, ui_callback, mode='EXECUTE'):
        """
        When this node is triggered, it simply passes the received payload
        to its output port to continue the flow.
        """
        self.node_instance_id = config.get('__internal_node_id', self.node_instance_id or self.module_id)
        status_updater(f"Passing data through...", "INFO") # English Hardcode
        status_updater("Data received and passed.", "SUCCESS") # English Hardcode
        return {"payload": payload, "output_name": "output"}
    def _handle_prompt_event(self, event_data):
        """
        This is the callback that gets triggered by the Event Bus.
        It starts the workflow execution from this node.
        """
        prompt = event_data.get("prompt")
        self.logger(f"Received prompt for node '{self.node_instance_id}': '{prompt[:50]}...'", "INFO")
        new_payload = {
            "data": {"prompt": prompt},
            "history": []
        }
        if self.kernel:
            pass
    def _copy_node_id_to_clipboard(self, node_id):
        """Copies the node ID to the clipboard."""
        if self.parent_frame_for_clipboard:
            self.parent_frame_for_clipboard.clipboard_clear()
            self.parent_frame_for_clipboard.clipboard_append(node_id)
            self.logger(f"Receiver ID '{node_id}' copied to clipboard.", "SUCCESS")
    def create_properties_ui(self, parent_frame, get_current_config, available_vars):
        """Creates the UI for the properties popup."""
        config = get_current_config()
        self.parent_frame_for_clipboard = parent_frame
        node_id = self.node_instance_id
        info_frame = ttk.LabelFrame(parent_frame, text="Receiver Info", padding=10) # English Hardcode
        info_frame.pack(fill='x', padx=5, pady=10)
        id_info_text = f"This node listens for prompts sent to its unique ID. Copy this ID and paste it into a 'Prompt Sender' widget.\n\nID: {node_id}" # English Hardcode
        ttk.Label(info_frame, text=id_info_text, wraplength=350, justify="left").pack(anchor='w', fill='x', expand=True, pady=(0, 10))
        copy_button = ttk.Button(
            info_frame,
            text="Copy ID", # English Hardcode
            command=lambda: self._copy_node_id_to_clipboard(node_id),
            bootstyle="info-outline"
        )
        copy_button.pack(anchor='e')
        return {}
    def get_data_preview(self, config: dict):
        """
        TODO: Implement the data preview logic for this module.
        This method should return a small, representative sample of the data
        that the 'execute' method would produce.
        It should run quickly and have no side effects.
        """
        self.logger(f"'get_data_preview' is not yet implemented for {self.module_id}", 'WARN')
        return [{'status': 'preview not implemented'}]
_UNUSED_SIGNATURE = 'B3Ba%m#rDeKa' # Embedded Signature
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\modules\prompt_receiver_module\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "74fd3ca76ff3fe670750ff67abe16cf6c5f10364f6e89e62142a9627121615da",
    "manifest_hash": "43fb8a4d923c07b6c540459a76259e108870ea3d9b5188643d16630d45dcde6e",
    "timestamp": 1757204655.9143288
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\modules\prompt_receiver_module\locales\en.json
# JUMLAH BARIS : 1
#######################################################################

```json
{}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\modules\prompt_receiver_module\locales\id.json
# JUMLAH BARIS : 1
#######################################################################

```json
{}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\ai_architect_page.py
# JUMLAH BARIS : 152
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import scrolledtext, messagebox
import threading
import re
from flowork_gui.api_client.client import ApiClient
class AiArchitectPage(ttk.Frame):
    """
    The user interface for the AI Architect feature, allowing users to generate
    workflows from natural language prompts.
    """
    def __init__(self, parent_notebook, api_client, loc_service, **kwargs): # PENAMBAHAN: New init signature.
        self.api_client = api_client
        super().__init__(parent_notebook, padding=0) # MODIFIKASI: padding diatur di frame konten
        self.loc = loc_service
        class MockKernel:
            def __init__(self, api_client_instance, loc_instance):
                self.api_client = api_client_instance
                self.loc = loc_instance
                self.services = {'localization_manager': self.loc}
            def get_service(self, service_name):
                return self.services.get(service_name)
            def is_tier_sufficient(self, tier): # PENAMBAHAN: Simple mock for tier check
                return True # Assuming GUI has access if the page is visible
        self.kernel = MockKernel(self.api_client, self.loc)
        self.guide_is_pinned = False
        self.hide_guide_job = None
        self._build_ui()
        self._populate_guide()
    def _apply_markdown_to_text_widget(self, text_widget, content):
        text_widget.config(state="normal")
        text_widget.delete("1.0", "end")
        parts = re.split(r'(\*\*.*?\*\*)', content)
        for part in parts:
            if part.startswith('**') and part.endswith('**'):
                text_widget.insert("end", part[2:-2], "bold")
            else:
                text_widget.insert("end", part)
        text_widget.config(state="disabled")
    def _populate_guide(self):
        guide_content = self.loc.get("ai_architect_guide_content")
        self._apply_markdown_to_text_widget(self.guide_text, guide_content)
        self.guide_text.tag_configure("bold", font="-size 9 -weight bold")
    def _build_ui(self):
        """Builds the main widgets for the page."""
        main_content_frame = ttk.Frame(self, padding=20)
        main_content_frame.place(relx=0, rely=0, relwidth=1, relheight=1)
        main_content_frame.columnconfigure(0, weight=1)
        main_content_frame.rowconfigure(1, weight=1)
        header_frame = ttk.Frame(main_content_frame)
        header_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        ttk.Label(header_frame, text=self.loc.get('ai_architect_page_title', fallback="AI Architect"), font=("Helvetica", 16, "bold")).pack(side="left", anchor="w")
        self.status_label = ttk.Label(header_frame, text=self.loc.get('ai_architect_status_ready', fallback="Ready."), bootstyle="secondary")
        self.status_label.pack(side="right", anchor="e")
        self.prompt_text = scrolledtext.ScrolledText(main_content_frame, wrap="word", height=10, font=("Helvetica", 11))
        self.prompt_text.grid(row=1, column=0, sticky="nsew")
        self.prompt_text.insert("1.0", self.loc.get('ai_architect_prompt_placeholder', fallback="Example: Create a workflow that gets data from a web scraper..."))
        button_container = ttk.Frame(main_content_frame)
        button_container.grid(row=2, column=0, sticky="ew", pady=(10, 0))
        button_container.columnconfigure(0, weight=1)
        self.generate_button = ttk.Button(button_container, text=self.loc.get('ai_architect_generate_button', fallback="🚀 Generate Workflow"), command=self._start_generation_thread, bootstyle="success")
        self.generate_button.grid(row=0, column=0, sticky="ew", ipady=5)
        guide_handle = ttk.Frame(self, width=15, bootstyle="secondary")
        guide_handle.place(relx=0, rely=0, relheight=1, anchor='nw')
        handle_label = ttk.Label(guide_handle, text=">", bootstyle="inverse-secondary", font=("Helvetica", 10, "bold"))
        handle_label.pack(expand=True)
        guide_handle.bind("<Enter>", self._show_guide_panel)
        self.guide_panel = ttk.Frame(self, bootstyle="secondary")
        control_bar = ttk.Frame(self.guide_panel, bootstyle="secondary")
        control_bar.pack(fill='x', padx=5, pady=2)
        self.guide_pin_button = ttk.Button(control_bar, text="📌", bootstyle="light-link", command=self._toggle_pin_guide)
        self.guide_pin_button.pack(side='right')
        guide_frame_inner = ttk.LabelFrame(self.guide_panel, text=self.loc.get('ai_architect_guide_title'), padding=15)
        guide_frame_inner.pack(fill='both', expand=True, padx=5, pady=(0,5))
        guide_frame_inner.columnconfigure(0, weight=1)
        guide_frame_inner.rowconfigure(0, weight=1)
        self.guide_text = scrolledtext.ScrolledText(guide_frame_inner, wrap="word", height=10, state="disabled", font="-size 9")
        self.guide_text.grid(row=0, column=0, sticky="nsew")
        self.guide_panel.bind("<Leave>", self._hide_guide_panel_later)
        self.guide_panel.bind("<Enter>", self._cancel_hide_guide)
        guide_handle.lift()
    def _start_generation_thread(self):
        if not self.kernel.is_tier_sufficient('architect'):
            messagebox.showwarning(
                self.loc.get('license_popup_title'),
                self.loc.get('license_popup_message', module_name="AI Architect"),
                parent=self.winfo_toplevel()
            )
            return
        user_prompt = self.prompt_text.get("1.0", "end-1c").strip()
        if not user_prompt:
            messagebox.showwarning(
                self.loc.get('ai_architect_warn_empty_prompt_title', fallback="Empty Prompt"),
                self.loc.get('ai_architect_warn_empty_prompt_msg', fallback="Please describe the workflow you want to create.")
            )
            return
        self.generate_button.config(state="disabled")
        self.status_label.config(text=self.loc.get('ai_architect_status_thinking', fallback="Thinking..."), bootstyle="info")
        thread = threading.Thread(target=self._generate_workflow_worker, args=(user_prompt,), daemon=True)
        thread.start()
    def _generate_workflow_worker(self, user_prompt):
        try:
            architect_service = self.kernel.get_service("ai_architect_service")
            if not architect_service:
                raise RuntimeError("AiArchitectService not available.")
            workflow_json = architect_service.generate_workflow_from_prompt(user_prompt)
            self.after(0, self._on_generation_complete, True, workflow_json, user_prompt)
        except Exception as e:
            self.after(0, self._on_generation_complete, False, str(e), None)
    def _on_generation_complete(self, success, result, user_prompt):
        self.generate_button.config(state="normal")
        if success:
            self.status_label.config(text=self.loc.get('ai_architect_status_success', fallback="Success! New tab created."), bootstyle="success")
            tab_manager = self.kernel.get_service("tab_manager_service")
            new_tab = tab_manager.add_new_workflow_tab()
            self.after(100, lambda: self._populate_new_tab(new_tab, result, user_prompt))
        else:
            self.status_label.config(text=self.loc.get('ai_architect_status_failed', fallback="Failed."), bootstyle="danger")
            messagebox.showerror(
                self.loc.get('ai_architect_error_title', fallback="AI Architect Error"),
                self.loc.get('ai_architect_error_failed_to_create', error=result, fallback=f"Failed to create workflow:\n\n{result}")
            )
    def _populate_new_tab(self, new_tab_frame, workflow_json, user_prompt):
        if hasattr(new_tab_frame, 'canvas_area_instance') and new_tab_frame.canvas_area_instance:
            new_tab_frame.canvas_area_instance.canvas_manager.load_workflow_data(workflow_json)
            tab_title = user_prompt[:25] + '...' if len(user_prompt) > 25 else user_prompt
        else:
            self.after(200, lambda: self._populate_new_tab(new_tab_frame, workflow_json, user_prompt))
    def _toggle_pin_guide(self):
        self.guide_is_pinned = not self.guide_is_pinned
        pin_char = "📌"
        self.guide_pin_button.config(text=pin_char)
        if not self.guide_is_pinned:
            self._hide_guide_panel_later()
    def _show_guide_panel(self, event=None):
        self._cancel_hide_guide()
        self.guide_panel.place(in_=self, relx=0, rely=0, relheight=1.0, anchor='nw', width=350)
        self.guide_panel.lift()
    def _hide_guide_panel_later(self, event=None):
        if not self.guide_is_pinned:
            self.hide_guide_job = self.after(300, lambda: self.guide_panel.place_forget())
    def _cancel_hide_guide(self, event=None):
        if self.hide_guide_job:
            self.after_cancel(self.hide_guide_job)
            self.hide_guide_job = None
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\ai_trainer_page.py
# JUMLAH BARIS : 245
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, messagebox, scrolledtext
import os
import re
import threading
import time
from widgets.dataset_manager_widget.dataset_manager_widget import DatasetManagerWidget
from flowork_gui.api_client.client import ApiClient
class AITrainerPage(ttk.Frame):
    """
    The main UI page for initiating and monitoring AI model fine-tuning jobs.
    [MODIFIED] Added a tutorial and guide panel.
    """
    def __init__(self, parent_notebook, api_client, loc_service, **kwargs): # PENAMBAHAN: New init signature.
        super().__init__(parent_notebook, padding=15)
        self.loc = loc_service
        self.api_client = api_client
        class MockKernel:
            def __init__(self, api_client_instance, loc_instance):
                self.api_client = api_client_instance
                self.loc = loc_instance
                self.services = {'localization_manager': self.loc}
            def get_service(self, service_name):
                return self.services.get(service_name)
        self.kernel = MockKernel(self.api_client, self.loc)
        self.guide_is_pinned = False
        self.hide_guide_job = None
        self.base_model_var = StringVar()
        self.dataset_var = StringVar()
        self.new_model_name_var = StringVar()
        self.epochs_var = StringVar(value="1")
        self.batch_size_var = StringVar(value="4")
        self.job_id = None
        self.is_polling = False
        self._build_ui()
        self._load_initial_data()
        self._populate_guide()
    def _apply_markdown_to_text_widget(self, text_widget, content):
        """ (ADDED) Helper function to parse simple markdown (bold). """
        text_widget.config(state="normal")
        text_widget.delete("1.0", "end")
        parts = re.split(r'(\*\*.*?\*\*)', content)
        for part in parts:
            if part.startswith('**') and part.endswith('**'):
                text_widget.insert("end", part[2:-2], "bold")
            else:
                text_widget.insert("end", part)
        text_widget.config(state="disabled")
    def _populate_guide(self):
        guide_content = self.loc.get("ai_trainer_guide_content")
        self._apply_markdown_to_text_widget(self.guide_text, guide_content)
        self.guide_text.tag_configure("bold", font="-size 9 -weight bold")
    def _build_ui(self):
        self.columnconfigure(0, weight=1)
        self.rowconfigure(0, weight=1)
        main_pane = ttk.PanedWindow(self, orient='horizontal')
        main_pane.grid(row=0, column=0, sticky="nsew")
        guide_handle = ttk.Frame(self, width=15, bootstyle="secondary")
        guide_handle.place(relx=0, rely=0, relheight=1, anchor='nw')
        handle_label = ttk.Label(guide_handle, text=">", bootstyle="inverse-secondary", font=("Helvetica", 10, "bold"))
        handle_label.pack(expand=True)
        guide_handle.bind("<Enter>", self._show_guide_panel)
        guide_handle.lift()
        self.guide_panel = ttk.Frame(self, bootstyle="secondary")
        control_bar = ttk.Frame(self.guide_panel, bootstyle="secondary")
        control_bar.pack(fill='x', padx=5, pady=2)
        self.guide_pin_button = ttk.Button(control_bar, text="📌", bootstyle="light-link", command=self._toggle_pin_guide)
        self.guide_pin_button.pack(side='right')
        guide_frame = ttk.LabelFrame(self.guide_panel, text=self.loc.get('ai_trainer_guide_title'), padding=15)
        guide_frame.pack(fill='both', expand=True, padx=5, pady=(0,5))
        guide_frame.columnconfigure(0, weight=1)
        guide_frame.rowconfigure(0, weight=1)
        self.guide_text = scrolledtext.ScrolledText(guide_frame, wrap="word", height=12, state="disabled", font="-size 9")
        self.guide_text.grid(row=0, column=0, sticky="nsew")
        self.guide_panel.bind("<Leave>", self._hide_guide_panel_later)
        self.guide_panel.bind("<Enter>", self._cancel_hide_guide)
        left_pane = ttk.Frame(main_pane, padding=10)
        main_pane.add(left_pane, weight=2)
        config_frame = ttk.LabelFrame(left_pane, text="1. Training Configuration", padding=15) # English Hardcode
        config_frame.pack(fill='x', expand=False)
        base_model_frame = ttk.Frame(config_frame)
        base_model_frame.pack(fill='x', pady=(2, 10))
        base_model_frame.columnconfigure(1, weight=1)
        ttk.Label(base_model_frame, text="Base Model (for new training only):").grid(row=0, column=0, columnspan=3, sticky='w') # English Hardcode
        self.model_combo = ttk.Combobox(base_model_frame, textvariable=self.base_model_var, state="readonly")
        self.model_combo.grid(row=1, column=0, columnspan=2, sticky='ew')
        refresh_model_button = ttk.Button(base_model_frame, text="⟳", width=3, command=self._load_initial_data, style="secondary.TButton")
        refresh_model_button.grid(row=1, column=2, padx=(5,0))
        ttk.Label(config_frame, text="Dataset for Training:").pack(anchor='w') # English Hardcode
        self.dataset_combo = ttk.Combobox(config_frame, textvariable=self.dataset_var, state="readonly")
        self.dataset_combo.pack(fill='x', pady=(2, 10))
        ttk.Label(config_frame, text="New or Existing Model Name:").pack(anchor='w') # English Hardcode
        self.new_model_name_combo = ttk.Combobox(config_frame, textvariable=self.new_model_name_var)
        self.new_model_name_combo.pack(fill='x', pady=(2, 10))
        params_frame = ttk.Frame(config_frame)
        params_frame.pack(fill='x', pady=5)
        ttk.Label(params_frame, text="Epochs:").pack(side='left') # English Hardcode
        ttk.Entry(params_frame, textvariable=self.epochs_var, width=5).pack(side='left', padx=(5, 20))
        ttk.Label(params_frame, text="Batch Size:").pack(side='left') # English Hardcode
        ttk.Entry(params_frame, textvariable=self.batch_size_var, width=5).pack(side='left', padx=5)
        self.dataset_manager = DatasetManagerWidget(
            left_pane,
            self.winfo_toplevel(),
            self.kernel,
            "ai_trainer_dataset_manager",
            refresh_callback=self._load_initial_data
        )
        self.dataset_manager.pack(fill='both', expand=True, pady=(10,0))
        right_pane = ttk.Frame(main_pane, padding=10)
        main_pane.add(right_pane, weight=3)
        monitor_frame = ttk.LabelFrame(right_pane, text="2. Training Monitor", padding=15) # English Hardcode
        monitor_frame.pack(fill='both', expand=True)
        monitor_frame.rowconfigure(1, weight=1)
        monitor_frame.columnconfigure(0, weight=1)
        self.status_label = ttk.Label(monitor_frame, text="Status: Idle", font="-size 10") # English Hardcode
        self.status_label.grid(row=0, column=0, sticky='ew', pady=(0, 10))
        self.log_text = scrolledtext.ScrolledText(monitor_frame, wrap="word", state="disabled", height=15)
        self.log_text.grid(row=1, column=0, sticky='nsew')
        self.progress_bar = ttk.Progressbar(monitor_frame, mode='determinate')
        self.progress_bar.grid(row=2, column=0, sticky='ew', pady=(10, 10))
        self.start_button = ttk.Button(monitor_frame, text="🚀 Start Fine-Tuning Job", command=self._start_training_job, bootstyle="success") # English Hardcode
        self.start_button.grid(row=3, column=0, sticky='ew', ipady=5)
    def _load_initial_data(self):
        threading.Thread(target=self._load_data_worker, daemon=True).start()
    def _load_data_worker(self):
        success_models, models_data = self.api_client.get_components("ai_models") # PENAMBAHAN: Fetch from API
        local_models = [m['name'] for m in models_data] if success_models else []
        success, datasets_response = self.api_client.list_datasets()
        datasets = datasets_response if success else []
        self.after(0, self._populate_combos, local_models, datasets)
    def _populate_combos(self, models, datasets):
        sorted_models = sorted(models)
        self.model_combo['values'] = sorted_models
        self.new_model_name_combo['values'] = sorted_models
        if 'training' in sorted_models:
            self.base_model_var.set('training')
            self.new_model_name_var.set('training')
        elif sorted_models:
            if self.base_model_var.get() not in sorted_models:
                self.base_model_var.set(sorted_models[0])
        dataset_names = [ds['name'] for ds in datasets]
        self.dataset_combo['values'] = sorted(dataset_names)
        if dataset_names:
            if self.dataset_var.get() not in dataset_names:
                self.dataset_var.set(dataset_names[0])
        if hasattr(self, 'dataset_manager'):
            self.dataset_manager._populate_dataset_combo(True, datasets)
    def _start_training_job(self):
        base_model = self.base_model_var.get()
        dataset = self.dataset_var.get()
        new_model_name = self.new_model_name_var.get().strip()
        new_model_name = re.sub(r'[^a-zA-Z0-9_-]', '', new_model_name)
        if not all([base_model, dataset, new_model_name]):
            messagebox.showerror("Validation Error", "All fields (Base Model, Dataset, New/Existing Model Name) are required.", parent=self) # English Hardcode
            return
        try:
            training_args = {
                "epochs": int(self.epochs_var.get()),
                "batch_size": int(self.batch_size_var.get())
            }
        except ValueError:
            messagebox.showerror("Validation Error", "Epochs and Batch Size must be numbers.", parent=self) # English Hardcode
            return
        self.start_button.config(state="disabled")
        self.log_text.config(state="normal")
        self.log_text.delete("1.0", "end")
        self.log_text.insert("1.0", "Sending training job request to the server...\n") # English Hardcode
        self.log_text.config(state="disabled")
        threading.Thread(
            target=self._start_training_worker,
            args=(base_model, dataset, new_model_name, training_args),
            daemon=True
        ).start()
    def _start_training_worker(self, base_model, dataset, new_model_name, args):
        success, response = self.api_client.start_training_job(base_model, dataset, new_model_name, args)
        self.after(0, self._on_job_started, success, response)
    def _on_job_started(self, success, response):
        if success:
            self.job_id = response.get('job_id')
            self.status_label.config(text=f"Status: Job {self.job_id} is QUEUED.") # English Hardcode
            self._log_message(f"Training job successfully queued with ID: {self.job_id}") # English Hardcode
            self._start_polling()
        else:
            messagebox.showerror("Job Error", f"Failed to start training job: {response}", parent=self) # English Hardcode
            self.start_button.config(state="normal")
    def _start_polling(self):
        if not self.is_polling:
            self.is_polling = True
            self._poll_job_status()
    def _poll_job_status(self):
        if not self.job_id:
            self.is_polling = False
            return
        threading.Thread(target=self._poll_worker, daemon=True).start()
    def _poll_worker(self):
        success, response = self.api_client.get_training_job_status(self.job_id)
        self.after(0, self._update_status_ui, success, response)
    def _update_status_ui(self, success, response):
        if success:
            status = response.get('status', 'UNKNOWN')
            message = response.get('message', '')
            progress = response.get('progress', 0)
            self.status_label.config(text=f"Status: {status}") # English Hardcode
            self._log_message(f"Update: {message}") # English Hardcode
            self.progress_bar['value'] = progress
            if status in ["COMPLETED", "FAILED"]:
                self.is_polling = False
                self.start_button.config(state="normal")
                messagebox.showinfo("Training Finished", f"Job {self.job_id} finished with status: {status}", parent=self) # English Hardcode
                self._load_initial_data()
            else:
                self.after(5000, self._poll_job_status)
        else:
            self._log_message(f"Error polling status: {response}") # English Hardcode
            self.after(5000, self._poll_job_status)
    def _log_message(self, message):
        self.log_text.config(state="normal")
        self.log_text.insert("end", f"{time.strftime('%H:%M:%S')} - {message}\n")
        self.log_text.see("end")
        self.log_text.config(state="disabled")
    def _toggle_pin_guide(self):
        self.guide_is_pinned = not self.guide_is_pinned
        pin_char = "📌"
        self.guide_pin_button.config(text=pin_char)
        if not self.guide_is_pinned:
            self._hide_guide_panel_later()
    def _show_guide_panel(self, event=None):
        self._cancel_hide_guide()
        self.guide_panel.place(in_=self, relx=0, rely=0, relheight=1.0, anchor='nw', width=350)
        self.guide_panel.lift()
    def _hide_guide_panel_later(self, event=None):
        if not self.guide_is_pinned:
            self.hide_guide_job = self.after(300, lambda: self.guide_panel.place_forget())
    def _cancel_hide_guide(self, event=None):
        if self.hide_guide_job:
            self.after_cancel(self.hide_guide_job)
            self.hide_guide_job = None
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "afcb1acba5b4844f1ab3ada0476c095f472d396faea5813a71ca50667df7a55e",
    "manifest_hash": "136667227cb826358dacc2b2573665a0cfd98b57204393f64712b0fcdd60ad6b",
    "timestamp": 1757229832.7975452
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\core_editor_page.py
# JUMLAH BARIS : 223
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import ttk as tk_ttk
import os
import json
from tkinter import messagebox, scrolledtext, Menu, Toplevel
import re
from flowork_gui.views.canvas_manager import CanvasManager
from flowork_gui.api_client.client import ApiClient
class CoreEditorPage(ttk.Frame):
    """
    The UI for the "Meta-Developer Mode" where core service
    workflows (.flowork files) can be visually edited.
    """
    def __init__(self, parent_notebook, api_client, loc_service, **kwargs): # PENAMBAHAN: New init signature.
        self.api_client = api_client
        super().__init__(parent_notebook, padding=10)
        self.loc = loc_service
        class MockKernel:
            def __init__(self, api_client_instance, loc_instance):
                self.api_client = api_client_instance
                self.loc = loc_instance
                self.services = {'localization_manager': self.loc}
                self.write_to_log = lambda msg, lvl="INFO": print(f"[INFO] (from MockKernel in CoreEditorPage): {msg}")
                self.project_root_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
            def get_service(self, service_name):
                if service_name not in self.services:
                    class MockService:
                        def __init__(self, api_client, kernel):
                            self.api_client = api_client
                            self.kernel = kernel
                        def get_colors(self): # Mock for theme manager
                            return {'bg': '#222', 'dark': '#343a40', 'success': '#28a745', 'info': '#17a2b8', 'border': 'grey'}
                    self.services[service_name] = MockService(self.api_client, self)
                return self.services.get(service_name)
        self.kernel = MockKernel(self.api_client, self.loc)
        self.canvas_manager = None
        self._drag_data = {}
        self.core_services_path = os.path.join(self.kernel.project_root_path, "core_services")
        self.guide_is_pinned = False
        self.hide_guide_job = None
        self._build_ui()
        self._populate_service_dropdown()
        self._populate_guide()
    def _apply_markdown_to_text_widget(self, text_widget, content):
        """ Helper function to parse simple markdown (bold). """
        text_widget.config(state="normal")
        text_widget.delete("1.0", "end")
        parts = re.split(r'(\*\*.*?\*\*)', content)
        for part in parts:
            if part.startswith('**') and part.endswith('**'):
                text_widget.insert("end", part[2:-2], "bold")
            else:
                text_widget.insert("end", part)
        text_widget.config(state="disabled")
    def _populate_guide(self):
        """Populates the guide panel with localized content."""
        guide_content = self.loc.get("core_editor_guide_content", fallback="Guide content not found.")
        self._apply_markdown_to_text_widget(self.guide_text, guide_content)
        self.guide_text.tag_configure("bold", font="-size 9 -weight bold")
    def _toggle_pin_guide(self):
        """Toggles the pinned state of the guide panel."""
        self.guide_is_pinned = not self.guide_is_pinned
        pin_char = "📌" # Karakter pin solid
        self.guide_pin_button.config(text=pin_char)
        if not self.guide_is_pinned:
            self._hide_guide_panel_later()
    def _show_guide_panel(self, event=None):
        """Shows the guide panel."""
        self._cancel_hide_guide()
        self.guide_panel.place(in_=self.canvas_container, relx=0, rely=0, relheight=1.0, anchor='nw', width=350)
        self.guide_panel.lift()
    def _hide_guide_panel_later(self, event=None):
        """Schedules the guide panel to be hidden after a short delay."""
        if not self.guide_is_pinned:
            self.hide_guide_job = self.after(300, lambda: self.guide_panel.place_forget())
    def _cancel_hide_guide(self, event=None):
        """Cancels a scheduled hide job."""
        if self.hide_guide_job:
            self.after_cancel(self.hide_guide_job)
            self.hide_guide_job = None
    def _build_ui(self):
        """
        Builds the main layout with a service selector and a canvas.
        """
        control_frame = ttk.Frame(self)
        control_frame.pack(side="top", fill="x", padx=5, pady=(0, 10))
        ttk.Label(control_frame, text=self.loc.get('core_editor_select_service', fallback="Select Service to Edit:")).pack(side="left", padx=(0, 10))
        self.service_var = ttk.StringVar()
        self.service_dropdown = ttk.Combobox(control_frame, textvariable=self.service_var, state="readonly")
        self.service_dropdown.pack(side="left", fill="x", expand=True)
        self.service_dropdown.bind("<<ComboboxSelected>>", self._on_service_selected)
        self.save_button = ttk.Button(control_frame, text=self.loc.get('core_editor_save_button', fallback="Save Changes"), command=self._save_workflow_data, bootstyle="success", state="disabled")
        self.save_button.pack(side="left", padx=(10, 0))
        main_pane = ttk.PanedWindow(self, orient='horizontal')
        main_pane.pack(fill="both", expand=True)
        toolbox_frame = ttk.LabelFrame(main_pane, text="Toolbox", padding=10)
        main_pane.add(toolbox_frame, weight=1)
        self.module_tree = tk_ttk.Treeview(toolbox_frame, show="tree", selectmode="browse")
        self.module_tree.pack(expand=True, fill='both')
        self._populate_module_toolbox()
        self.module_tree.bind("<ButtonPress-1>", self._on_drag_start)
        self.module_tree.bind("<B1-Motion>", self._on_drag_motion)
        self.module_tree.bind("<ButtonRelease-1>", self._on_drag_release)
        canvas_container = ttk.LabelFrame(main_pane, text="Visual Workflow") # English Hardcode
        main_pane.add(canvas_container, weight=4)
        self.canvas_container = canvas_container
        guide_handle = ttk.Frame(self.canvas_container, width=15, bootstyle="secondary")
        guide_handle.place(relx=0, rely=0, relheight=1, anchor='nw')
        handle_label = ttk.Label(guide_handle, text=">", bootstyle="inverse-secondary", font=("Helvetica", 10, "bold"))
        handle_label.pack(expand=True)
        guide_handle.bind("<Enter>", self._show_guide_panel)
        self.guide_panel = ttk.Frame(self.canvas_container, bootstyle="secondary")
        control_bar = ttk.Frame(self.guide_panel, bootstyle="secondary")
        control_bar.pack(fill='x', padx=5, pady=2)
        self.guide_pin_button = ttk.Button(control_bar, text="📌", bootstyle="light-link", command=self._toggle_pin_guide)
        self.guide_pin_button.pack(side='right')
        guide_frame = ttk.LabelFrame(self.guide_panel, text=self.loc.get('core_editor_guide_title'), padding=10)
        guide_frame.pack(fill='both', expand=True, padx=5, pady=(0,5))
        self.guide_text = scrolledtext.ScrolledText(guide_frame, wrap="word", height=10, state="disabled", font="-size 9")
        self.guide_text.pack(fill='both', expand=True)
        self.guide_panel.bind("<Leave>", self._hide_guide_panel_later)
        self.guide_panel.bind("<Enter>", self._cancel_hide_guide)
        class DummyCoordinatorTab(ttk.Frame):
            def __init__(self, kernel, editor_page):
                super().__init__()
                self.kernel = kernel
                self._execution_state = "IDLE"
                self.editor_page = editor_page
                self.bind = self.winfo_toplevel().bind
                self.unbind = self.winfo_toplevel().unbind
                self.unbind_all = self.winfo_toplevel().unbind_all
                self.after = self.winfo_toplevel().after
            def on_drag_release(self, event, item_id, tree_widget):
                self.editor_page._on_drag_release(event)
        dummy_tab = DummyCoordinatorTab(self.kernel, self)
        theme_manager = self.kernel.get_service("theme_manager")
        colors = theme_manager.get_colors() if theme_manager else {'bg': '#222'}
        canvas_widget = ttk.Canvas(canvas_container, background=colors.get('bg', '#222'))
        canvas_widget.pack(expand=True, fill='both')
        guide_handle.lift()
        self.canvas_manager = CanvasManager(canvas_container, dummy_tab, canvas_widget, self.kernel)
    def _populate_module_toolbox(self):
        logic_modules = {}
        action_modules = {}
        self.module_tree.insert('', 'end', iid='logic_category', text='Logic Modules', open=True) # English Hardcode
        for mod_id, name in sorted(logic_modules.items(), key=lambda item: item[1]):
             self.module_tree.insert('logic_category', 'end', iid=mod_id, text=f" {name}")
        self.module_tree.insert('', 'end', iid='action_category', text='Action Modules', open=True) # English Hardcode
        for mod_id, name in sorted(action_modules.items(), key=lambda item: item[1]):
             self.module_tree.insert('action_category', 'end', iid=mod_id, text=f" {name}")
    def _on_drag_start(self, event):
        item_id = self.module_tree.identify_row(event.y)
        if not item_id or self.module_tree.tag_has('category', item_id): return
        self._drag_data = {"item_id": item_id, "widget": ttk.Label(self.winfo_toplevel(), text=self.module_tree.item(item_id, "text").strip(), bootstyle="inverse-info", padding=5, relief="solid"), "tree_widget": self.module_tree}
    def _on_drag_motion(self, event):
        if self._drag_data.get("widget"):
            self._drag_data['widget'].place(x=event.x_root - self.winfo_toplevel().winfo_rootx() + 10, y=event.y_root - self.winfo_toplevel().winfo_rooty() + 10)
    def _on_drag_release(self, event):
        if self.canvas_manager and self._drag_data.get("item_id"):
            self.canvas_manager.interaction_manager.on_drag_release(event, self._drag_data["item_id"], self._drag_data["tree_widget"])
        if self._drag_data.get("widget"):
            self._drag_data["widget"].destroy()
        self._drag_data = {}
    def _populate_service_dropdown(self):
        if not os.path.isdir(self.core_services_path):
            self.service_dropdown['values'] = ["'core_services' folder not found!"]
            return
        service_files = [f for f in os.listdir(self.core_services_path) if f.endswith(".flowork")]
        self.service_dropdown['values'] = sorted(service_files)
        if service_files:
            self.service_dropdown.set(service_files[0])
            self._load_workflow_data(service_files[0])
    def _on_service_selected(self, event=None):
        self.save_button.config(state="disabled")
        selected_file = self.service_var.get()
        if selected_file:
            self._load_workflow_data(selected_file)
    def _load_workflow_data(self, filename):
        if not self.canvas_manager: return
        file_path = os.path.join(self.core_services_path, filename)
        self.kernel.write_to_log(f"Core Editor: Loading '{filename}'...", "INFO") # English Log
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                workflow_data = json.load(f)
            self.canvas_manager.load_workflow_data(workflow_data)
            self.kernel.write_to_log(f"Core Editor: Successfully rendered '{filename}'.", "SUCCESS") # English Log
            self.save_button.config(state="normal")
        except Exception as e:
            self.canvas_manager.clear_canvas(feedback=False)
            self.kernel.write_to_log(f"Core Editor: Failed to load or parse '{filename}': {e}", "ERROR") # English Log
            self.save_button.config(state="disabled")
            messagebox.showerror(
                self.loc.get('error_title', fallback="Error"),
                f"Failed to load service workflow '{filename}'.\nThe file might be corrupted or empty. Saving is disabled to prevent data loss.",
                parent=self
            )
    def _save_workflow_data(self):
        if not self.canvas_manager:
            messagebox.showerror("Error", "Canvas is not ready.") # English Hardcode
            return
        selected_file = self.service_var.get()
        if not selected_file:
            messagebox.showwarning("Warning", "No service workflow is selected to save.") # English Hardcode
            return
        workflow_data = self.canvas_manager.get_workflow_data()
        file_path = os.path.join(self.core_services_path, selected_file)
        self.kernel.write_to_log(f"Core Editor: Saving changes to '{selected_file}'...", "INFO") # English Log
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(workflow_data, f, indent=4, ensure_ascii=False)
            self.kernel.write_to_log(f"Core Editor: Successfully saved '{selected_file}'.", "SUCCESS") # English Log
            messagebox.showinfo("Success", f"Changes to '{selected_file}' have been saved.") # English Hardcode
        except Exception as e:
            self.kernel.write_to_log(f"Core Editor: Failed to save '{selected_file}': {e}", "ERROR") # English Log
            messagebox.showerror("Error", f"Failed to save file: {e}") # English Hardcode
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\core_ui_provider.py
# JUMLAH BARIS : 165
#######################################################################

```py
from api_contract import BaseModule, BaseUIProvider # PENAMBAHAN OTOMATIS
from plugins.flowork_core_ui.settings_tab import SettingsTab
from plugins.flowork_core_ui.template_manager_page import TemplateManagerPage
from plugins.flowork_core_ui.generator_page import GeneratorPage
from plugins.flowork_core_ui.trigger_manager_page import TriggerManagerPage
from plugins.flowork_core_ui.marketplace_page import MarketplacePage
from plugins.flowork_core_ui.ai_architect_page import AiArchitectPage
from plugins.flowork_core_ui.core_editor_page import CoreEditorPage
from plugins.flowork_core_ui.pricing_page import PricingPage
from plugins.flowork_core_ui.ai_trainer_page import AITrainerPage
from plugins.flowork_core_ui.model_converter_page import ModelConverterPage
from plugins.flowork_core_ui.prompt_manager_page import PromptManagerPage
from scanners.diagnostics_page import DiagnosticsPage
from api_client import ApiClient # PENAMBAHAN OTOMATIS
class CoreUIProvider(BaseModule, BaseUIProvider):
    TIER = "free"
    def __init__(self, module_id, services):
        self.api_client = ApiClient()
        super().__init__(module_id, services)
        if hasattr(self, 'logger') and callable(self.logger):
            self.logger("<<<<< [MATA-MATA] CoreUIProvider __init__ BERHASIL DIJALANKAN! >>>>>", "SUCCESS") # English log
    def execute(self, payload, config, status_updater, ui_callback, mode='EXECUTE'):
        status_updater("No action", "INFO") # English Log
        return payload
    def get_ui_tabs(self):
        self.logger("[MATA-MATA] CoreUIProvider: get_ui_tabs() called by Kernel.", "DEBUG") # English Log
        all_pages = [
            {
                "key": "settings",
                "title": self.loc.get('settings_tab_title', fallback="Settings"),
                "frame_class": SettingsTab
            },
            {
                "key": "trigger_manager",
                "title": self.loc.get('trigger_manager_page_title', fallback="Trigger Management"),
                "frame_class": TriggerManagerPage
            },
            {
                "key": "prompt_manager",
                "title": self.loc.get('menu_title_prompt_manager', fallback="Prompt Manager"),
                "frame_class": PromptManagerPage
            },
            {
                "key": "template_manager",
                "title": self.loc.get('template_manager_page_title', fallback="Template Management"),
                "frame_class": TemplateManagerPage
            },
            {
                "key": "generator",
                "title": self.loc.get('generator_page_title', fallback="Generator Tools"),
                "frame_class": GeneratorPage
            },
            {
                "key": "marketplace",
                "title": self.loc.get('marketplace_page_title', fallback="Marketplace"),
                "frame_class": MarketplacePage
            },
            {
                "key": "ai_architect",
                "title": self.loc.get('ai_architect_page_title', fallback="AI Architect"),
                "frame_class": AiArchitectPage
            },
            {
                "key": "ai_trainer",
                "title": self.loc.get('menu_open_ai_trainer', fallback="AI Trainer"),
                "frame_class": AITrainerPage
            },
            {
                "key": "model_converter",
                "title": self.loc.get('menu_open_model_factory', fallback="Model Factory"),
                "frame_class": ModelConverterPage
            },
            {
                "key": "core_editor",
                "title": self.loc.get('core_editor_page_title', fallback="Core Editor"),
                "frame_class": CoreEditorPage
            },
            {
                "key": "pricing_page",
                "title": self.loc.get('pricing_page_title', fallback="Upgrade Plan"),
                "frame_class": PricingPage
            },
            {
                "key": "system_diagnostics",
                "title": self.loc.get('diagnostics_tab_title', fallback="System Diagnostics"),
                "frame_class": DiagnosticsPage
            }
        ]
        license_manager = self.kernel.get_service("license_manager_service")
        monetization_is_active = license_manager and license_manager.remote_permission_rules and license_manager.remote_permission_rules.get("monetization_active")
        final_pages_to_show = []
        for page in all_pages:
            if page['key'] == 'pricing_page' and not monetization_is_active:
                self.logger(f"UI: Monetization is inactive, hiding page: {page['key']}", "DEBUG") # English Log
                continue
            final_pages_to_show.append(page)
        return final_pages_to_show
    def get_menu_items(self):
        self.logger("[MATA-MATA] CoreUIProvider: get_menu_items() called by Kernel.", "DEBUG") # English Log
        tab_manager = self.kernel.get_service("tab_manager_service")
        plugin_manager = self.kernel.get_service("plugin_manager_service")
        all_items = [
            {
                "parent": self.loc.get('menu_ai_tools', fallback="AI Tools"),
                "add_separator": True,
                "label": self.loc.get('menu_title_prompt_manager', fallback="Prompt Manager"),
                "command": lambda: tab_manager.open_managed_tab('prompt_manager')
            },
            {
                "parent": self.loc.get('menu_ai_tools', fallback="AI Tools"),
                "label": self.loc.get('menu_open_ai_architect', fallback="Open AI Architect"),
                "command": lambda: tab_manager.open_managed_tab('ai_architect')
            },
            {
                "parent": self.loc.get('menu_ai_tools', fallback="AI Tools"),
                "add_separator": True,
                "label": self.loc.get('menu_open_ai_trainer', fallback="Open AI Trainer"),
                "command": lambda: tab_manager.open_managed_tab('ai_trainer')
            },
            {
                "parent": self.loc.get('menu_ai_tools', fallback="AI Tools"),
                "label": self.loc.get('menu_open_model_factory', fallback="Open Model Factory"),
                "command": lambda: tab_manager.open_managed_tab('model_converter')
            },
            {
                "parent": self.loc.get('menu_ai_tools', fallback="AI Tools"),
                "add_separator": True,
                "label": self.loc.get('menu_open_generator', fallback="Open Module Factory"),
                "command": lambda: tab_manager.open_managed_tab('generator')
            },
            {
                "parent": self.loc.get('menu_developer', fallback="Developer"),
                "label": self.loc.get('menu_open_core_editor', fallback="Open Core Workflow Editor"),
                "command": lambda: tab_manager.open_managed_tab('core_editor')
            },
            {
                "parent": self.loc.get('menu_help', fallback="Help"),
                "add_separator": True,
                "label": self.loc.get('diagnostics_tab_title', fallback="System Diagnostics"),
                "command": lambda: tab_manager.open_managed_tab('system_diagnostics')
            },
            {
                "parent": self.loc.get('menu_help', fallback="Help"),
                "add_separator": True,
                "label": self.loc.get('menu_open_pricing_page', fallback="View Plans & Upgrade"),
                "command": lambda: tab_manager.open_managed_tab('pricing_page')
            }
        ]
        license_manager = self.kernel.get_service("license_manager_service")
        monetization_is_active = license_manager and license_manager.remote_permission_rules and license_manager.remote_permission_rules.get("monetization_active")
        final_items_to_show = []
        for item in all_items:
            if item['label'] == self.loc.get('menu_open_pricing_page', fallback="View Plans & Upgrade") and not monetization_is_active:
                self.logger(f"UI: Monetization is inactive, hiding menu item: {item['label']}", "DEBUG") # English Log
                continue
            final_items_to_show.append(item)
        return final_items_to_show
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\generator_page.py
# JUMLAH BARIS : 562
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import ttk as tk_ttk, messagebox, Text, StringVar, BooleanVar, Toplevel, scrolledtext, Menu
import os
import json
import re
import uuid
import zipfile
import tempfile
import shutil
import importlib
import inspect
from tkinter import filedialog
from collections import OrderedDict
from .generator_components.base_component import BaseGeneratorComponent
from .generator_components.logic_builder_canvas import LogicBuilderCanvas
from flowork_gui.api_client.client import ApiClient
class GeneratorPage(ttk.Frame):
    """
    Page for the Generator Tools.
    [UPGRADE] Added a comprehensive tutorial panel to guide users through module creation.
    """
    DESIGN_STATE_KEY = "generator_page_last_state"
    def __init__(self, parent_notebook, api_client, loc_service, **kwargs): # PENAMBAHAN: New init signature.
        self.api_client = api_client
        super().__init__(parent_notebook, style='TFrame')
        self.loc = loc_service
        class MockKernel:
            def __init__(self, api_client_instance, loc_instance):
                self.api_client = api_client_instance
                self.loc = loc_instance
                self.services = {'localization_manager': self.loc}
                self.write_to_log = lambda msg, lvl="INFO": print(f"[INFO] (from MockKernel in GeneratorPage): {msg}")
            def get_service(self, service_name):
                return self.services.get(service_name)
            def is_tier_sufficient(self, tier): # PENAMBAHAN: Simple mock for tier check
                return True # Assuming GUI has access if the page is visible
        self.kernel = MockKernel(self.api_client, self.loc)
        self._drag_data = {}
        self.designed_components = {}
        self.selected_component_id = None
        self._is_updating_from_selection = False
        self.registered_components = {}
        self.guide_is_pinned = False
        self.hide_guide_job = None
        self.item_name_var = StringVar()
        self.item_id_var = StringVar()
        self.item_author_var = StringVar(value="Flowork Contributor")
        self.item_email_var = StringVar(value="contributor@teetah.art")
        self.item_website_var = StringVar(value="https://www.teetah.art")
        self.item_desc_text = None
        self.comp_prop_frame_content = None
        self._discover_and_load_components()
        self.create_widgets()
        self.item_name_var.trace_add("write", self._update_id_field)
        self.refresh_content()
        self._populate_guide()
        self.after(100, self._load_saved_design_state)
    def _apply_markdown_to_text_widget(self, text_widget, content):
        text_widget.config(state="normal")
        text_widget.delete("1.0", "end")
        parts = re.split(r'(\*\*.*?\*\*)', content)
        for part in parts:
            if part.startswith('**') and part.endswith('**'):
                text_widget.insert("end", part[2:-2], "bold")
            else:
                text_widget.insert("end", part)
        text_widget.config(state="disabled")
    def _populate_guide(self):
        guide_content = self.loc.get("generator_guide_content")
        self._apply_markdown_to_text_widget(self.guide_text, guide_content)
        self.guide_text.tag_configure("bold", font="-size 9 -weight bold")
    def _save_current_design_state(self):
        state_manager = self.kernel.get_service("state_manager")
        if not state_manager:
            messagebox.showerror("Error", "StateManager service not available.") # English Hardcode
            return
        state_data = {
            "metadata": {
                "name": self.item_name_var.get(),
                "id": self.item_id_var.get(),
                "author": self.item_author_var.get(),
                "email": self.item_email_var.get(),
                "website": self.item_website_var.get(),
                "description": self.item_desc_text.get("1.0", "end-1c").strip()
            },
            "ui_components": [],
            "logic_definition": self.logic_builder_canvas.get_logic_data()
        }
        for comp_id, comp_data in self.designed_components.items():
            widget = comp_data['widget']
            state_data["ui_components"].append({
                "id": comp_id,
                "type": comp_data['type'],
                "config": comp_data['config'],
                "x": widget.winfo_x(),
                "y": widget.winfo_y()
            })
        state_manager.set(self.DESIGN_STATE_KEY, state_data)
        messagebox.showinfo("Sukses", "Desain saat ini berhasil disimpan. Akan dimuat otomatis saat membuka halaman ini lagi.")
    def _load_saved_design_state(self):
        state_manager = self.kernel.get_service("state_manager")
        if not state_manager: return
        state_data = state_manager.get(self.DESIGN_STATE_KEY)
        if not state_data:
            return
        try:
            self._clear_canvas(ask_confirmation=False)
            meta = state_data.get("metadata", {})
            self.item_name_var.set(meta.get("name", ""))
            self.item_id_var.set(meta.get("id", ""))
            self.item_author_var.set(meta.get("author", ""))
            self.item_email_var.set(meta.get("email", ""))
            self.item_website_var.set(meta.get("website", ""))
            self.item_desc_text.delete("1.0", "end")
            self.item_desc_text.insert("1.0", meta.get("description", ""))
            for comp_info in state_data.get("ui_components", []):
                self._add_component_to_canvas(
                    component_type=comp_info['type'],
                    x=comp_info['x'],
                    y=comp_info['y'],
                    existing_id=comp_info['id'],
                    existing_config=comp_info['config']
                )
            self.logic_builder_canvas.load_logic_data(state_data.get("logic_definition"))
        except Exception as e:
            messagebox.showerror("Error", f"Gagal memuat desain yang tersimpan. File state mungkin rusak.\n\nError: {e}")
    def _clear_saved_design_state(self):
        if not messagebox.askyesno("Konfirmasi", "Anda yakin ingin menghapus desain yang tersimpan? Ini tidak bisa diurungkan."):
            return
        state_manager = self.kernel.get_service("state_manager")
        if state_manager:
            state_manager.delete(self.DESIGN_STATE_KEY)
            messagebox.showinfo("Sukses", "Desain yang tersimpan telah dihapus.")
    def _discover_and_load_components(self):
        self.kernel.write_to_log("GeneratorPage: Discovering UI component generators...") # English Log
        components_path = os.path.join(os.path.dirname(__file__), 'generator_components')
        if not os.path.exists(components_path): return
        for filename in os.listdir(components_path):
            if filename.endswith('.py') and not filename.startswith('__') and filename != 'logic_builder_canvas.py':
                module_name = f"flowork_gui.plugins.flowork_core_ui.generator_components.{filename[:-3]}" # PENAMBAHAN: Use absolute import path
                try:
                    module = importlib.import_module(module_name)
                    for name, obj in inspect.getmembers(module, inspect.isclass):
                        if issubclass(obj, BaseGeneratorComponent) and obj is not BaseGeneratorComponent:
                            instance = obj(self.kernel)
                            comp_type = instance.get_component_type()
                            self.registered_components[comp_type] = instance
                            self.kernel.write_to_log(f"  -> Loaded generator component: '{comp_type}'") # English Log
                except Exception as e:
                    self.kernel.write_to_log(f"Failed to load generator component from {filename}: {e}") # English Log
    def apply_styles(self, colors):
        style = tk_ttk.Style(self)
        if not colors: return
        style.configure('TFrame', background=colors.get('bg'))
        style.configure('TLabel', background=colors.get('bg'), foreground=colors.get('fg'))
        style.configure('TLabelframe', background=colors.get('bg'), relief="solid", borderwidth=1, bordercolor=colors.get('border'))
        style.configure('TLabelframe.Label', background=colors.get('bg'), foreground=colors.get('fg'), font=('Helvetica', 11, 'bold'))
        style.configure('Header.TLabel', font=('Helvetica', 10, 'bold'), foreground=colors.get('primary'))
        style.configure('Ghost.TLabel', background=colors.get('primary'), foreground=colors.get('fg'), padding=5, borderwidth=1, relief='solid')
        style.configure('SelectedComponent.TFrame', borderwidth=2, relief='solid', bordercolor=colors.get('info'))
        style.configure('NormalComponent.TFrame', borderwidth=1, relief='solid', bordercolor=colors.get('border'))
    def create_widgets(self):
        main_pane = ttk.PanedWindow(self, orient='horizontal')
        main_pane.pack(fill="both", expand=True, padx=15, pady=15)
        guide_handle = ttk.Frame(self, width=15, bootstyle="secondary")
        guide_handle.place(relx=0, rely=0, relheight=1, anchor='nw')
        handle_label = ttk.Label(guide_handle, text=">", bootstyle="inverse-secondary", font=("Helvetica", 10, "bold"))
        handle_label.pack(expand=True)
        guide_handle.bind("<Enter>", self._show_guide_panel)
        guide_handle.lift()
        self.guide_panel = ttk.Frame(self, bootstyle="secondary")
        control_bar = ttk.Frame(self.guide_panel, bootstyle="secondary")
        control_bar.pack(fill='x', padx=5, pady=2)
        self.guide_pin_button = ttk.Button(control_bar, text="📌", bootstyle="light-link", command=self._toggle_pin_guide)
        self.guide_pin_button.pack(side='right')
        guide_frame_inner = ttk.LabelFrame(self.guide_panel, text=self.loc.get('generator_guide_title'), padding=15)
        guide_frame_inner.pack(fill='both', expand=True, padx=5, pady=(0,5))
        guide_frame_inner.columnconfigure(0, weight=1)
        guide_frame_inner.rowconfigure(0, weight=1)
        self.guide_text = scrolledtext.ScrolledText(guide_frame_inner, wrap="word", height=10, state="disabled", font="-size 9")
        self.guide_text.grid(row=0, column=0, sticky="nsew")
        self.guide_panel.bind("<Leave>", self._hide_guide_panel_later)
        self.guide_panel.bind("<Enter>", self._cancel_hide_guide)
        left_pane = ttk.Frame(main_pane, padding=10)
        main_pane.add(left_pane, weight=2)
        design_notebook = ttk.Notebook(left_pane)
        design_notebook.pack(fill='both', expand=True)
        property_design_tab = ttk.Frame(design_notebook, padding=5)
        design_notebook.add(property_design_tab, text=" 1. Desain Properti (UI) ")
        toolbox_frame = ttk.LabelFrame(property_design_tab, text=self.loc.get('generator_toolbox_title', fallback="UI Component Toolbox"), padding=10)
        toolbox_frame.pack(side='left', fill='y', padx=(0, 10))
        for comp_type, component_instance in sorted(self.registered_components.items()):
            label = component_instance.get_toolbox_label()
            self._create_draggable_button(toolbox_frame, label, comp_type)
        design_container = ttk.Frame(property_design_tab)
        design_container.pack(side='left', fill='both', expand=True)
        self.design_canvas_frame = ttk.LabelFrame(design_container, text=self.loc.get('generator_canvas_title', fallback="Property Design Canvas"), padding=10)
        self.design_canvas_frame.pack(side='top', fill='both', expand=True)
        self.canvas_placeholder = ttk.Label(self.design_canvas_frame, text=self.loc.get('generator_canvas_placeholder', fallback="Drag components from the Toolbox here..."), bootstyle="secondary")
        self.canvas_placeholder.pack(expand=True)
        self.design_canvas_frame.bind("<Button-3>", self._show_context_menu)
        self.canvas_placeholder.bind("<Button-3>", self._show_context_menu)
        property_button_frame = ttk.Frame(design_container)
        property_button_frame.pack(side='bottom', fill='x', pady=(10,0))
        clear_button = ttk.Button(property_button_frame, text=self.loc.get('generator_clear_canvas_button', fallback="Clear Canvas"), command=self._clear_canvas, bootstyle="danger-outline")
        clear_button.pack(side='left', expand=True, fill='x', padx=(0,5))
        save_design_button = ttk.Button(property_button_frame, text="Simpan Desain", command=self._save_current_design_state, bootstyle="primary-outline")
        save_design_button.pack(side='left', expand=True, fill='x', padx=(5,5))
        clear_saved_button = ttk.Button(property_button_frame, text="Hapus Desain Tersimpan", command=self._clear_saved_design_state, bootstyle="secondary-outline")
        clear_saved_button.pack(side='left', expand=True, fill='x', padx=(5,0))
        logic_design_tab = ttk.Frame(design_notebook, padding=5)
        design_notebook.add(logic_design_tab, text=" 2. Desain Logika (Execute) ")
        self.logic_builder_canvas = LogicBuilderCanvas(logic_design_tab, self.kernel)
        self.logic_builder_canvas.pack(fill='both', expand=True)
        right_pane = ttk.Frame(main_pane, padding=10)
        main_pane.add(right_pane, weight=1)
        metadata_frame = ttk.LabelFrame(right_pane, text=self.loc.get('generator_meta_title', fallback="3. Module Info"), padding=15)
        metadata_frame.pack(fill='x', expand=False, pady=(0, 15))
        ttk.Label(metadata_frame, text=self.loc.get('generator_meta_name_label', fallback="Feature Name:")).pack(fill='x', anchor='w')
        ttk.Entry(metadata_frame, textvariable=self.item_name_var).pack(fill='x', pady=(0,5))
        ttk.Label(metadata_frame, text=self.loc.get('generator_meta_id_label', fallback="Unique ID (automatic):")).pack(fill='x', anchor='w')
        ttk.Entry(metadata_frame, textvariable=self.item_id_var, state="readonly").pack(fill='x', pady=(0,5))
        ttk.Label(metadata_frame, text=self.loc.get('generator_meta_author_label', fallback="Author:")).pack(fill='x', anchor='w')
        ttk.Entry(metadata_frame, textvariable=self.item_author_var).pack(fill='x', pady=(0,5))
        ttk.Label(metadata_frame, text=self.loc.get('generator_meta_email_label', fallback="Email:")).pack(fill='x', anchor='w')
        ttk.Entry(metadata_frame, textvariable=self.item_email_var).pack(fill='x', pady=(0,5))
        ttk.Label(metadata_frame, text=self.loc.get('generator_meta_website_label', fallback="Website:")).pack(fill='x', anchor='w')
        ttk.Entry(metadata_frame, textvariable=self.item_website_var).pack(fill='x', pady=(0,5))
        ttk.Label(metadata_frame, text=self.loc.get('generator_meta_desc_label', fallback="Description:")).pack(fill='x', anchor='w')
        self.item_desc_text = Text(metadata_frame, height=3, font=("Helvetica", 9))
        self.item_desc_text.pack(fill='x', pady=(0,5))
        self.comp_prop_frame = ttk.LabelFrame(right_pane, text=self.loc.get('generator_comp_prop_title', fallback="4. Selected Component Properties"), padding=15)
        self.comp_prop_frame.pack(fill='x', expand=False, pady=(0, 15))
        generate_frame = ttk.LabelFrame(right_pane, text=self.loc.get('generator_finalize_title', fallback="5. Finalize"), padding=15)
        generate_frame.pack(fill='x', expand=False)
        ttk.Button(generate_frame, text=self.loc.get('generator_generate_button', fallback="Generate Module ZIP File"), command=self._start_generation_process, style="success.TButton").pack(fill='x', ipady=5)
    def _create_draggable_button(self, parent, text, component_type):
        button = ttk.Button(parent, text=text)
        button.pack(fill='x', pady=2)
        button.bind("<ButtonPress-1>", lambda event, c_type=component_type: self._on_drag_start(event, c_type))
    def _on_drag_start(self, event, component_type):
        self._drag_data = {'widget': ttk.Label(self, text=event.widget.cget('text'), style='Ghost.TLabel'), 'component_type': component_type, 'drag_type': 'new_component'}
        self.winfo_toplevel().bind("<B1-Motion>", self._on_drag_motion)
        self.winfo_toplevel().bind("<ButtonRelease-1>", self._on_drag_release)
    def _on_drag_motion(self, event):
        drag_type = self._drag_data.get('drag_type')
        if not drag_type: return
        if drag_type == 'new_component':
            if self._drag_data.get('widget'): self._drag_data['widget'].place(x=event.x_root - self.winfo_toplevel().winfo_rootx(), y=event.y_root - self.winfo_toplevel().winfo_rooty())
        elif drag_type == 'move_component':
            if self._drag_data.get('widget'):
                dx, dy = event.x - self._drag_data['x'], event.y - self._drag_data['y']
                x, y = self._drag_data['widget'].winfo_x() + dx, self._drag_data['widget'].winfo_y() + dy
                self._drag_data['widget'].place(x=x, y=y)
    def _on_drag_release(self, event):
        drag_type = self._drag_data.get('drag_type')
        if not drag_type: return
        if drag_type == 'new_component':
            if self._drag_data.get('widget'): self._drag_data['widget'].destroy()
            canvas_x, canvas_y = self.design_canvas_frame.winfo_rootx(), self.design_canvas_frame.winfo_rooty()
            canvas_width, canvas_height = self.design_canvas_frame.winfo_width(), self.design_canvas_frame.winfo_height()
            if canvas_x < event.x_root < canvas_x + canvas_width and canvas_y < event.y_root < canvas_y + canvas_height:
                drop_x, drop_y = event.x_root - canvas_x - 10, event.y_root - canvas_y - 30
                self._add_component_to_canvas(self._drag_data['component_type'], drop_x, drop_y)
        self._drag_data = {}
        self.winfo_toplevel().unbind("<B1-Motion>")
        self.winfo_toplevel().unbind("<ButtonRelease-1>")
    def _add_component_to_canvas(self, component_type, x, y, existing_id=None, existing_config=None):
        if self.canvas_placeholder: self.canvas_placeholder.destroy(); self.canvas_placeholder = None
        component_generator = self.registered_components.get(component_type)
        if not component_generator: self.kernel.write_to_log(f"Attempted to add unknown component type: {component_type}", "ERROR"); return
        comp_id = existing_id or f"comp_{str(uuid.uuid4())[:8]}"
        comp_frame = ttk.Frame(self.design_canvas_frame, padding=5, style='NormalComponent.TFrame')
        if existing_config:
            config = existing_config
        else:
            var_id = f"{component_type.replace('_input','')}_{str(uuid.uuid4())[:4]}"
            config = {'label': f"My {component_type.replace('_', ' ').title()}", 'id': var_id, 'default': '', 'options': []}
            if component_type == 'checkbox': config['default'] = False
        label_widget = component_generator.create_canvas_widget(comp_frame, comp_id, config)
        for widget in [comp_frame] + comp_frame.winfo_children():
            if widget:
                widget.bind("<ButtonPress-1>", lambda e, cid=comp_id: self._on_component_press(e, cid))
                widget.bind("<B1-Motion>", self._on_drag_motion)
                widget.bind("<ButtonRelease-1>", self._on_component_release)
        comp_frame.place(x=x, y=y)
        self.designed_components[comp_id] = {'widget': comp_frame, 'label_widget': label_widget, 'type': component_type, 'config': config}
        if not existing_id:
            self._on_canvas_component_selected(None, comp_id)
    def _on_component_press(self, event, component_id):
        self._on_canvas_component_selected(event, component_id)
        widget_to_move = self.designed_components[component_id]['widget']
        self._drag_data = {'widget': widget_to_move, 'x': event.x, 'y': event.y, 'drag_type': 'move_component'}
        return "break"
    def _on_component_release(self, event):
        self._drag_data = {}
    def _on_canvas_component_selected(self, event, component_id):
        self._is_updating_from_selection = True
        if self.selected_component_id and self.selected_component_id in self.designed_components:
            if self.designed_components[self.selected_component_id]['widget'].winfo_exists():
                self.designed_components[self.selected_component_id]['widget'].config(style='NormalComponent.TFrame')
        self.selected_component_id = component_id
        component_data = self.designed_components.get(component_id)
        if not component_data: self._is_updating_from_selection = False; return
        component_data['widget'].config(style='SelectedComponent.TFrame')
        if self.comp_prop_frame_content and self.comp_prop_frame_content.winfo_exists(): self.comp_prop_frame_content.destroy()
        self.comp_prop_frame_content = ttk.Frame(self.comp_prop_frame)
        self.comp_prop_frame_content.pack(fill='both', expand=True)
        comp_type, config = component_data.get('type'), component_data.get('config', {})
        component_generator = self.registered_components.get(comp_type)
        if component_generator:
            prop_vars = component_generator.create_properties_ui(self.comp_prop_frame_content, config)
            if prop_vars:
                component_data['prop_vars'] = prop_vars
                for var in prop_vars.values():
                    if isinstance(var, (StringVar, BooleanVar)): var.trace_add('write', self._update_component_properties)
                    elif isinstance(var, Text): var.bind("<<Modified>>", self._update_component_properties)
        self._is_updating_from_selection = False
        if event: return "break"
    def _update_component_properties(self, *args):
        if self._is_updating_from_selection or not self.selected_component_id: return
        component_data = self.designed_components.get(self.selected_component_id)
        if not component_data or not component_data.get('prop_vars'): return
        prop_vars = component_data['prop_vars']
        for key, var in prop_vars.items():
            if isinstance(var, (StringVar, BooleanVar)):
                component_data['config'][key] = var.get()
            elif isinstance(var, Text):
                component_data['config'][key] = var.get('1.0', 'end-1c')
        if 'options' in component_data['config'] and isinstance(component_data['config']['options'], str):
            options_list = component_data['config']['options'].strip().split('\n')
            component_data['config']['options'] = [opt.strip() for opt in options_list if opt.strip()]
            visual_widget = next((w for w in component_data['widget'].winfo_children() if isinstance(w, ttk.Combobox)), None)
            if visual_widget: visual_widget['values'] = component_data['config']['options']
        label_widget, new_label_text = component_data.get('label_widget'), component_data['config'].get('label', '')
        if label_widget and label_widget.winfo_exists(): label_widget.config(text=new_label_text)
        if 'options' in prop_vars and isinstance(prop_vars.get('options'), Text): prop_vars['options'].edit_modified(False)
    def _show_context_menu(self, event):
        context_menu = Menu(self, tearoff=0)
        add_menu = Menu(context_menu, tearoff=0)
        canvas_x, canvas_y = self.design_canvas_frame.winfo_rootx(), self.design_canvas_frame.winfo_rooty()
        drop_x, drop_y = event.x_root - canvas_x, event.y_root - canvas_y
        for comp_type, comp_instance in sorted(self.registered_components.items()):
            add_menu.add_command(label=comp_instance.get_toolbox_label(), command=lambda ct=comp_type: self._add_component_to_canvas(ct, drop_x, drop_y))
        context_menu.add_cascade(label=self.loc.get('generator_context_add', fallback="Add Component"), menu=add_menu)
        context_menu.add_separator()
        delete_state = "normal" if self.selected_component_id else "disabled"
        context_menu.add_command(label=self.loc.get('generator_context_delete', fallback="Delete Selected"), command=self._delete_selected_component, state=delete_state)
        try: context_menu.tk_popup(event.x_root, event.y_root)
        finally: context_menu.grab_release()
    def _delete_selected_component(self):
        if not self.selected_component_id: return
        component_to_delete = self.designed_components.pop(self.selected_component_id, None)
        if component_to_delete: component_to_delete['widget'].destroy()
        self.selected_component_id = None
        if self.comp_prop_frame_content and self.comp_prop_frame_content.winfo_exists():
            for child in self.comp_prop_frame_content.winfo_children(): child.destroy()
        if not self.designed_components and (not self.canvas_placeholder or not self.canvas_placeholder.winfo_exists()):
            self.canvas_placeholder = ttk.Label(self.design_canvas_frame, text=self.loc.get('generator_canvas_placeholder', fallback="Drag components from the Toolbox here..."), bootstyle="secondary")
            self.canvas_placeholder.pack(expand=True)
            self.canvas_placeholder.bind("<Button-3>", self._show_context_menu)
    def _clear_canvas(self, ask_confirmation=True):
        do_clear = False
        if ask_confirmation:
            if messagebox.askyesno(self.loc.get('messagebox_confirm_title', fallback="Confirm"), self.loc.get('generator_confirm_clear_canvas', fallback="Are you sure you want to clear all components from the canvas?")):
                do_clear = True
        else:
            do_clear = True
        if do_clear:
            for comp_id in list(self.designed_components.keys()):
                self.designed_components[comp_id]['widget'].destroy()
                del self.designed_components[comp_id]
            self._delete_selected_component()
    def refresh_content(self):
        self.kernel.write_to_log("Generator page refreshed.", "DEBUG") # English Log
    def _update_id_field(self, *args):
        name_text = self.item_name_var.get().lower()
        sanitized_name = re.sub(r'[^a-z0-9_]', '', name_text.replace(' ', '_'))
        if sanitized_name:
            if not hasattr(self, '_current_random_suffix'): self._current_random_suffix = str(uuid.uuid4())[:4]
            id_text = f"{sanitized_name}_{self._current_random_suffix}"
            self.item_id_var.set(id_text)
        else: self.item_id_var.set("")
    def _sync_ui_to_config(self):
        if not self.selected_component_id: return
        self._is_updating_from_selection = False
        self._update_component_properties()
    def _start_generation_process(self):
        if not self.kernel.is_tier_sufficient('pro'):
            messagebox.showwarning(
                self.loc.get('license_popup_title'),
                self.loc.get('license_popup_message', module_name="Module Generator"),
                parent=self.winfo_toplevel()
            )
            return
        self._sync_ui_to_config()
        module_info = {'id': self.item_id_var.get(), 'name': self.item_name_var.get(), 'author': self.item_author_var.get(), 'email': self.item_email_var.get(), 'website': self.item_website_var.get(), 'description': self.item_desc_text.get("1.0", "end-1c").strip(), 'components': list(self.designed_components.values())}
        if not module_info['id'] or not module_info['name']:
            messagebox.showerror(self.loc.get('generator_err_missing_info_title', fallback="Info Missing"), self.loc.get('generator_err_missing_info_msg', fallback="Module Name and ID are required."))
            return
        save_path = filedialog.asksaveasfilename(title=self.loc.get('generator_save_zip_title', fallback="Save Module ZIP File"), initialfile=f"{module_info['id']}.zip", defaultextension=".zip", filetypes=[("ZIP files", "*.zip")])
        if not save_path: return
        try:
            logic_data = self.logic_builder_canvas.get_logic_data()
            manifest_content = self._generate_manifest_content(module_info)
            processor_content = self._generate_processor_content(module_info, logic_data)
            with tempfile.TemporaryDirectory() as temp_dir:
                module_root_path = os.path.join(temp_dir, module_info['id'])
                os.makedirs(os.path.join(module_root_path, 'locales'))
                with open(os.path.join(module_root_path, 'manifest.json'), 'w', encoding='utf-8') as f: json.dump(manifest_content, f, indent=4)
                with open(os.path.join(module_root_path, 'processor.py'), 'w', encoding='utf-8') as f: f.write(processor_content)
                with open(os.path.join(module_root_path, 'locales', 'id.json'), 'w', encoding='utf-8') as f: json.dump({"module_name": module_info['name']}, f, indent=4)
                with open(os.path.join(module_root_path, 'locales', 'en.json'), 'w', encoding='utf-8') as f: json.dump({"module_name": module_info['name']}, f, indent=4)
                with open(os.path.join(module_root_path, 'requirements.txt'), 'w', encoding='utf-8') as f: f.write("# Add any required Python packages here, one per line\n")
                shutil.make_archive(os.path.splitext(save_path)[0], 'zip', temp_dir)
            messagebox.showinfo(self.loc.get('messagebox_success_title', fallback="Success"), self.loc.get('generator_zip_success_msg', fallback=f"Module '{module_info['name']}' has been successfully packaged!"))
        except Exception as e:
            messagebox.showerror(self.loc.get('messagebox_error_title', fallback="Error"), self.loc.get('generator_zip_error_msg', fallback=f"An error occurred while generating the ZIP file: {e}"))
    def _generate_manifest_content(self, info):
        class_name = "".join(word.capitalize() for word in info['id'].replace('_', ' ').split()).replace(' ', '') + "Module"
        properties = []
        for comp_data in info['components']:
            comp_type, comp_config = comp_data['type'], comp_data['config']
            component_generator = self.registered_components.get(comp_type)
            if component_generator:
                entry = component_generator.generate_manifest_entry(comp_config)
                if entry: properties.append(entry)
        manifest = OrderedDict()
        ideal_order = ["id", "name", "version", "icon_file", "author", "email", "website", "description", "type", "entry_point", "behaviors", "requires_services", "properties", "output_ports"]
        manifest_data = {"id": info['id'], "name": info['name'], "version": "1.0", "icon_file": "icon.png", "author": info['author'], "email": info['email'], "website": info['website'],"description": info['description'], "type": "ACTION", "entry_point": f"processor.{class_name}", "behaviors": ["loop", "retry"], "requires_services": ["logger", "loc"],"properties": properties, "output_ports": [{"name": "success", "display_name": "Success"}, {"name": "error", "display_name": "Error"}]}
        for key in ideal_order:
            if key in manifest_data: manifest[key] = manifest_data[key]
        return manifest
    def _generate_processor_content(self, info, logic_data):
        class_name = "".join(word.capitalize() for word in info['id'].replace('_', ' ').split()).replace(' ', '') + "Module"
        all_imports = {
            "from flowork_kernel.api_contract import BaseModule, IExecutable, IConfigurableUI, IDataPreviewer",
            "import ttkbootstrap as ttk",
            "from flowork_kernel.ui_shell import shared_properties",
            "from flowork_kernel.utils.payload_helper import get_nested_value",
            "import json"
        }
        for comp_data in info['components']:
            comp_type = comp_data['type']
            component_generator = self.registered_components.get(comp_type)
            if component_generator: all_imports.update(component_generator.get_required_imports())
        imports_str = "\n".join(sorted(list(all_imports)))
        execute_lines = [
            "    def execute(self, payload: dict, config: dict, status_updater, ui_callback, mode='EXECUTE'):",
            f"        self.logger(f\"Executing '{info['name']}' module logic...\", \"INFO\")",
            "        # This logic was visually generated by the Logic Builder Canvas.",
            "        internal_payload = payload.copy()",
            "        node_results = {}",
            "        module_manager = self.kernel.get_service(\"module_manager_service\")",
            "",
            "        def run_logic_node(node_id, current_payload, node_config_str):",
            "            # Replace config placeholders with actual values from the main module's config",
            "            for key, value in config.items():",
            "                placeholder = f'{{{{config.{key}}}}}'",
            "                node_config_str = node_config_str.replace(placeholder, str(value))",
            "            node_config = json.loads(node_config_str)",
            "            module_id = node_config.get('module_id')",
            "            instance = module_manager.get_instance(module_id)",
            "            if not instance: raise Exception(f'Logic node module {{module_id}} not found')",
            "            return instance.execute(current_payload, node_config.get('config_values', {}), lambda m, l: None, ui_callback, mode)",
            ""
        ]
        nodes = {node['id']: node for node in logic_data['nodes']}
        connections = logic_data['connections']
        all_node_ids = set(nodes.keys())
        nodes_with_incoming = set(conn['to'] for conn in connections)
        start_nodes = list(all_node_ids - nodes_with_incoming)
        execution_flow = {}
        for conn in connections:
            if conn['from'] not in execution_flow:
                execution_flow[conn['from']] = []
            execution_flow[conn['from']].append(conn)
        nodes_to_process = start_nodes[:]
        processed_nodes = set()
        while nodes_to_process:
            node_id = nodes_to_process.pop(0)
            if node_id in processed_nodes:
                continue
            node_info = nodes[node_id]
            node_var = f"node_results['{node_id}']"
            incoming_conns = [c for c in connections if c['to'] == node_id]
            if not incoming_conns:
                input_payload = "internal_payload"
            else:
                prev_node_id = incoming_conns[0]['from']
                input_payload = f"node_results.get('{prev_node_id}', {{}})"
            execute_lines.append(f"        # --- Executing Logic Node: {node_info.get('name')} ---")
            execute_lines.append(f"        self.logger('  -> Running logic for: {node_info.get('name')}', 'DEBUG')")
            node_config_as_string_literal = repr(json.dumps(node_info))
            execute_lines.append(f"        {node_var} = run_logic_node('{node_id}', {input_payload}, {node_config_as_string_literal})")
            processed_nodes.add(node_id)
            if node_id in execution_flow:
                for conn in execution_flow[node_id]:
                    if conn['to'] not in processed_nodes:
                        nodes_to_process.append(conn['to'])
        end_nodes = list(all_node_ids - set(conn['from'] for conn in connections))
        if end_nodes:
            final_payload_source = f"node_results.get('{end_nodes[0]}', internal_payload)"
        else:
            final_payload_source = "internal_payload"
        execute_lines.append("")
        execute_lines.append(f"        final_payload = {final_payload_source}")
        execute_lines.append("        status_updater(\"Visual logic execution complete\", \"SUCCESS\")") # English Hardcode
        execute_lines.append("        return {\"payload\": final_payload, \"output_name\": \"success\"}")
        execute_str = "\n".join(execute_lines)
        prop_ui_lines = ["    def create_properties_ui(self, parent_frame, get_current_config, available_vars):","        config = get_current_config()","        property_vars = {}","        # Custom UI elements are generated based on the visual design",]
        for comp_data in info['components']:
            comp_type, comp_config = comp_data['type'], comp_data['config']
            component_generator = self.registered_components.get(comp_type)
            if component_generator: prop_ui_lines.extend(component_generator.generate_processor_ui_code(comp_config))
        prop_ui_lines.extend(["        # Standard settings UI","        ttk.Separator(parent_frame).pack(fill='x', pady=15, padx=5)","        debug_vars = shared_properties.create_debug_and_reliability_ui(parent_frame, config, self.loc)","        property_vars.update(debug_vars)","        loop_vars = shared_properties.create_loop_settings_ui(parent_frame, config, self.loc, available_vars)","        property_vars.update(loop_vars)","        return property_vars"])
        prop_ui_str = "\n".join(prop_ui_lines)
        code = f"""{imports_str}
class {class_name}(BaseModule, IExecutable, IConfigurableUI, IDataPreviewer):
    TIER = "pro"
    \"\"\"
    Module '{info['name']}' generated by Flowork Module Factory.
    Author: {info['author']}
    \"\"\"
    def __init__(self, module_id, services):
        super().__init__(module_id, services)
        self.logger("Module '{info['name']}' initialized.", "INFO")
{execute_str}
{prop_ui_str}
    def get_data_preview(self, config: dict):
        \"\"\"
        TODO: Implement the data preview logic for this module.
        \"\"\"
        self.logger(f"'get_data_preview' is not yet implemented for {{self.module_id}}", 'WARN')
        return [{{'status': 'preview not implemented'}}]
"""
        return code
    def _toggle_pin_guide(self):
        self.guide_is_pinned = not self.guide_is_pinned
        pin_char = "📌"
        self.guide_pin_button.config(text=pin_char)
        if not self.guide_is_pinned:
            self._hide_guide_panel_later()
    def _show_guide_panel(self, event=None):
        self._cancel_hide_guide()
        self.guide_panel.place(in_=self, relx=0, rely=0, relheight=1.0, anchor='nw', width=350)
        self.guide_panel.lift()
    def _hide_guide_panel_later(self, event=None):
        if not self.guide_is_pinned:
            self.hide_guide_job = self.after(300, lambda: self.guide_panel.place_forget())
    def _cancel_hide_guide(self, event=None):
        if self.hide_guide_job:
            self.after_cancel(self.hide_guide_job)
            self.hide_guide_job = None
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\manifest.json
# JUMLAH BARIS : 20
#######################################################################

```json
{
    "id": "flowork_core_ui",
    "name": "Flowork Core UI",
    "version": "1.0",
    "icon_file": "icon.png",
    "author": "Awenk Audico",
    "email": "Contributor@teetah.art",
    "website": "www.teetah.art",
    "description": "Menyediakan semua antarmuka manajemen inti untuk Flowork.",
    "type": "PLUGIN",
    "entry_point": "core_ui_provider.CoreUIProvider",
    "requires_services": [
        "kernel",
        "loc",
        "logger"
    ],
    "permissions": [
        "ui_provider"
    ]
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\marketplace_page.py
# JUMLAH BARIS : 512
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import messagebox, filedialog
import os
import threading
import json
import webbrowser
import requests
import tempfile
from .upload_dialog import UploadDialog
from api_client.client import ApiClient # PENAMBAHAN: Alamat yang benar
class MarketplacePage(ttk.Frame):
    def __init__(self, parent_notebook, api_client, loc_service, tab_id=None, is_new_tab=False, **kwargs): # PENAMBAHAN: Konstruktor baru
        kwargs.pop('tab_id', None)
        kwargs.pop('is_new_tab', None)
        super().__init__(parent_notebook, **kwargs)
        self.loc = loc_service
        self.api_client = api_client
        class MockKernel:
            def __init__(self, api_client_instance, loc_instance):
                self.api_client = api_client_instance
                self.loc = loc_instance
                self.current_user = None # Diisi oleh data dari API nanti
                self.license_tier = 'free'
                self.services = { "event_bus": self } # Mock EventBus
            def get_service(self, service_name):
                return self.services.get(service_name)
            def write_to_log(self, msg, lvl="INFO"):
                print(f"[{lvl}] (from MockKernel in MarketplacePage): {msg}")
            def is_monetization_active(self): return True
            def is_tier_sufficient(self, tier): return True
            def subscribe(self, event, id, callback): pass
        self.kernel = MockKernel(self.api_client, self.loc)
        self.local_component_trees = {}
        self.community_component_trees = {}
        self.local_cache = {}
        self.community_cache = {}
        self.main_notebook = None
        self.ui_ready = False
        self._build_ui()
        self._fetch_all_data_and_refresh()
        event_bus = self.kernel.get_service("event_bus")
        if event_bus:
            subscriber_id = f"marketplace_page_{id(self)}"
            event_bus.subscribe("COMPONENT_LIST_CHANGED", subscriber_id, self.refresh_content)
    def _build_ui(self):
        main_frame = ttk.Frame(self, padding=15)
        main_frame.pack(fill='both', expand=True)
        self.ads_frame = ttk.LabelFrame(main_frame, text="Community Highlights", padding=10, width=350) # English Hardcode
        self.ads_frame.pack(side='right', fill='y', padx=(10, 0))
        self.ads_frame.pack_propagate(False)
        left_pane = ttk.Frame(main_frame)
        left_pane.pack(side='left', fill='both', expand=True)
        action_frame = ttk.Frame(left_pane)
        action_frame.pack(fill='x', pady=(0, 10))
        self.install_button = ttk.Button(action_frame, text=self.loc.get('marketplace_install_btn', fallback="Install from Zip..."), command=self._install_component, bootstyle="success")
        self.install_button.pack(side='left', padx=(0, 10))
        self.upload_button = ttk.Button(action_frame, text=self.loc.get('marketplace_upload_btn', fallback="Upload to Community..."), command=self._upload_selected_component, bootstyle="info")
        self.upload_button.pack(side='left', padx=(0,10))
        self.toggle_button = ttk.Button(action_frame, text=self.loc.get('marketplace_disable_btn', fallback="Disable Selected"), command=self._toggle_selected_component, bootstyle="warning")
        self.toggle_button.pack(side='left', padx=(0, 10))
        self.uninstall_button = ttk.Button(action_frame, text=self.loc.get('marketplace_uninstall_btn', fallback="Uninstall Selected"), command=self._uninstall_selected_component, bootstyle="danger")
        self.uninstall_button.pack(side='left')
        search_bar_frame = ttk.Frame(left_pane)
        search_bar_frame.pack(fill='x', pady=(0, 10))
        self.search_var = ttk.StringVar()
        self.search_var.trace_add("write", self._on_search)
        search_entry = ttk.Entry(search_bar_frame, textvariable=self.search_var)
        search_entry.pack(fill='x', expand=True)
        search_entry.insert(0, self.loc.get('marketplace_search_placeholder', fallback="Search by Name, ID, or Description..."))
        self.main_notebook = ttk.Notebook(left_pane)
        self.main_notebook.pack(fill='both', expand=True)
        self.main_notebook.bind("<<NotebookTabChanged>>", self._on_tab_change)
        local_tab = ttk.Frame(self.main_notebook)
        community_tab = ttk.Frame(self.main_notebook)
        self.main_notebook.add(local_tab, text=self.loc.get('marketplace_tab_local', fallback="Locally Installed"))
        self.main_notebook.add(community_tab, text=self.loc.get('marketplace_tab_community', fallback="Community"))
        self._create_component_notebook(local_tab, self.local_component_trees)
        self._create_component_notebook(community_tab, self.community_component_trees)
        self.ui_ready = True
    def refresh_content(self, event_data=None):
        self.kernel.write_to_log("MarketplacePage received a signal to refresh its content.", "INFO") # English Log
        self._fetch_all_data_and_refresh()
    def _fetch_all_data_and_refresh(self):
        threading.Thread(target=self._fetch_all_data_worker, daemon=True).start()
    def _create_component_notebook(self, parent_tab, tree_dict):
        notebook = ttk.Notebook(parent_tab)
        notebook.pack(fill='both', expand=True)
        component_types = {
            "modules": self.loc.get('marketplace_tab_modules', fallback="Modules"),
            "plugins": self.loc.get('marketplace_tab_plugins', fallback="Plugins"),
            "widgets": self.loc.get('marketplace_tab_widgets', fallback="Widgets"),
            "presets": self.loc.get('marketplace_tab_presets', fallback="Presets"),
            "triggers": "Triggers", # English Hardcode
            "ai_providers": "AI Providers", # English Hardcode
            "ai_models": "AI Models" # English Hardcode
        }
        is_monet_active = self.kernel.is_monetization_active()
        for comp_type, tab_title in component_types.items():
            tab = ttk.Frame(notebook, padding=5)
            notebook.add(tab, text=tab_title)
            columns = ["name", "description"]
            if is_monet_active:
                columns.append("tier")
            if comp_type == 'ai_models':
                columns.append("downloads")
            else:
                columns.append("version")
            columns.append("status")
            tree = ttk.Treeview(tab, columns=tuple(columns), show="headings")
            tree.heading("name", text=self.loc.get('marketplace_col_name', fallback="Addon Name"))
            tree.column("name", width=250)
            tree.heading("description", text=self.loc.get('marketplace_col_desc', fallback="Description"))
            tree.column("description", width=400)
            if is_monet_active:
                tree.heading("tier", text=self.loc.get('marketplace_col_tier', fallback="Tier"))
                tree.column("tier", width=80, anchor='center')
            if comp_type == 'ai_models':
                tree.heading("downloads", text=self.loc.get('marketplace_col_downloads', fallback="Downloads"))
                tree.column("downloads", width=80, anchor='center')
            else:
                tree.heading("version", text=self.loc.get('marketplace_col_version', fallback="Version"))
                tree.column("version", width=80, anchor='center')
            tree.heading("status", text=self.loc.get('marketplace_col_status', fallback="Status"))
            tree.column("status", width=100, anchor='center')
            tree.pack(fill='both', expand=True)
            tree.bind('<<TreeviewSelect>>', self._update_button_state)
            tree_dict[comp_type] = tree
    def _populate_ads_panel(self, success, ads_data):
        if not self.winfo_exists() or not self.ads_frame.winfo_exists():
            return
        for widget in self.ads_frame.winfo_children():
            widget.destroy()
        if not success or not ads_data:
            ttk.Label(self.ads_frame, text="Cannot load highlights at the moment.").pack() # English Hardcode
            return
        styles = ["primary", "info", "success", "warning", "danger", "secondary"]
        for i, ad in enumerate(ads_data):
            style = styles[i % len(styles)]
            ad_card = ttk.LabelFrame(self.ads_frame, text=ad.get("title", "Ad"), padding=10, bootstyle=style)
            ad_card.pack(fill="x", pady=5)
            ttk.Label(ad_card, text=ad.get("text", ""), wraplength=280).pack(anchor='w', pady=(0, 10))
            if "target_url" in ad and "button_text" in ad:
                ttk.Button(
                    ad_card,
                    text=ad.get("button_text"),
                    bootstyle=f"{style}-outline",
                    command=lambda url=ad.get("target_url"): webbrowser.open(url)
                ).pack(anchor='e')
    def _get_current_tab_info(self):
        try:
            if not self.main_notebook or not self.main_notebook.winfo_exists():
                return None, None, True
            active_main_tab_text = self.main_notebook.tab(self.main_notebook.select(), "text")
            if self.loc.get('marketplace_tab_local', fallback="Locally Installed") in active_main_tab_text:
                if not self.main_notebook.nametowidget(self.main_notebook.select()).winfo_exists():
                    return None, None, True
                notebook = self.main_notebook.nametowidget(self.main_notebook.select()).winfo_children()[0]
                tree_dict = self.local_component_trees
                is_local = True
            else:
                if not self.main_notebook.nametowidget(self.main_notebook.select()).winfo_exists():
                    return None, None, False
                notebook = self.main_notebook.nametowidget(self.main_notebook.select()).winfo_children()[0]
                tree_dict = self.community_component_trees
                is_local = False
            if not notebook.winfo_exists():
                return None, None, is_local
            tab_text = notebook.tab(notebook.select(), "text").strip()
            tab_map = {
                self.loc.get('marketplace_tab_modules', fallback="Modules"): 'modules',
                self.loc.get('marketplace_tab_plugins', fallback="Plugins"): 'plugins',
                self.loc.get('marketplace_tab_widgets', fallback="Widgets"): 'widgets',
                self.loc.get('marketplace_tab_presets', fallback="Presets"): 'presets',
                "Triggers": 'triggers',
                "AI Providers": 'ai_providers',
                "AI Models": 'ai_models'
            }
            comp_type = tab_map.get(tab_text, 'modules')
            return comp_type, tree_dict.get(comp_type), is_local
        except Exception:
            return 'modules', self.local_component_trees.get('modules'), True
    def _fetch_all_data_worker(self):
        threads = []
        def fetch_component_data(comp_type):
            success_local, local_data = self.api_client.get_components(comp_type)
            self.local_cache[comp_type] = local_data if success_local else []
            if not success_local:
                self.kernel.write_to_log(f"API Error fetching local {comp_type}: {local_data}", "ERROR")
            success_remote, remote_data = self.api_client.get_marketplace_index(comp_type)
            self.community_cache[comp_type] = remote_data if success_remote else []
            if not success_remote:
                self.kernel.write_to_log(f"API Error fetching remote {comp_type}: {remote_data}", "WARN")
        for comp_type in self.local_component_trees.keys():
            thread = threading.Thread(target=fetch_component_data, args=(comp_type,))
            threads.append(thread)
            thread.start()
        for thread in threads:
            thread.join()
        success_ads, ads_data = self.api_client.get_marketplace_ads()
        self.after(0, self._refresh_all_lists)
        self.after(0, self._populate_ads_panel, success_ads, ads_data)
    def _refresh_all_lists(self):
        for comp_type in self.local_component_trees.keys():
            self._refresh_list(comp_type, self.local_component_trees.get(comp_type), self.local_cache, is_local_tab=True)
        for comp_type in self.community_component_trees.keys():
            self._refresh_list(comp_type, self.community_component_trees.get(comp_type), self.community_cache, is_local_tab=False)
        self._update_button_state()
    def _refresh_list(self, component_type, tree, data_cache, is_local_tab):
        if not tree or not tree.winfo_exists():
            return
        for item in tree.get_children():
            tree.delete(item)
        search_query = self.search_var.get().lower()
        if search_query == self.loc.get('marketplace_search_placeholder', fallback="Search by Name, ID, or Description...").lower():
            search_query = ""
        search_keywords = search_query.split()
        data = data_cache.get(component_type, [])
        all_local_ids = set()
        for c_type in self.local_cache.keys():
            for item in self.local_cache.get(c_type, []):
                all_local_ids.add(item['id'])
        is_monet_active = self.kernel.is_monetization_active()
        for component in sorted(data, key=lambda x: x.get('name', '').lower()):
            searchable_string = (f"{component.get('name', '').lower()} {component.get('id', '').lower()} {component.get('description', '').lower()}")
            if all(keyword in searchable_string for keyword in search_keywords):
                status = ""
                if is_local_tab:
                    status = self.loc.get('status_disabled') if component.get('is_paused') else self.loc.get('status_enabled')
                else:
                    if component.get('id') in all_local_ids:
                        status = self.loc.get('marketplace_status_installed', fallback="Installed")
                    else:
                        status = self.loc.get('marketplace_status_not_installed', fallback="Not Installed")
                tags = ('paused',) if component.get('is_paused') and is_local_tab else ('enabled',)
                values = [
                    component.get('name', ''),
                    component.get('description', '')
                ]
                if is_monet_active:
                    values.append(component.get('tier', 'N/A').capitalize())
                if component_type == 'ai_models':
                    values.append(component.get('downloads', 0))
                else:
                    values.append(component.get('version', ''))
                values.append(status)
                tree.insert("", "end", iid=component['id'], values=tuple(values), tags=tags)
        theme_manager = self.kernel.get_service("theme_manager")
        colors = theme_manager.get_colors() if theme_manager else {}
        tree.tag_configure('paused', foreground='grey')
        tree.tag_configure('enabled', foreground=colors.get('fg', 'white'))
    def _on_search(self, *args):
        if not self.ui_ready: return
        self._refresh_all_lists()
    def _on_tab_change(self, event=None):
        self._update_button_state()
        self._refresh_all_lists()
    def _update_button_state(self, event=None):
        if not self.ui_ready or not self.winfo_exists():
            return
        comp_type, tree, is_local = self._get_current_tab_info()
        if not tree or not tree.winfo_exists():
            return
        selected_items = tree.selection()
        all_buttons_exist = all(hasattr(self, btn) and getattr(self, btn).winfo_exists() for btn in ['install_button', 'toggle_button', 'uninstall_button', 'upload_button'])
        if not all_buttons_exist:
            return
        if is_local:
            self.install_button.config(text=self.loc.get('marketplace_install_btn', fallback="Install from Zip..."), state="normal")
            self.toggle_button.config(state="disabled", text=self.loc.get('marketplace_disable_btn', fallback="Disable Selected"))
            self.uninstall_button.config(state="disabled")
            self.upload_button.config(state="disabled")
            if not selected_items: return
            selected_id = selected_items[0]
            component_data = next((item for item in self.local_cache.get(comp_type, []) if item['id'] == selected_id), None)
            if not component_data: return
            is_core = component_data.get('is_core', False)
            if not is_core:
                self.uninstall_button.config(state="normal")
                can_upload = self.kernel.current_user is not None
                self.upload_button.config(state="normal" if can_upload else "disabled")
                is_preset = comp_type == 'presets'
                is_model = comp_type == 'ai_models'
                self.toggle_button.config(state="normal" if not is_preset and not is_model else "disabled")
                tags = tree.item(selected_id, "tags")
                if 'paused' in tags:
                    self.toggle_button.config(text=self.loc.get('marketplace_enable_btn', fallback="Enable Selected"))
                else:
                    self.toggle_button.config(text=self.loc.get('marketplace_disable_btn', fallback="Disable Selected"))
        else: # Community tab
            install_text = self.loc.get('marketplace_install_model_btn', fallback="Download Model") if comp_type == 'ai_models' else self.loc.get('marketplace_install_community_btn', fallback="Install from Community")
            self.install_button.config(text=install_text, state="normal" if selected_items else "disabled")
            self.toggle_button.config(state="disabled")
            self.uninstall_button.config(state="disabled")
            self.upload_button.config(state="disabled")
    def _upload_selected_component(self):
        if not self.kernel.current_user:
            messagebox.showwarning("Login Required", "You must be logged in to upload components to the marketplace.", parent=self) # English Hardcode
            if hasattr(self.kernel.root, '_open_authentication_dialog'):
                self.kernel.root._open_authentication_dialog()
            return
        comp_type, tree, is_local = self._get_current_tab_info()
        if not is_local or not tree: return
        selected_items = tree.selection()
        if not selected_items: return
        component_id = selected_items[0]
        component_name = tree.item(component_id, "values")[0]
        dialog = UploadDialog(self, self.kernel, component_name)
        if not dialog.result:
            self.kernel.write_to_log("Upload process cancelled by user.", "INFO")
            return
        upload_details = dialog.result
        if not messagebox.askyesno(
            self.loc.get('marketplace_upload_confirm_title'),
            self.loc.get('marketplace_upload_confirm_message', component_name=component_name)
        ):
            return
        self.kernel.write_to_log(f"UI: Sending upload request for '{component_name}' to the API server...", "INFO")
        if comp_type == 'ai_models':
            model_path = os.path.join(self.kernel.project_root_path, "ai_models", f"{component_id}.gguf")
            threading.Thread(target=self._upload_model_worker, args=(model_path, upload_details), daemon=True).start()
        else:
            threading.Thread(target=self._upload_worker, args=(comp_type, component_id, upload_details), daemon=True).start()
    def _upload_model_worker(self, model_path, upload_details):
        self.after(0, self.upload_button.config, {"state": "disabled", "text": "Uploading Model..."}) # English Hardcode
        success, response = self.api_client.upload_model(
            model_path=model_path,
            description=upload_details['description'],
            tier=upload_details['tier']
        )
        if success:
            self.after(0, messagebox.showinfo, self.loc.get('messagebox_success_title'), self.loc.get('marketplace_upload_success'))
        else:
            error_message = response if isinstance(response, str) else response.get('error', 'Unknown error occurred.')
            self.after(0, messagebox.showerror, self.loc.get('messagebox_error_title'), self.loc.get('marketplace_upload_failed', error=error_message))
        self.after(0, self.upload_button.config, {"state": "normal", "text": self.loc.get('marketplace_upload_btn')})
        self.after(0, self._fetch_all_data_and_refresh)
    def _upload_worker(self, comp_type, component_id, upload_details):
        self.after(0, self.upload_button.config, {"state": "disabled", "text": "Uploading..."}) # English Hardcode
        success, response = self.api_client.upload_component(
            comp_type=comp_type,
            component_id=component_id,
            description=upload_details['description'],
            tier=upload_details['tier']
        )
        if success:
            self.after(0, messagebox.showinfo, self.loc.get('messagebox_success_title'), self.loc.get('marketplace_upload_success'))
        else:
            error_message = response if isinstance(response, str) else response.get('error', 'Unknown error occurred.')
            self.after(0, messagebox.showerror, self.loc.get('messagebox_error_title'), self.loc.get('marketplace_upload_failed', error=error_message))
        self.after(0, self.upload_button.config, {"state": "normal", "text": self.loc.get('marketplace_upload_btn')})
        self.after(0, self._fetch_all_data_and_refresh)
    def _toggle_selected_component(self):
        comp_type, tree, is_local = self._get_current_tab_info()
        if not is_local or not tree: return
        selected_items = tree.selection()
        if not selected_items: return
        component_id = selected_items[0]
        tags = tree.item(component_id, "tags")
        is_currently_paused = 'paused' in tags
        new_paused_state = not is_currently_paused
        success, response = self.api_client.update_component_state(comp_type, component_id, new_paused_state)
        if success:
            action = "disabled" if new_paused_state else "enabled"
            self.kernel.write_to_log(f"Component '{component_id}' has been {action}.", "SUCCESS")
            if messagebox.askyesno(
                self.loc.get('marketplace_hot_reload_prompt_title', fallback="Reload Required"),
                self.loc.get('marketplace_toggle_hot_reload_prompt_message', fallback="State changed successfully. Reload all components now to apply?")
            ):
                threading.Thread(target=self.api_client.trigger_hot_reload, daemon=True).start()
        else:
            messagebox.showerror(self.loc.get("messagebox_error_title"), f"API Error: {response}")
    def _uninstall_selected_component(self):
        comp_type, tree, is_local = self._get_current_tab_info()
        if not is_local or not tree: return
        selected_items = tree.selection()
        if not selected_items: return
        component_id = selected_items[0]
        component_name = tree.item(component_id, "values")[0]
        if not messagebox.askyesno(self.loc.get('messagebox_confirm_title'), self.loc.get('marketplace_uninstall_confirm', component_name=component_name)):
            return
        success, response = self.api_client.delete_component(comp_type, component_id)
        if success:
            self.kernel.write_to_log(f"Component '{component_id}' has been uninstalled.", "SUCCESS")
            if messagebox.askyesno(
                self.loc.get('marketplace_hot_reload_prompt_title', fallback="Reload Required"),
                self.loc.get('marketplace_uninstall_hot_reload_prompt_message', fallback="Uninstallation successful. Reload all components now to apply changes?")
            ):
                threading.Thread(target=self.api_client.trigger_hot_reload, daemon=True).start()
        else:
            messagebox.showerror(self.loc.get("messagebox_error_title"), f"API Error: {response}")
    def _install_component(self):
        comp_type, tree, is_local = self._get_current_tab_info()
        if not is_local: # Community Tab Logic
            if not self.kernel.is_monetization_active():
                if not self.kernel.current_user:
                    messagebox.showwarning("Login Required", "You must be logged in to download components from the community.", parent=self) # English Hardcode
                    if hasattr(self.kernel.root, '_open_authentication_dialog'):
                        self.kernel.root._open_authentication_dialog()
                    return # Stop the install process
            if not tree: return
            selected_items = tree.selection()
            if not selected_items:
                messagebox.showwarning(
                    self.loc.get('marketplace_warn_no_selection_title', fallback="Warning"),
                    self.loc.get('marketplace_warn_no_selection_msg', fallback="Please select a component from the community list to install.")
                )
                return
            component_id = selected_items[0]
            component_data = next((item for item in self.community_cache.get(comp_type, []) if item['id'] == component_id), None)
            if not component_data: return
            required_tier = component_data.get('tier', 'free').lower()
            if not self.kernel.is_tier_sufficient(required_tier):
                messagebox.showerror(
                    self.loc.get('marketplace_install_failed_title', fallback="Installation Failed"),
                    self.loc.get('marketplace_install_tier_error', tier=required_tier.capitalize(), userTier=self.kernel.license_tier.capitalize(), fallback=f"This component requires a '{required_tier.capitalize()}' tier license, but your current tier is '{self.kernel.license_tier.capitalize()}'.")
                )
                return
            if comp_type == 'presets':
                threading.Thread(target=self._download_and_install_preset_worker, args=(component_data,), daemon=True).start()
                return
            if comp_type == 'ai_models':
                threading.Thread(target=self._download_and_install_model_worker, args=(component_data,), daemon=True).start()
                return
            download_url = component_data.get('download_url')
            if not download_url:
                messagebox.showerror(self.loc.get('error_title', fallback="Error"), self.loc.get('marketplace_install_no_url_error', fallback="The download URL for this component is not available."))
                return
            threading.Thread(target=self._download_and_install_worker, args=(comp_type, component_data), daemon=True).start()
        else: # Local Tab Logic
            filepath = filedialog.askopenfilename(
                title=self.loc.get('marketplace_install_dialog_title'),
                filetypes=[("Zip files", "*.zip")]
            )
            if not filepath:
                return
            success, response = self.api_client.install_component(comp_type, filepath)
            self._on_install_complete(success, response)
    def _download_and_install_model_worker(self, model_data):
        download_url = model_data.get('download_url')
        model_name = model_data.get('id')
        self.after(0, self.install_button.config, {"state": "disabled", "text": f"Downloading {model_name}..."}) # English Hardcode
        try:
            with requests.get(download_url, stream=True) as r:
                r.raise_for_status()
                save_path = os.path.join(self.kernel.project_root_path, "ai_models", f"{model_name}.gguf")
                with open(save_path, 'wb') as f:
                    for chunk in r.iter_content(chunk_size=8192):
                        f.write(chunk)
            self.api_client.trigger_hot_reload()
            self.after(0, messagebox.showinfo, self.loc.get('messagebox_success_title'), f"Model '{model_name}' downloaded successfully to your ai_models folder.")
            self.after(0, self._fetch_all_data_and_refresh)
        except Exception as e:
            self.after(0, messagebox.showerror, self.loc.get('messagebox_error_title'), f"Failed to download model: {e}")
        finally:
            self.after(0, self.install_button.config, {"state": "normal", "text": self.loc.get('marketplace_install_model_btn')})
    def _download_and_install_preset_worker(self, preset_data):
        download_url = preset_data.get('download_url')
        preset_name = preset_data.get('id')
        self.after(0, self.install_button.config, {"state": "disabled", "text": f"Downloading {preset_name}..."})
        try:
            response = requests.get(download_url, timeout=20)
            response.raise_for_status()
            preset_content = response.json()
            success, save_response = self.api_client.save_preset(preset_name, preset_content)
            if success:
                self.after(0, messagebox.showinfo, self.loc.get('messagebox_success_title'), f"Preset '{preset_name}' was installed successfully.")
                self.after(0, self._fetch_all_data_and_refresh)
            else:
                self.after(0, messagebox.showerror, self.loc.get('messagebox_error_title'), f"Failed to save preset: {save_response}")
        except requests.exceptions.RequestException as e:
            self.after(0, messagebox.showerror, self.loc.get('messagebox_error_title'), f"Failed to download preset: {e}")
        except json.JSONDecodeError:
            self.after(0, messagebox.showerror, self.loc.get('messagebox_error_title'), "Downloaded preset file is not valid JSON.")
        except Exception as e:
            self.after(0, messagebox.showerror, self.loc.get('messagebox_error_title'), f"An unexpected error occurred: {e}")
        finally:
            self.after(0, self.install_button.config, {"state": "normal", "text": "Install from Community"})
    def _download_and_install_worker(self, comp_type, component_data):
        download_url = component_data.get('download_url')
        component_name = component_data.get('name')
        self.after(0, self.install_button.config, {"state": "disabled", "text": f"Downloading {component_name}..."})
        try:
            with requests.get(download_url, stream=True) as r:
                r.raise_for_status()
                with tempfile.NamedTemporaryFile(delete=False, suffix=".zip") as tmp_file:
                    temp_filepath = tmp_file.name
                    for chunk in r.iter_content(chunk_size=8192):
                        tmp_file.write(chunk)
            success, response = self.api_client.install_component(comp_type, temp_filepath)
            os.unlink(temp_filepath)
            self.after(0, self._on_install_complete, success, response)
        except Exception as e:
            self.after(0, self._on_install_complete, False, str(e))
    def _on_install_complete(self, success, response):
        if success:
            self.kernel.write_to_log(f"Component installed via community tab.", "SUCCESS")
            if messagebox.askyesno(
                self.loc.get('marketplace_hot_reload_prompt_title', fallback="Reload Required"),
                self.loc.get('marketplace_install_hot_reload_prompt_message', fallback="Installation successful. Reload all components now to use the new component?")
            ):
                threading.Thread(target=self.api_client.trigger_hot_reload, daemon=True).start()
        else:
            messagebox.showerror(self.loc.get("messagebox_error_title"), f"API Error: {response}")
        self._update_button_state()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\model_converter_page.py
# JUMLAH BARIS : 232
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, messagebox, scrolledtext, filedialog
import os
import re
import threading
import time
from flowork_gui.api_client.client import ApiClient
class ModelConverterPage(ttk.Frame):
    """
    The user interface for the Model Factory, allowing users to convert
    fine-tuned models into the efficient GGUF format.
    [MODIFIED] Added a tutorial and guide panel.
    [FIXED] Correctly identifies the notebook widget to get the active tab.
    """
    TIER = "pro" # (ADDED) Define the required license tier for this feature
    def __init__(self, parent_notebook, api_client, loc_service, **kwargs): # PENAMBAHAN: New init signature.
        super().__init__(parent_notebook, padding=0)
        self.loc = loc_service
        self.api_client = api_client
        class MockKernel:
            def __init__(self, api_client_instance, loc_instance):
                self.api_client = api_client_instance
                self.loc = loc_instance
                self.services = {'localization_manager': self.loc}
            def get_service(self, service_name):
                return self.services.get(service_name)
            def is_tier_sufficient(self, tier): # PENAMBAHAN: Simple mock for tier check
                return True # Assuming GUI has access if the page is visible
        self.kernel = MockKernel(self.api_client, self.loc)
        self.guide_is_pinned = False
        self.hide_guide_job = None
        self.source_model_var = StringVar()
        self.output_name_var = StringVar()
        self.source_gguf_var = StringVar()
        self.requantize_output_name_var = StringVar()
        self.quantize_method_var = StringVar(value="Q4_K_M")
        self.job_id = None
        self.is_polling = False
        self.main_notebook = None # (ADDED) Initialize main_notebook attribute
        self._build_ui()
        self._load_initial_data()
        self._populate_guide()
    def _apply_markdown_to_text_widget(self, text_widget, content):
        text_widget.config(state="normal")
        text_widget.delete("1.0", "end")
        parts = re.split(r'(\*\*.*?\*\*)', content)
        for part in parts:
            if part.startswith('**') and part.endswith('**'):
                text_widget.insert("end", part[2:-2], "bold")
            else:
                text_widget.insert("end", part)
        text_widget.config(state="disabled")
    def _populate_guide(self):
        guide_content = self.loc.get("model_converter_guide_content")
        self._apply_markdown_to_text_widget(self.guide_text, guide_content)
        self.guide_text.tag_configure("bold", font="-size 9 -weight bold")
    def _build_ui(self):
        """Builds the main widgets for the page."""
        main_content_frame = ttk.Frame(self, padding=20)
        main_content_frame.place(relx=0, rely=0, relwidth=1, relheight=1)
        main_content_frame.columnconfigure(0, weight=1)
        main_content_frame.rowconfigure(1, weight=1)
        self.main_notebook = ttk.Notebook(main_content_frame) # (MODIFIED) Assign to self.main_notebook
        self.main_notebook.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        convert_tab = ttk.Frame(self.main_notebook, padding=15)
        self.main_notebook.add(convert_tab, text="Convert HF to GGUF")
        convert_tab.columnconfigure(1, weight=1)
        ttk.Label(convert_tab, text=self.loc.get('model_converter_source_label', fallback="Fine-Tuned Model Folder:")).grid(row=0, column=0, sticky="w", padx=5, pady=5)
        self.model_combo = ttk.Combobox(convert_tab, textvariable=self.source_model_var, state="readonly")
        self.model_combo.grid(row=0, column=1, sticky="ew", padx=5, pady=5)
        ttk.Label(convert_tab, text=self.loc.get('model_converter_output_label', fallback="New .gguf Filename (no extension):")).grid(row=1, column=0, sticky="w", padx=5, pady=5)
        self.output_entry = ttk.Entry(convert_tab, textvariable=self.output_name_var)
        self.output_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        requantize_tab = ttk.Frame(self.main_notebook, padding=15)
        self.main_notebook.add(requantize_tab, text="Re-Quantize Existing GGUF")
        requantize_tab.columnconfigure(1, weight=1)
        ttk.Label(requantize_tab, text="Source .gguf File:").grid(row=0, column=0, sticky="w", padx=5, pady=5) # English Hardcode
        source_gguf_frame = ttk.Frame(requantize_tab)
        source_gguf_frame.grid(row=0, column=1, sticky="ew", padx=5, pady=5)
        source_gguf_frame.columnconfigure(0, weight=1)
        self.source_gguf_entry = ttk.Entry(source_gguf_frame, textvariable=self.source_gguf_var)
        self.source_gguf_entry.pack(side="left", fill="x", expand=True)
        ttk.Button(source_gguf_frame, text="Browse...", command=self._browse_gguf_file).pack(side="left", padx=(5,0)) # English Hardcode
        ttk.Label(requantize_tab, text="New Quantized Filename (no extension):").grid(row=1, column=0, sticky="w", padx=5, pady=5) # English Hardcode
        self.requantize_output_entry = ttk.Entry(requantize_tab, textvariable=self.requantize_output_name_var)
        self.requantize_output_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        self._add_common_settings_to_tab(convert_tab, 2)
        self._add_common_settings_to_tab(requantize_tab, 2)
        monitor_frame = ttk.LabelFrame(main_content_frame, text=self.loc.get('model_converter_monitor_title', fallback="2. Conversion Monitor"), padding=15)
        monitor_frame.grid(row=1, column=0, sticky="nsew", pady=(10, 0))
        monitor_frame.rowconfigure(0, weight=1)
        monitor_frame.columnconfigure(0, weight=1)
        self.log_text = scrolledtext.ScrolledText(monitor_frame, wrap="word", state="disabled", height=15, font=("Consolas", 9))
        self.log_text.grid(row=0, column=0, sticky="nsew")
        self.start_button = ttk.Button(main_content_frame, text=self.loc.get('model_converter_start_btn', fallback="Start Conversion Job"), command=self._start_job, bootstyle="success")
        self.start_button.grid(row=2, column=0, sticky="ew", pady=(10, 0), ipady=5)
        guide_handle = ttk.Frame(self, width=15, bootstyle="secondary")
        guide_handle.place(relx=0, rely=0, relheight=1, anchor='nw')
        handle_label = ttk.Label(guide_handle, text=">", bootstyle="inverse-secondary", font=("Helvetica", 10, "bold"))
        handle_label.pack(expand=True)
        guide_handle.bind("<Enter>", self._show_guide_panel)
        self.guide_panel = ttk.Frame(self, bootstyle="secondary")
        control_bar = ttk.Frame(self.guide_panel, bootstyle="secondary")
        control_bar.pack(fill='x', padx=5, pady=2)
        self.guide_pin_button = ttk.Button(control_bar, text="📌", bootstyle="light-link", command=self._toggle_pin_guide)
        self.guide_pin_button.pack(side='right')
        guide_frame_inner = ttk.LabelFrame(self.guide_panel, text=self.loc.get('model_converter_guide_title'), padding=15)
        guide_frame_inner.pack(fill='both', expand=True, padx=5, pady=(0,5))
        guide_frame_inner.columnconfigure(0, weight=1)
        guide_frame_inner.rowconfigure(0, weight=1)
        self.guide_text = scrolledtext.ScrolledText(guide_frame_inner, wrap="word", height=10, state="disabled")
        self.guide_text.grid(row=0, column=0, sticky="nsew")
        self.guide_panel.bind("<Leave>", self._hide_guide_panel_later)
        self.guide_panel.bind("<Enter>", self._cancel_hide_guide)
        guide_handle.lift()
    def _add_common_settings_to_tab(self, parent_tab, start_row):
        ttk.Label(parent_tab, text=self.loc.get('model_converter_quant_label', fallback="Quantization Method:")).grid(row=start_row, column=0, sticky="w", padx=5, pady=5)
        quant_methods = ["Q2_K", "Q3_K_M", "Q4_0", "Q4_K_M", "Q5_0", "Q5_K_M", "Q6_K", "Q8_0", "F16", "F32"]
        self.quant_combo = ttk.Combobox(parent_tab, textvariable=self.quantize_method_var, values=quant_methods, state="readonly")
        self.quant_combo.grid(row=start_row, column=1, sticky="ew", padx=5, pady=5)
    def _browse_gguf_file(self):
        filepath = filedialog.askopenfilename(title="Select GGUF model file", filetypes=[("GGUF Model", "*.gguf")]) # English Hardcode
        if filepath:
            self.source_gguf_var.set(filepath)
            base_name = os.path.basename(filepath).replace(".gguf", "")
            self.requantize_output_name_var.set(f"{base_name}-quantized")
    def _load_initial_data(self):
        pass
    def _start_job(self):
        if not self.kernel.is_tier_sufficient(self.TIER):
            messagebox.showwarning(
                self.loc.get('license_popup_title'),
                self.loc.get('license_popup_message', module_name="Model Factory"),
                parent=self.winfo_toplevel()
            )
            return
        selected_tab_index = self.main_notebook.index("current") # (FIXED) Correctly get the index from the notebook widget instance.
        quant_method = self.quantize_method_var.get()
        if selected_tab_index == 0: # Convert Tab
            source_model = self.source_model_var.get()
            output_name = self.output_name_var.get().strip()
            if not source_model or not output_name:
                messagebox.showerror("Validation Error", "Source Model and Output Filename are required.", parent=self) # English Hardcode
                return
            self.start_button.config(state="disabled")
            self._log_message("Sending conversion job request to the server...") # English Hardcode
            threading.Thread(target=self._start_conversion_worker, args=(source_model, output_name, quant_method), daemon=True).start()
        elif selected_tab_index == 1: # Re-quantize Tab
            source_gguf = self.source_gguf_var.get()
            output_name = self.requantize_output_name_var.get().strip()
            if not source_gguf or not output_name:
                messagebox.showerror("Validation Error", "Source GGUF File and Output Filename are required.", parent=self) # English Hardcode
                return
            self.start_button.config(state="disabled")
            self._log_message("Sending re-quantization job request to the server...") # English Hardcode
            threading.Thread(target=self._start_requantize_worker, args=(source_gguf, output_name, quant_method), daemon=True).start()
    def _start_conversion_worker(self, source, output, method):
        success, response = self.api_client.start_model_conversion(source, output, method)
        self.after(0, self._on_job_started, success, response)
    def _start_requantize_worker(self, source, output, method):
        success, response = self.api_client.start_model_requantize(source, output, method)
        self.after(0, self._on_job_started, success, response)
    def _on_job_started(self, success, response):
        if success:
            self.job_id = response.get('job_id')
            self._log_message(f"Job successfully queued with ID: {self.job_id}") # English Hardcode
            self._start_polling()
        else:
            messagebox.showerror("Job Error", f"Failed to start job: {response}", parent=self) # English Hardcode
            self.start_button.config(state="normal")
    def _start_polling(self):
        if not self.is_polling:
            self.is_polling = True
            self._poll_job_status()
    def _poll_job_status(self):
        if not self.job_id:
            self.is_polling = False
            return
        threading.Thread(target=self._poll_worker, daemon=True).start()
    def _poll_worker(self):
        success, response = self.api_client.get_conversion_status(self.job_id)
        self.after(0, self._update_status_ui, success, response)
    def _update_status_ui(self, success, response):
        if success:
            status = response.get('status', 'UNKNOWN')
            full_log = response.get('log', [])
            self.log_text.config(state="normal")
            self.log_text.delete("1.0", "end")
            self.log_text.insert("1.0", f"Current Status: {status}\n--- LOG ---\n") # English Hardcode
            for line in full_log:
                self.log_text.insert("end", f"{line}\n")
            self.log_text.see("end")
            self.log_text.config(state="disabled")
            if status in ["COMPLETED", "FAILED"]:
                self.is_polling = False
                self.start_button.config(state="normal")
                messagebox.showinfo("Job Finished", f"Job {self.job_id} finished with status: {status}", parent=self) # English Hardcode
            else:
                self.after(5000, self._poll_job_status)
        else:
            self._log_message(f"Error polling status: {response}") # English Hardcode
            self.after(5000, self._poll_job_status)
    def _log_message(self, message):
        self.log_text.config(state="normal")
        self.log_text.insert("end", f"{time.strftime('%H:%M:%S')} - {message}\n")
        self.log_text.see("end")
        self.log_text.config(state="disabled")
    def _toggle_pin_guide(self):
        self.guide_is_pinned = not self.guide_is_pinned
        pin_char = "📌"
        self.guide_pin_button.config(text=pin_char)
        if not self.guide_is_pinned:
            self._hide_guide_panel_later()
    def _show_guide_panel(self, event=None):
        self._cancel_hide_guide()
        self.guide_panel.place(in_=self, relx=0, rely=0, relheight=1.0, anchor='nw', width=350)
        self.guide_panel.lift()
    def _hide_guide_panel_later(self, event=None):
        if not self.guide_is_pinned:
            self.hide_guide_job = self.after(300, lambda: self.guide_panel.place_forget())
    def _cancel_hide_guide(self, event=None):
        if self.hide_guide_job:
            self.after_cancel(self.hide_guide_job)
            self.hide_guide_job = None
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\pricing_page.py
# JUMLAH BARIS : 154
#######################################################################

```py
import ttkbootstrap as ttk
import webbrowser
import os
from dotenv import load_dotenv
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class PricingPage(ttk.Frame):
    """
    A UI frame that displays the different license tiers and their features,
    with dynamic buttons based on the user's current license.
    (MODIFIED) Redesigned with a more persuasive, benefit-driven, and cinematic narrative.
    """
    def __init__(self, parent_notebook, kernel_instance):
        self.api_client = ApiClient()
        super().__init__(parent_notebook, padding=20)
        self.kernel = kernel_instance
        self.loc = self.kernel.get_service("localization_manager")
        self.feature_groups = {
            "foundation": {
                "title_key": "feature_group_foundation",
                "features": ["feature_visual_editor", "feature_basic_modules", "feature_manual_install", "feature_theme_customization", "feature_limited_api"]
            },
            "connectivity": {
                "title_key": "feature_group_connectivity",
                "features": ["feature_unlimited_api", "feature_headless_mode"]
            },
            "powerhouse": {
                "title_key": "feature_group_powerhouse",
                "features": ["feature_time_travel_debugger", "feature_preset_versioning", "screen_recorder", "web_scraping_advanced"]
            },
            "intelligence": {
                "title_key": "feature_group_intelligence",
                "features": ["feature_ai_copilot", "ai:provider_access", "ai:local_models", "feature_marketplace_upload", "video_processing"]
            },
            "creator": {
                "title_key": "feature_group_creator",
                "features": ["feature_ai_architect", "core_compiler", "module_generator"]
            },
            "enterprise": {
                "title_key": "feature_group_enterprise",
                "features": ["feature_advanced_security", "feature_priority_support", "feature_team_collaboration"]
            }
        }
        self.tier_data = {
            "free": {
                "title_key": "tier_pemula_title", "tagline_key": "tier_pemula_tagline", "desc_key": "tier_pemula_desc_detail", "style": "secondary",
                "features": ["foundation"]
            },
            "basic": {
                "title_key": "tier_profesional_title", "tagline_key": "tier_profesional_tagline", "desc_key": "tier_profesional_desc_detail", "style": "info",
                "features": ["connectivity", "powerhouse"]
            },
            "pro": {
                "title_key": "tier_arsitek_ai_title", "tagline_key": "tier_arsitek_ai_tagline", "desc_key": "tier_arsitek_ai_desc_detail", "style": "success",
                "features": ["intelligence"]
            },
            "architect": {
                "title_key": "tier_maestro_title", "tagline_key": "tier_maestro_tagline", "desc_key": "tier_maestro_desc_detail", "style": "primary",
                "features": ["creator"]
            },
            "enterprise": {
                "title_key": "tier_titan_title", "tagline_key": "tier_titan_tagline", "desc_key": "tier_titan_desc_detail", "style": "dark",
                "features": ["enterprise"]
            }
        }
        self.base_upgrade_urls = {
            "basic": "https://www.flowork.art/harga/basic",
            "pro": "https://www.flowork.art/harga/pro",
            "architect": "https://www.flowork.art/harga/architect",
            "enterprise": "https://www.flowork.art/kontak"
        }
        self.affiliate_id = None
        affiliate_file_path = os.path.join(self.kernel.data_path, ".flowork_id")
        if os.path.exists(affiliate_file_path):
            load_dotenv(dotenv_path=affiliate_file_path)
            self.affiliate_id = os.getenv("ID_USER")
            if self.affiliate_id:
                self.kernel.write_to_log(f"Affiliate ID '{self.affiliate_id}' loaded successfully.", "SUCCESS")
        self._build_ui()
    def _build_ui(self):
        for widget in self.winfo_children():
            widget.destroy()
        container = ttk.Frame(self)
        container.pack(fill='both', expand=True)
        container.columnconfigure(0, weight=2)
        container.columnconfigure(1, weight=2)
        container.columnconfigure(2, weight=3)
        container.columnconfigure(3, weight=2)
        container.columnconfigure(4, weight=2)
        container.rowconfigure(0, weight=1)
        tier_order = ["free", "basic", "pro", "architect", "enterprise"]
        for i, tier_key in enumerate(tier_order):
            data = self.tier_data[tier_key]
            is_highlighted = (tier_key == "pro")
            self._create_tier_card(container, tier_key, data, is_highlighted).grid(row=0, column=i, sticky="nsew", padx=10, pady=10)
    def _create_tier_card(self, parent, tier_key, data, is_highlighted=False):
        style = f"{data['style']}"
        card = ttk.LabelFrame(parent, text=self.loc.get(data['title_key']), padding=20, bootstyle=style)
        if is_highlighted:
            banner = ttk.Label(card, text=self.loc.get('btn_most_popular', fallback="MOST POPULAR"), bootstyle=f"inverse-{data['style']}", padding=(10, 2), font="-weight bold")
            banner.place(relx=0.5, rely=0, anchor="n", y=-15)
        tagline_text = self.loc.get(data['tagline_key'])
        ttk.Label(card, text=tagline_text, font="-size 12 -weight bold", anchor="center").pack(fill='x', pady=(10, 5))
        desc_text = self.loc.get(data['desc_key'])
        ttk.Label(card, text=desc_text, wraplength=250, justify='center', anchor='center').pack(fill='x', pady=(0, 20))
        all_features_in_tier = set()
        tier_hierarchy_keys = list(self.kernel.TIER_HIERARCHY.keys())
        current_tier_index = tier_hierarchy_keys.index(tier_key)
        for i in range(current_tier_index + 1):
            tier_to_include = tier_hierarchy_keys[i]
            for group_key in self.tier_data[tier_to_include]['features']:
                all_features_in_tier.add(group_key)
        for group_key, group_data in self.feature_groups.items():
            if group_key in all_features_in_tier:
                ttk.Label(card, text=self.loc.get(group_data['title_key']), font="-weight bold", bootstyle="secondary").pack(anchor='w', pady=(10, 2))
                for feature_key in group_data['features']:
                    if feature_key == "feature_limited_api" and self.kernel.TIER_HIERARCHY[tier_key] >= self.kernel.TIER_HIERARCHY['basic']:
                        continue
                    if feature_key == "feature_unlimited_api" and self.kernel.TIER_HIERARCHY[tier_key] < self.kernel.TIER_HIERARCHY['basic']:
                        continue
                    feature_text = self.loc.get(feature_key, fallback=feature_key.replace('_', ' ').title())
                    ttk.Label(card, text=f"✓ {feature_text}", anchor='w').pack(fill='x', padx=10)
        ttk.Frame(card).pack(fill='y', expand=True) # Spacer
        user_tier_level = self.kernel.TIER_HIERARCHY[self.kernel.license_tier]
        card_tier_level = self.kernel.TIER_HIERARCHY[tier_key]
        btn_command = None
        if user_tier_level == card_tier_level:
            btn_text = self.loc.get('btn_current_plan')
            btn_state = "disabled"
            btn_bootstyle = f"outline-{data['style']}"
        elif user_tier_level > card_tier_level:
            btn_text = self.loc.get('btn_included')
            btn_state = "disabled"
            btn_bootstyle = f"outline-{data['style']}"
        else:
            base_url = self.base_upgrade_urls.get(tier_key, "https://www.flowork.art")
            final_url = f"{base_url}?aff={self.affiliate_id}" if self.affiliate_id else base_url
            btn_command = lambda url=final_url: webbrowser.open(url)
            if tier_key == "enterprise":
                btn_text = self.loc.get('btn_contact_us')
            else:
                btn_text = self.loc.get(f'btn_upgrade_{tier_key}', fallback=f"Upgrade to {tier_key.capitalize()}")
            btn_state = "normal"
            btn_bootstyle = data['style']
        action_button = ttk.Button(card, text=btn_text, state=btn_state, command=btn_command, bootstyle=btn_bootstyle)
        action_button.pack(fill='x', ipady=8, pady=(15, 0))
        return card
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\prompt_manager_page.py
# JUMLAH BARIS : 166
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import messagebox, scrolledtext, StringVar, Toplevel
import re
from api_client.client import ApiClient
class PromptManagerPage(ttk.Frame):
    def __init__(self, parent, api_client, loc_service, tab_id=None, is_new_tab=False, **kwargs): # PENAMBAHAN: Menangkap argumen custom
        kwargs.pop('tab_id', None)
        kwargs.pop('is_new_tab', None)
        super().__init__(parent, **kwargs)
        self.loc = loc_service
        self.api_client = api_client
        self.current_prompt_id = None
        self.guide_is_pinned = False
        self.hide_guide_job = None
        self.columnconfigure(1, weight=1)
        self.rowconfigure(0, weight=1)
        left_pane = ttk.Frame(self, padding=10)
        left_pane.grid(row=0, column=0, sticky="ns", padx=(0, 5))
        left_pane.rowconfigure(1, weight=1)
        list_toolbar = ttk.Frame(left_pane)
        list_toolbar.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        new_button = ttk.Button(list_toolbar, text=self.loc.get("button_new", fallback="New"), command=self._new_prompt)
        new_button.pack(side="left")
        delete_button = ttk.Button(list_toolbar, text=self.loc.get("button_delete", fallback="Delete"), command=self._delete_prompt, bootstyle="danger")
        delete_button.pack(side="left", padx=5)
        self.prompt_tree = ttk.Treeview(left_pane, columns=("name",), show="tree", selectmode="browse")
        self.prompt_tree.grid(row=1, column=0, sticky="ns")
        self.prompt_tree.bind("<<TreeviewSelect>>", self._on_prompt_select)
        self.right_pane = ttk.Frame(self, padding=10)
        self.right_pane.grid(row=0, column=1, sticky="nsew")
        self.right_pane.columnconfigure(0, weight=1)
        self.right_pane.rowconfigure(0, weight=1) # MODIFIKASI: Editor sekarang di row 0
        editor_frame = ttk.LabelFrame(self.right_pane, text=self.loc.get("prompt_manager_editor_title", fallback="Prompt Editor"))
        editor_frame.grid(row=0, column=0, sticky="nsew") # MODIFIKASI: Editor sekarang di row 0
        editor_frame.columnconfigure(0, weight=1)
        editor_frame.rowconfigure(3, weight=1)
        self.name_var = StringVar()
        ttk.Label(editor_frame, text=self.loc.get("prompt_manager_name_label", fallback="Template Name:")).grid(row=0, column=0, sticky="w", padx=10, pady=(10,2))
        ttk.Entry(editor_frame, textvariable=self.name_var).grid(row=1, column=0, sticky="ew", padx=10, pady=(0,10))
        ttk.Label(editor_frame, text=self.loc.get("prompt_manager_content_label", fallback="Template Content:")).grid(row=2, column=0, sticky="nw", padx=10, pady=(0,2))
        self.content_text = scrolledtext.ScrolledText(editor_frame, wrap="word", height=15, font=("Consolas", 10))
        self.content_text.grid(row=3, column=0, sticky="nsew", padx=10, pady=(0,10))
        save_button = ttk.Button(self.right_pane, text=self.loc.get("button_save_changes", fallback="Save Changes"), command=self._save_prompt, bootstyle="success")
        save_button.grid(row=1, column=0, sticky="e", pady=10) # MODIFIKASI: Save button sekarang di row 1
        self._build_guide_panel()
        self._load_prompt_list()
        self._populate_tutorial()
    def _build_guide_panel(self):
        guide_handle = ttk.Frame(self.right_pane, width=15, bootstyle="secondary")
        guide_handle.place(relx=0, rely=0, relheight=1, anchor='nw')
        handle_label = ttk.Label(guide_handle, text=">", bootstyle="inverse-secondary", font=("Helvetica", 10, "bold"))
        handle_label.pack(expand=True)
        guide_handle.bind("<Enter>", self._show_guide_panel)
        guide_handle.lift()
        self.guide_panel = ttk.Frame(self.right_pane, bootstyle="secondary")
        control_bar = ttk.Frame(self.guide_panel, bootstyle="secondary")
        control_bar.pack(fill='x', padx=5, pady=2)
        self.guide_pin_button = ttk.Button(control_bar, text="📌", bootstyle="light-link", command=self._toggle_pin_guide)
        self.guide_pin_button.pack(side='right')
        tutorial_frame = ttk.LabelFrame(self.guide_panel, text=self.loc.get("prompt_manager_tutorial_title", fallback="Guide & How-To"))
        tutorial_frame.pack(fill='both', expand=True, padx=5, pady=(0,5))
        tutorial_frame.columnconfigure(0, weight=1)
        tutorial_frame.rowconfigure(0, weight=1)
        self.tutorial_text = scrolledtext.ScrolledText(tutorial_frame, wrap="word", height=10, state="disabled", font="-size 9")
        self.tutorial_text.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        self.tutorial_text.tag_configure("bold", font="-size 9 -weight bold")
        self.guide_panel.bind("<Leave>", self._hide_guide_panel_later)
        self.guide_panel.bind("<Enter>", self._cancel_hide_guide)
    def _populate_tutorial(self):
        tutorial_content = self.loc.get("prompt_manager_tutorial_content")
        self._apply_markdown_to_text_widget(self.tutorial_text, tutorial_content)
    def _apply_markdown_to_text_widget(self, text_widget, content):
        text_widget.config(state="normal")
        text_widget.delete("1.0", "end")
        parts = re.split(r'(\*\*.*?\*\*)', content)
        for part in parts:
            if part.startswith('**') and part.endswith('**'):
                text_widget.insert("end", part[2:-2], "bold")
            else:
                text_widget.insert("end", part)
        text_widget.config(state="disabled")
    def _load_prompt_list(self):
        for i in self.prompt_tree.get_children():
            self.prompt_tree.delete(i)
        success, data = self.api_client.get_prompts()
        if success:
            if isinstance(data, list):
                for prompt in data:
                    self.prompt_tree.insert("", "end", iid=prompt['id'], text=prompt['name'])
            else:
                self.prompt_tree.insert("", "end", text="Error: Invalid data format from API.")
        else:
            self.prompt_tree.insert("", "end", text="Error loading prompts...")
    def _on_prompt_select(self, event):
        selected_items = self.prompt_tree.selection()
        if not selected_items:
            return
        self.current_prompt_id = selected_items[0]
        success, data = self.api_client.get_prompt(self.current_prompt_id)
        if success:
            self.name_var.set(data.get('name', ''))
            self.content_text.delete("1.0", "end")
            self.content_text.insert("1.0", data.get('content', ''))
        else:
            error_message = data if isinstance(data, str) else data.get('error', 'Unknown error')
            messagebox.showerror("Error", f"Could not load prompt details: {error_message}", parent=self)
    def _new_prompt(self):
        self.current_prompt_id = None
        self.name_var.set("")
        self.content_text.delete("1.0", "end")
        self.prompt_tree.selection_set("")
    def _save_prompt(self):
        name = self.name_var.get().strip()
        content = self.content_text.get("1.0", "end-1c").strip()
        if not name or not content:
            messagebox.showwarning("Input Required", "Template Name and Content cannot be empty.", parent=self)
            return
        prompt_data = {"name": name, "content": content}
        if self.current_prompt_id:
            success, response = self.api_client.update_prompt(self.current_prompt_id, prompt_data)
        else:
            success, response = self.api_client.create_prompt(prompt_data)
        if success:
            messagebox.showinfo("Success", "Prompt template saved successfully.", parent=self)
            self._load_prompt_list()
        else:
            error_message = response if isinstance(response, str) else response.get('error', 'Unknown error')
            messagebox.showerror("Error", f"Failed to save prompt: {error_message}", parent=self)
    def _delete_prompt(self):
        if not self.current_prompt_id:
            messagebox.showwarning("Selection Required", "Please select a template to delete.", parent=self)
            return
        if messagebox.askyesno("Confirm Deletion", "Are you sure you want to delete this prompt template?", parent=self):
            success, response = self.api_client.delete_prompt(self.current_prompt_id)
            if success:
                messagebox.showinfo("Success", "Prompt template deleted.", parent=self)
                self._new_prompt()
                self._load_prompt_list()
            else:
                error_message = response if isinstance(response, str) else response.get('error', 'Unknown error')
                messagebox.showerror("Error", f"Failed to delete prompt: {error_message}", parent=self)
    def _toggle_pin_guide(self):
        self.guide_is_pinned = not self.guide_is_pinned
        pin_char = "📌"
        self.guide_pin_button.config(text=pin_char)
        if not self.guide_is_pinned:
            self._hide_guide_panel_later()
    def _show_guide_panel(self, event=None):
        self._cancel_hide_guide()
        self.guide_panel.place(in_=self.right_pane, relx=0, rely=0, relheight=1.0, anchor='nw', width=350)
        self.guide_panel.lift()
    def _hide_guide_panel_later(self, event=None):
        if not self.guide_is_pinned:
            self.hide_guide_job = self.after(300, lambda: self.guide_panel.place_forget())
    def _cancel_hide_guide(self, event=None):
        if self.hide_guide_job:
            self.after_cancel(self.hide_guide_job)
            self.hide_guide_job = None
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\settings_tab.py
# JUMLAH BARIS : 139
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import messagebox
from .settings_components.general_settings_frame import GeneralSettingsFrame
from .settings_components.webhook_settings_frame import WebhookSettingsFrame
from .settings_components.notification_settings_frame import NotificationSettingsFrame
from .settings_components.license_management_frame import LicenseManagementFrame
from .settings_components.error_handler_frame import ErrorHandlerFrame
from .settings_components.variable_manager_frame import VariableManagerFrame
from .settings_components.ai_provider_settings_frame import AiProviderSettingsFrame
from .settings_components.recorder_settings_frame import RecorderSettingsFrame
import threading
from flowork_gui.views.custom_widgets.scrolled_frame import ScrolledFrame
from flowork_gui.exceptions import PermissionDeniedError # PENAMBAHAN: Importing exceptions from the new local GUI file.
from flowork_gui.api_client.client import ApiClient
class SettingsTab(ttk.Frame):
    """
    Acts as a container and coordinator for all the individual settings frames.
    [REFACTORED] Now fetches all settings from the API and orchestrates saving.
    """
    def __init__(self, parent_notebook, api_client, loc_service, **kwargs):
        super().__init__(parent_notebook, padding=15)
        self.loc = loc_service
        self.api_client = api_client
        class MockKernel:
            def __init__(self, api_client_instance, loc_instance):
                self.api_client = api_client_instance
                self.loc = loc_instance
                self.services = {'localization_manager': self.loc}
                self.write_to_log = lambda msg, lvl="INFO": print(f"[INFO] (from MockKernel in SettingsTab): {msg}")
            def get_service(self, service_name):
                if service_name not in self.services:
                    class MockService:
                        def __init__(self, api_client):
                            self.api_client = api_client
                    self.services[service_name] = MockService(self.api_client)
                return self.services.get(service_name)
        self.kernel = MockKernel(self.api_client, self.loc)
        self.all_settings_frames = []
        self._content_initialized = False
        ttk.Label(self, text="Loading Settings...").pack(expand=True) # English Hardcode
    def _initialize_content(self):
        if self._content_initialized:
            return
        for widget in self.winfo_children():
            widget.destroy()
        self._build_ui()
        self._load_all_settings_from_api()
        self._content_initialized = True
    def refresh_content(self):
        """Refreshes the content and state of all child setting frames."""
        self.kernel.write_to_log("SettingsTab: Refreshing content.", "DEBUG")
        for frame in self.all_settings_frames:
            if hasattr(frame, 'refresh_content'):
                frame.refresh_content()
        if hasattr(self, 'variable_manager_frame'):
            self.variable_manager_frame.load_variables_to_ui()
    def _build_ui(self):
        paned_window = ttk.PanedWindow(self, orient='horizontal')
        paned_window.pack(fill='both', expand=True)
        left_scrolled_frame = ScrolledFrame(paned_window)
        paned_window.add(left_scrolled_frame, weight=1)
        right_frame = ttk.Frame(paned_window, padding=5)
        paned_window.add(right_frame, weight=1)
        self._build_left_panel(left_scrolled_frame.scrollable_frame)
        self._build_right_panel(right_frame)
    def _build_left_panel(self, parent_frame):
        self.general_frame = GeneralSettingsFrame(parent_frame, self.kernel)
        self.general_frame.pack(fill="x", pady=5, padx=5)
        self.all_settings_frames.append(self.general_frame)
        self.ai_provider_frame = AiProviderSettingsFrame(parent_frame, self.kernel)
        self.ai_provider_frame.pack(fill="x", pady=5, padx=5)
        self.all_settings_frames.append(self.ai_provider_frame)
        self.recorder_frame = RecorderSettingsFrame(parent_frame, self.kernel)
        self.recorder_frame.pack(fill="x", pady=5, padx=5)
        self.all_settings_frames.append(self.recorder_frame)
        self.webhook_frame = WebhookSettingsFrame(parent_frame, self.kernel)
        self.webhook_frame.pack(fill="x", pady=5, padx=5)
        self.all_settings_frames.append(self.webhook_frame)
        self.notification_frame = NotificationSettingsFrame(parent_frame, self.kernel)
        self.notification_frame.pack(fill="x", pady=5, padx=5)
        self.all_settings_frames.append(self.notification_frame)
        self.license_frame = LicenseManagementFrame(parent_frame, self.kernel)
        self.all_settings_frames.append(self.license_frame)
        self.license_frame.pack(fill="x", pady=5, padx=5)
        self.error_handler_frame = ErrorHandlerFrame(parent_frame, self.kernel)
        self.error_handler_frame.pack(fill="x", pady=5, padx=5, expand=True, anchor="n")
        self.all_settings_frames.append(self.error_handler_frame)
        save_button = ttk.Button(parent_frame, text=self.loc.get("settings_save_button", fallback="Save All Settings"), command=self._save_all_settings, bootstyle="success")
        save_button.pack(pady=10, padx=5, side="bottom", anchor="e")
    def _build_right_panel(self, parent_frame):
        self.variable_manager_frame = VariableManagerFrame(parent_frame, self.kernel)
        self.variable_manager_frame.pack(fill="both", expand=True, pady=5, padx=5)
    def _load_all_settings_from_api(self):
        threading.Thread(target=self._load_settings_worker, daemon=True).start()
    def _load_settings_worker(self):
        success, settings_data = self.api_client.get_all_settings()
        self.after(0, self._populate_settings_ui, success, settings_data)
    def _populate_settings_ui(self, success, settings_data):
        if success:
            for frame in self.all_settings_frames:
                try:
                    if hasattr(frame, 'load_settings_data'):
                        frame.load_settings_data(settings_data)
                except PermissionDeniedError:
                    self.kernel.write_to_log(f"Hiding settings frame '{frame.__class__.__name__}' due to insufficient permissions.", "WARN")
                    frame.pack_forget()
                except Exception as e:
                    self.kernel.write_to_log(f"Error loading settings for frame '{frame.__class__.__name__}': {e}", "ERROR")
                    frame.pack_forget()
        else:
            messagebox.showerror(self.loc.get("messagebox_error_title"), f"Failed to load settings from API: {settings_data}")
    def _save_all_settings(self):
        all_new_settings = {}
        try:
            for frame in self.all_settings_frames:
                if frame.winfo_ismapped() and hasattr(frame, 'get_settings_data'):
                    all_new_settings.update(frame.get_settings_data())
            threading.Thread(target=self._save_settings_worker, args=(all_new_settings,), daemon=True).start()
        except ValueError as e:
            messagebox.showerror(self.loc.get("messagebox_error_title"), str(e))
        except Exception as e:
            messagebox.showerror(self.loc.get("messagebox_error_title"), f"{self.loc.get('settings_save_error_msg')}: {e}")
    def _save_settings_worker(self, settings_to_save):
        success, response = self.api_client.save_settings(settings_to_save)
        self.after(0, self._on_save_settings_complete, success, response)
    def _on_save_settings_complete(self, success, response):
        if success:
            messagebox.showinfo(self.loc.get("messagebox_success_title"), self.loc.get("settings_save_success_msg"))
            self._load_all_settings_from_api()
        else:
             messagebox.showerror(self.loc.get("messagebox_error_title"), f"API Error: {response}")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\template_manager_page.py
# JUMLAH BARIS : 231
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import ttk as tk_ttk, messagebox, filedialog, scrolledtext
import os
import shutil
import json
import platform
import subprocess
import re
from flowork_gui.views.custom_widgets.tooltip import ToolTip # PENAMBAHAN: Importing from the new local GUI path.
from flowork_gui.api_client.client import ApiClient
class TemplateManagerPage(ttk.Frame):
    def __init__(self, parent_notebook, api_client, loc_service, **kwargs):
        super().__init__(parent_notebook, style='TFrame', padding=0)
        self.loc = loc_service
        self.api_client = api_client
        class MockKernel:
            def __init__(self, api_client_instance, loc_instance):
                self.api_client = api_client_instance
                self.loc = loc_instance
                self.services = {'localization_manager': self.loc}
                self.write_to_log = lambda msg, lvl="INFO": print(f"[INFO] (from MockKernel in TemplateManagerPage): {msg}")
                self.themes_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "..", "themes")
                self.root = parent_notebook.winfo_toplevel()
            def get_service(self, service_name):
                if service_name not in self.services:
                    class MockService:
                        def __init__(self, api_client, kernel):
                            self.api_client = api_client
                            self.kernel = kernel
                        def get_all_themes(self):
                            themes = {}
                            try:
                                for filename in os.listdir(self.kernel.themes_path):
                                    if filename.endswith(".json"):
                                        theme_id = os.path.splitext(filename)[0]
                                        filepath = os.path.join(self.kernel.themes_path, filename)
                                        with open(filepath, 'r', encoding='utf-8') as f:
                                            themes[theme_id] = json.load(f)
                                            themes[theme_id]['path'] = filepath
                            except Exception as e:
                                print(f"[ERROR] Mock get_all_themes failed: {e}")
                            return themes
                        def get_colors(self):
                            return {'bg': '#222', 'fg': '#fff', 'border': '#444'}
                    self.services[service_name] = MockService(self.api_client, self)
                return self.services.get(service_name)
        self.kernel = MockKernel(self.api_client, self.loc)
        self.guide_is_pinned = False
        self.hide_guide_job = None
        self.create_widgets()
        theme_manager = self.kernel.get_service("theme_manager")
        if theme_manager:
            self.apply_styles(theme_manager.get_colors())
        self.populate_template_list()
        self._populate_guide()
    def apply_styles(self, colors):
        style = tk_ttk.Style(self)
        style.configure('TFrame', background=colors.get('bg'))
        style.configure('TLabel', background=colors.get('bg'), foreground=colors.get('fg'))
        style.configure('TLabelframe', background=colors.get('bg'), borderwidth=1, relief='solid', bordercolor=colors.get('border'))
        style.configure('TLabelframe.Label', background=colors.get('bg'), foreground=colors.get('fg'), font=('Helvetica', 10, 'bold'))
    def _apply_markdown_to_text_widget(self, text_widget, content):
        text_widget.config(state="normal")
        text_widget.delete("1.0", "end")
        parts = re.split(r'(\*\*.*?\*\*)', content)
        for part in parts:
            if part.startswith('**') and part.endswith('**'):
                text_widget.insert("end", part[2:-2], "bold")
            else:
                text_widget.insert("end", part)
        text_widget.config(state="disabled")
    def _populate_guide(self):
        guide_content = self.loc.get("theme_manager_guide_content")
        self._apply_markdown_to_text_widget(self.guide_text, guide_content)
        self.guide_text.tag_configure("bold", font="-size 9 -weight bold")
    def create_widgets(self):
        main_content_frame = ttk.Frame(self, padding=20, style='TFrame')
        main_content_frame.place(relx=0, rely=0, relwidth=1, relheight=1)
        theme_frame = ttk.LabelFrame(main_content_frame, text=self.loc.get('theme_management_title'), padding=15, style='TLabelframe')
        theme_frame.pack(fill="both", expand=True, pady=(0, 20))
        upload_theme_button = ttk.Button(theme_frame, text=self.loc.get('upload_theme_button'), command=self.upload_theme, style="info.TButton")
        upload_theme_button.pack(fill='x', pady=5)
        self.theme_list_frame = ttk.Frame(theme_frame, style='TFrame')
        self.theme_list_frame.pack(fill='both', expand=True, pady=(10,0))
        guide_handle = ttk.Frame(self, width=15, bootstyle="secondary")
        guide_handle.place(relx=0, rely=0, relheight=1, anchor='nw')
        handle_label = ttk.Label(guide_handle, text=">", bootstyle="inverse-secondary", font=("Helvetica", 10, "bold"))
        handle_label.pack(expand=True)
        guide_handle.bind("<Enter>", self._show_guide_panel)
        self.guide_panel = ttk.Frame(self, bootstyle="secondary")
        control_bar = ttk.Frame(self.guide_panel, bootstyle="secondary")
        control_bar.pack(fill='x', padx=5, pady=2)
        self.guide_pin_button = ttk.Button(control_bar, text="📌", bootstyle="light-link", command=self._toggle_pin_guide)
        self.guide_pin_button.pack(side='right')
        guide_frame_inner = ttk.LabelFrame(self.guide_panel, text=self.loc.get('theme_manager_guide_title'), padding=15)
        guide_frame_inner.pack(fill='both', expand=True, padx=5, pady=(0,5))
        guide_frame_inner.columnconfigure(0, weight=1)
        guide_frame_inner.rowconfigure(0, weight=1)
        self.guide_text = scrolledtext.ScrolledText(guide_frame_inner, wrap="word", height=10, state="disabled", font="-size 9")
        self.guide_text.grid(row=0, column=0, sticky="nsew")
        self.guide_panel.bind("<Leave>", self._hide_guide_panel_later)
        self.guide_panel.bind("<Enter>", self._cancel_hide_guide)
        guide_handle.lift()
    def populate_template_list(self):
        self.kernel.write_to_log(self.loc.get('log_populating_theme_list', fallback="DEBUG: Populating theme list..."), "DEBUG")
        for widget in self.theme_list_frame.winfo_children():
            widget.destroy()
        theme_manager = self.kernel.get_service("theme_manager")
        themes = theme_manager.get_all_themes() if theme_manager else {}
        if not themes:
            ttk.Label(self.theme_list_frame, text=self.loc.get('no_themes_installed_message'), style='TLabel').pack()
            self.kernel.write_to_log(self.loc.get('log_no_themes_found', fallback="INFO: No custom themes were found."), "INFO")
            return
        sorted_themes = sorted(themes.items(), key=lambda item: item[1].get('name', item[0]).lower())
        for theme_id, theme_data in sorted_themes:
            theme_name = theme_data.get('name', theme_id)
            item_frame = ttk.Frame(self.theme_list_frame, style='TFrame')
            item_frame.pack(fill='x', pady=2)
            label_text = self.loc.get('theme_list_item_format', name=theme_name, id=theme_id)
            ttk.Label(item_frame, text=label_text, style='TLabel').pack(side='left', anchor='w', fill='x', expand=True)
            buttons_frame = ttk.Frame(item_frame, style='TFrame')
            buttons_frame.pack(side='right')
            is_removable = (theme_id != "flowork_default")
            if is_removable:
                uninstall_button = ttk.Button(buttons_frame, text=self.loc.get('uninstall_button'), style="link", width=2, command=lambda tid=theme_id, tname=theme_name: self.uninstall_theme(tid, tname))
                ToolTip(uninstall_button).update_text(self.loc.get('tooltip_delete_theme'))
                uninstall_button.pack(side='right', padx=(5,0))
            edit_button = ttk.Button(buttons_frame, text=self.loc.get('edit_button'), style="info-link", width=2, command=lambda tid=theme_id: self.edit_theme(tid))
            ToolTip(edit_button).update_text(self.loc.get('tooltip_edit_theme'))
            edit_button.pack(side='right', padx=(5,0))
            self.kernel.write_to_log(self.loc.get('log_theme_added_to_list', name=theme_name, id=theme_id), "DEBUG")
        self.kernel.write_to_log(self.loc.get('log_theme_list_populated_success'), "INFO")
    def _open_path_in_explorer(self, path):
        try:
            if platform.system() == "Windows":
                os.startfile(path)
            elif platform.system() == "Darwin":
                subprocess.Popen(["open", path])
            else:
                subprocess.Popen(["xdg-open", path])
            self.kernel.write_to_log(self.loc.get('log_opening_folder', path=path), "INFO")
        except Exception as e:
            error_msg = self.loc.get('log_failed_to_open_folder', path=path, error=str(e))
            self.kernel.write_to_log(error_msg, "ERROR")
            messagebox.showerror(self.loc.get('error_title'), error_msg)
    def edit_theme(self, theme_id):
        theme_manager = self.kernel.get_service("theme_manager")
        if not theme_manager: return
        all_themes = theme_manager.get_all_themes()
        theme_data = all_themes.get(theme_id)
        if theme_data and 'path' in theme_data:
            self._open_path_in_explorer(theme_data['path'])
        else:
            messagebox.showerror(self.loc.get('error_title'), self.loc.get('theme_not_found_error', name=theme_id))
    def uninstall_theme(self, theme_id, theme_name):
        self.kernel.write_to_log(self.loc.get('log_uninstall_theme_attempt', name=theme_name, id=theme_id), "INFO")
        theme_manager = self.kernel.get_service("theme_manager")
        if not theme_manager: return
        all_themes = theme_manager.get_all_themes()
        theme_data = all_themes.get(theme_id)
        if not theme_data:
            messagebox.showerror(self.loc.get('error_title'), self.loc.get('theme_not_found_error', name=theme_name))
            self.kernel.write_to_log(self.loc.get('log_theme_not_found_for_uninstall', fallback="ERROR: Theme '{name}' ({id}) not found for uninstall.", name=theme_name, id=theme_id), "ERROR")
            return
        theme_path_to_delete = theme_data['path']
        if messagebox.askyesno(self.loc.get('confirm_delete_title'), self.loc.get('confirm_delete_theme_message', name=theme_name)):
            try:
                os.remove(theme_path_to_delete)
                self.kernel.write_to_log(self.loc.get('log_theme_deleted_success', name=theme_name), "SUCCESS")
                messagebox.showinfo(self.loc.get('success_title'), self.loc.get('theme_deleted_success_message', name=theme_name))
                self.populate_template_list()
                self.kernel.root.refresh_ui_components()
            except Exception as e:
                error_msg = self.loc.get('theme_delete_failed_error', name=theme_name, error=e)
                self.kernel.write_to_log(error_msg, "ERROR")
                messagebox.showerror(self.loc.get('failed_title'), error_msg)
        else:
            self.kernel.write_to_log(self.loc.get('log_theme_uninstall_cancelled', name=theme_name), "INFO")
    def upload_theme(self):
        self.kernel.write_to_log(self.loc.get('log_upload_theme_started'), "INFO")
        filepath = filedialog.askopenfilename(
            title=self.loc.get('select_theme_file_title'),
            filetypes=[(self.loc.get('json_files_label'), "*.json")]
        )
        if not filepath:
            self.kernel.write_to_log(self.loc.get('theme_upload_cancelled'), "WARN")
            return
        theme_manager = self.kernel.get_service("theme_manager")
        if not theme_manager: return
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                theme_data = json.load(f)
                if "name" not in theme_data or "colors" not in theme_data:
                    raise ValueError(self.loc.get('invalid_theme_format_error'))
            theme_filename = os.path.basename(filepath)
            target_path = os.path.join(self.kernel.themes_path, theme_filename)
            shutil.copyfile(filepath, target_path)
            success_msg = self.loc.get('theme_upload_success', name=theme_data['name'])
            messagebox.showinfo(self.loc.get('success_title'), success_msg)
            self.populate_template_list()
            self.kernel.root.refresh_ui_components()
        except Exception as e:
            error_msg_detail = str(e)
            error_msg_localized = self.loc.get('theme_upload_failed_error', filename=os.path.basename(filepath), error=error_msg_detail)
            self.kernel.write_to_log(error_msg_localized, "ERROR")
            messagebox.showerror(self.loc.get('theme_upload_failed_title'), error_msg_localized)
    def _toggle_pin_guide(self):
        self.guide_is_pinned = not self.guide_is_pinned
        pin_char = "📌"
        self.guide_pin_button.config(text=pin_char)
        if not self.guide_is_pinned:
            self._hide_guide_panel_later()
    def _show_guide_panel(self, event=None):
        self._cancel_hide_guide()
        self.guide_panel.place(in_=self, relx=0, rely=0, relheight=1.0, anchor='nw', width=350)
        self.guide_panel.lift()
    def _hide_guide_panel_later(self, event=None):
        if not self.guide_is_pinned:
            self.hide_guide_job = self.after(300, lambda: self.guide_panel.place_forget())
    def _cancel_hide_guide(self, event=None):
        if self.hide_guide_job:
            self.after_cancel(self.hide_guide_job)
            self.hide_guide_job = None
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "e87a3f914667c0e64e7c7c3c61dcd9044b18dba40d0c036feaa7a03d8e6dffd3",
    "manifest_hash": "136667227cb826358dacc2b2573665a0cfd98b57204393f64712b0fcdd60ad6b",
    "timestamp": 1757204690.2918966
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\trigger_manager_page.py
# JUMLAH BARIS : 353
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import messagebox, Toplevel, scrolledtext
import uuid
from datetime import datetime, timezone
import threading
import re
from api_client.client import ApiClient # PENAMBAHAN: Alamat yang benar
class TriggerManagerPage(ttk.Frame):
    """
    [REFACTORED V5] Complete UI overhaul for trigger management.
    Features a three-pane layout: a trigger toolbox, a details panel
    with localized descriptions and tutorials, and the active rules area.
    [FIXED] Text color in details panel now respects the current theme.
    """
    def __init__(self, parent, api_client, loc_service, tab_id=None, is_new_tab=False, **kwargs): # PENAMBAHAN: Konstruktor baru
        kwargs.pop('tab_id', None)
        kwargs.pop('is_new_tab', None)
        super().__init__(parent, **kwargs)
        self.loc = loc_service
        self.api_client = api_client
        class MockKernel:
            def __init__(self, api_client_instance, loc_instance):
                self.api_client = api_client_instance
                self.loc = loc_instance
                self.services = {"localization_manager": self.loc, "event_bus": self}
            def get_service(self, service_name): return self.services.get(service_name)
            def write_to_log(self, msg, lvl="INFO"): print(f"[{lvl}] (from MockKernel in TriggerManagerPage): {msg}")
            def subscribe(self, e, i, c): pass
        self.kernel = MockKernel(self.api_client, self.loc)
        self.countdown_updater_id = None
        self.countdown_jobs = {}
        self._drag_data = {}
        self.trigger_definitions = {}
        self.right_pane = None
        self._build_ui_v3()
        self._load_initial_data()
        self._start_countdown_updater()
        event_bus = self.kernel.get_service("event_bus")
        if event_bus:
            subscriber_id = f"trigger_manager_page_{id(self)}"
            event_bus.subscribe("CRON_JOB_EXECUTED", subscriber_id, self._on_cron_job_executed)
            self.kernel.write_to_log(f"TriggerManagerPage is now listening for cron job executions.", "DEBUG") # English Log
    def _build_ui_v3(self):
        """Builds the new three-pane, drag-and-drop UI with details panel."""
        main_pane = ttk.PanedWindow(self, orient='horizontal')
        main_pane.pack(fill='both', expand=True, padx=15, pady=15)
        left_pane_container = ttk.Frame(main_pane)
        main_pane.add(left_pane_container, weight=1)
        left_vertical_pane = ttk.PanedWindow(left_pane_container, orient='vertical')
        left_vertical_pane.pack(fill='both', expand=True)
        toolbox_frame = ttk.LabelFrame(left_vertical_pane, text="Available Triggers", padding=10)
        left_vertical_pane.add(toolbox_frame, weight=1)
        self.trigger_toolbox_tree = ttk.Treeview(toolbox_frame, show="tree", selectmode="browse")
        self.trigger_toolbox_tree.pack(expand=True, fill='both')
        self.trigger_toolbox_tree.bind("<ButtonPress-1>", self._on_drag_start)
        self.trigger_toolbox_tree.bind("<B1-Motion>", self._on_drag_motion)
        self.trigger_toolbox_tree.bind("<ButtonRelease-1>", self._on_drag_release)
        self.trigger_toolbox_tree.bind("<<TreeviewSelect>>", self._on_toolbox_select)
        details_frame = ttk.LabelFrame(left_vertical_pane, text="Trigger Details", padding=10)
        left_vertical_pane.add(details_frame, weight=2)
        details_frame.columnconfigure(0, weight=1)
        details_frame.rowconfigure(2, weight=1)
        theme_manager = self.kernel.get_service("theme_manager")
        colors = theme_manager.get_colors() if theme_manager else {}
        fg_color = colors.get('fg', 'white')
        bg_color = colors.get('bg', '#222222')
        text_bg_color = colors.get('dark', '#333333')
        self.detail_title = ttk.Label(details_frame, text="Select a trigger to see details", font="-weight bold", wraplength=250)
        self.detail_title.grid(row=0, column=0, sticky="ew", pady=(0, 5))
        self.detail_desc = ttk.Label(details_frame, text="", wraplength=280, justify="left", foreground=fg_color, background=bg_color)
        self.detail_desc.grid(row=1, column=0, sticky="nsew", pady=(0,10))
        self.detail_usage = scrolledtext.ScrolledText(
            details_frame,
            wrap="word",
            height=8,
            state="disabled",
            font="-size 9",
            background=text_bg_color,
            foreground=fg_color,
            borderwidth=0,
            highlightthickness=0,
            insertbackground=fg_color
        )
        self.detail_usage.grid(row=2, column=0, sticky="nsew")
        self.detail_usage.tag_configure("bold", font="-size 9 -weight bold")
        self.right_pane = ttk.Frame(main_pane, padding=10)
        main_pane.add(self.right_pane, weight=3)
        self.right_pane.rowconfigure(1, weight=1)
        self.right_pane.columnconfigure(0, weight=1)
        button_frame = ttk.Frame(self.right_pane)
        button_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        ttk.Button(button_frame, text=self.loc.get('trigger_btn_new', fallback="New Rule..."), command=self._open_rule_editor, style="success.TButton").pack(side="left")
        ttk.Button(button_frame, text=self.loc.get('trigger_btn_edit', fallback="Edit..."), command=self._edit_selected_rule).pack(side="left", padx=10)
        ttk.Button(button_frame, text=self.loc.get('trigger_btn_delete', fallback="Delete"), command=self._delete_selected_rule, style="danger.TButton").pack(side="left")
        rules_frame = ttk.LabelFrame(self.right_pane, text="Active Trigger Rules")
        rules_frame.grid(row=1, column=0, sticky="nsew")
        rules_frame.rowconfigure(0, weight=1)
        rules_frame.columnconfigure(0, weight=1)
        columns = ("name", "trigger_type", "preset", "status", "next_run")
        self.rules_tree = ttk.Treeview(rules_frame, columns=columns, show="headings", style="Custom.Treeview")
        self.rules_tree.heading("name", text=self.loc.get('trigger_col_name', fallback="Rule Name"))
        self.rules_tree.heading("trigger_type", text=self.loc.get('trigger_col_type', fallback="Trigger Type"))
        self.rules_tree.heading("preset", text=self.loc.get('trigger_col_preset', fallback="Preset to Run"))
        self.rules_tree.heading("status", text=self.loc.get('trigger_col_status', fallback="Status"))
        self.rules_tree.heading("next_run", text=self.loc.get('trigger_col_next_run', fallback="Next Schedule"))
        self.rules_tree.column("name", width=250)
        self.rules_tree.column("trigger_type", width=150)
        self.rules_tree.column("preset", width=200)
        self.rules_tree.column("status", width=80, anchor='center')
        self.rules_tree.column("next_run", width=150, anchor='center')
        self.rules_tree.grid(row=0, column=0, sticky="nsew")
        scrollbar = ttk.Scrollbar(rules_frame, orient="vertical", command=self.rules_tree.yview)
        self.rules_tree.configure(yscrollcommand=scrollbar.set)
        scrollbar.grid(row=0, column=1, sticky="ns")
    def _apply_markdown_to_text_widget(self, text_widget, content):
        text_widget.config(state="normal")
        text_widget.delete("1.0", "end")
        parts = re.split(r'(\*\*.*?\*\*)', content)
        for part in parts:
            if part.startswith('**') and part.endswith('**'):
                text_widget.insert("end", part[2:-2], "bold")
            else:
                text_widget.insert("end", part)
        text_widget.config(state="disabled")
    def _on_toolbox_select(self, event=None):
        selected_items = self.trigger_toolbox_tree.selection()
        if not selected_items:
            return
        trigger_id = selected_items[0]
        trigger_def = self.trigger_definitions.get(trigger_id)
        if trigger_def:
            name = self.loc.get(trigger_def.get('name_key'), fallback=trigger_def.get('id'))
            desc = self.loc.get(trigger_def.get('description_key'), fallback='No description available.')
            usage = self.loc.get(trigger_def.get('tutorial_key'), fallback='No tutorial available.')
            self.detail_title.config(text=name)
            self.detail_desc.config(text=desc)
            self._apply_markdown_to_text_widget(self.detail_usage, usage)
    def _populate_trigger_toolbox(self, success, definitions):
        for item in self.trigger_toolbox_tree.get_children():
            self.trigger_toolbox_tree.delete(item)
        self.trigger_definitions.clear()
        if success:
            for trigger_def in sorted(definitions, key=lambda x: self.loc.get(x.get('name_key'), fallback=x.get('id', ''))):
                trigger_id = trigger_def['id']
                display_name = self.loc.get(trigger_def.get('name_key'), fallback=trigger_id)
                self.trigger_definitions[trigger_id] = trigger_def
                self.trigger_toolbox_tree.insert("", "end", iid=trigger_id, text=display_name)
        else:
            self.trigger_toolbox_tree.insert("", "end", text="Error loading triggers.")
    def _on_drag_start(self, event):
        item_id = self.trigger_toolbox_tree.identify_row(event.y)
        if not item_id: return
        item_text = self.trigger_toolbox_tree.item(item_id, "text")
        self._drag_data = {
            "item_id": item_id,
            "widget": ttk.Label(self.winfo_toplevel(), text=item_text, bootstyle="inverse-info", padding=5, relief="solid"),
            "tree_widget": self.trigger_toolbox_tree
        }
    def _on_drag_motion(self, event):
        if self._drag_data.get("widget"):
            self._drag_data['widget'].place(x=event.x_root - self.winfo_toplevel().winfo_rootx() + 15, y=event.y_root - self.winfo_toplevel().winfo_rooty() + 15)
    def _on_drag_release(self, event):
        if self._drag_data.get("widget"):
            self._drag_data["widget"].destroy()
        drop_x, drop_y = event.x_root, event.y_root
        right_pane = self.right_pane
        if right_pane and right_pane.winfo_rootx() < drop_x < right_pane.winfo_rootx() + right_pane.winfo_width() and \
           right_pane.winfo_rooty() < drop_y < right_pane.winfo_rooty() + right_pane.winfo_height():
            dropped_trigger_id = self._drag_data.get("item_id")
            if dropped_trigger_id:
                self.kernel.write_to_log(f"Trigger type '{dropped_trigger_id}' dropped. Opening editor.", "INFO")
                prefilled_data = {'trigger_id': dropped_trigger_id}
                self._open_rule_editor(rule_data=prefilled_data)
        self._drag_data = {}
    def _load_initial_data(self):
        self.rules_tree.insert("", "end", values=("Loading rules from API...", "", "", "", ""), tags=("loading",))
        self.trigger_toolbox_tree.insert("", "end", text="Loading triggers...", tags=("loading",))
        threading.Thread(target=self._load_data_worker, daemon=True).start()
    def _load_data_worker(self):
        success_rules, rules = self.api_client.get_trigger_rules()
        success_defs, defs = self.api_client.get_trigger_definitions()
        self.after(0, self._populate_rules_list_from_data, success_rules, rules)
        self.after(0, self._populate_trigger_toolbox, success_defs, defs)
    def _populate_rules_list_from_data(self, success, rules):
        for item in self.rules_tree.get_children():
            self.rules_tree.delete(item)
        self.countdown_jobs.clear()
        if not success:
            messagebox.showerror(self.loc.get('error_title'), f"Failed to load trigger rules: {rules}")
            self.rules_tree.insert("", "end", values=("Failed to load rules.", "", "", "", ""), tags=("error",))
            return
        for rule_data in sorted(rules, key=lambda r: r.get('name', '')):
            status = self.loc.get('status_enabled') if rule_data.get("is_enabled") else self.loc.get('status_disabled')
            next_run_text = "-"
            if rule_data.get("is_enabled") and rule_data.get('next_run_time'):
                next_run_text = self.loc.get('status_calculating')
            values = (
                rule_data.get("name", "No Name"),
                rule_data.get("trigger_name", "Unknown"),
                rule_data.get("preset_to_run", "-"),
                status,
                next_run_text
            )
            item_id = self.rules_tree.insert("", "end", values=values, iid=rule_data['id'])
            if rule_data.get("is_enabled") and rule_data.get('next_run_time'):
                self.countdown_jobs[item_id] = rule_data['next_run_time']
    def _start_countdown_updater(self):
        if self.countdown_updater_id is None:
            self._update_countdowns()
    def _update_countdowns(self):
        if not self.winfo_exists(): return
        for item_id, next_run_iso in self.countdown_jobs.items():
            if not self.rules_tree.exists(item_id): continue
            try:
                next_run_time = datetime.fromisoformat(next_run_iso)
                now_utc = datetime.now(timezone.utc)
                delta = next_run_time - now_utc
                if delta.total_seconds() > 0:
                    hours, remainder = divmod(int(delta.total_seconds()), 3600)
                    minutes, seconds = divmod(remainder, 60)
                    countdown_str = f"{hours:02}:{minutes:02}:{seconds:02}"
                    self.rules_tree.set(item_id, "next_run", countdown_str)
                else:
                    self.rules_tree.set(item_id, "next_run", self.loc.get('status_waiting_schedule'))
            except (ValueError, TypeError):
                 self.rules_tree.set(item_id, "next_run", self.loc.get('status_not_scheduled'))
        self.countdown_updater_id = self.after(1000, self._update_countdowns)
    def destroy(self):
        if self.countdown_updater_id:
            self.after_cancel(self.countdown_updater_id)
        event_bus = self.kernel.get_service("event_bus")
        if event_bus:
            subscriber_id = f"trigger_manager_page_{id(self)}"
        super().destroy()
    def _on_cron_job_executed(self, event_data):
        self.kernel.write_to_log("Cron job executed, TriggerManagerPage is refreshing its data.", "DEBUG")
        self.after(1000, self._load_initial_data)
    def _edit_selected_rule(self):
        selected_items = self.rules_tree.selection()
        if not selected_items:
            messagebox.showwarning(self.loc.get('warning_title'), self.loc.get('trigger_warn_select_to_edit'))
            return
        success, all_rules = self.api_client.get_trigger_rules()
        if not success:
            messagebox.showerror(self.loc.get('error_title'), "Could not fetch rule details for editing.")
            return
        rule_data = next((r for r in all_rules if r['id'] == selected_items[0]), None)
        if rule_data:
            self._open_rule_editor(rule_id=selected_items[0], rule_data=rule_data)
    def _delete_selected_rule(self):
        selected_items = self.rules_tree.selection()
        if not selected_items:
            messagebox.showwarning(self.loc.get('warning_title'), self.loc.get('trigger_warn_select_to_delete'))
            return
        rule_id = selected_items[0]
        rule_name = self.rules_tree.item(rule_id, 'values')[0]
        if messagebox.askyesno(self.loc.get('confirm_delete_title'), self.loc.get('trigger_confirm_delete', name=rule_name)):
            success, response = self.api_client.delete_trigger_rule(rule_id)
            if success:
                self._save_and_reload()
            else:
                messagebox.showerror(self.loc.get('error_title'), f"Failed to delete rule: {response}")
    def _save_and_reload(self):
        self._load_initial_data()
        self.api_client.reload_triggers()
    def _open_rule_editor(self, rule_id=None, rule_data=None):
        rule_data = rule_data or {}
        editor_window = Toplevel(self)
        editor_window.transient(self)
        editor_window.grab_set()
        editor_window.title(self.loc.get('trigger_editor_title_edit' if rule_id else 'trigger_editor_title_new'))
        _, trigger_defs = self.api_client.get_trigger_definitions()
        _, presets = self.api_client.get_presets()
        form_vars = {
            'name': ttk.StringVar(value=rule_data.get('name', '')),
            'trigger_id': ttk.StringVar(value=rule_data.get('trigger_id', '')),
            'preset_to_run': ttk.StringVar(value=rule_data.get('preset_to_run', '')),
            'is_enabled': ttk.BooleanVar(value=rule_data.get('is_enabled', True)),
        }
        main_frame = ttk.Frame(editor_window, padding=20)
        main_frame.pack(fill="both", expand=True)
        ttk.Label(main_frame, text=self.loc.get('trigger_form_name')).pack(anchor='w', pady=(0,2))
        ttk.Entry(main_frame, textvariable=form_vars['name']).pack(fill='x', pady=(0, 10))
        ttk.Label(main_frame, text=self.loc.get('trigger_form_type')).pack(anchor='w', pady=(0,2))
        trigger_display_names = {self.loc.get(tdef.get('name_key'), fallback=tdef['id']): tdef['id'] for tdef in trigger_defs}
        trigger_combobox = ttk.Combobox(main_frame, state="readonly", values=list(sorted(trigger_display_names.keys())))
        if form_vars['trigger_id'].get():
            id_to_display = {v: k for k, v in trigger_display_names.items()}
            display_name = id_to_display.get(form_vars['trigger_id'].get())
            if display_name:
                trigger_combobox.set(display_name)
            else:
                self.kernel.write_to_log(f"Cannot set trigger in UI, ID '{form_vars['trigger_id'].get()}' not found in loaded definitions.", "WARN")
        trigger_combobox.pack(fill='x', pady=(0, 10))
        ttk.Label(main_frame, text=self.loc.get('trigger_form_preset')).pack(anchor='w', pady=(0,2))
        ttk.Combobox(main_frame, textvariable=form_vars['preset_to_run'], values=presets, state="readonly").pack(fill='x', pady=(0, 10))
        config_frame_container = ttk.Frame(main_frame)
        config_frame_container.pack(fill="both", expand=True, pady=5)
        def on_trigger_selected(event=None):
            for widget in config_frame_container.winfo_children(): widget.destroy()
            trigger_manager_service = self.kernel.get_service("trigger_manager_service")
            if not trigger_manager_service: return
            selected_display_name = trigger_combobox.get()
            selected_trigger_id = trigger_display_names.get(selected_display_name)
            if not selected_trigger_id: return
            form_vars['trigger_id'].set(selected_trigger_id)
            ConfigUIClass = trigger_manager_service.get_config_ui_class(selected_trigger_id)
            if ConfigUIClass:
                config_frame_container.configure(padding=(0, 10))
                config_ui_instance = ConfigUIClass(config_frame_container, self.loc, rule_data.get('config', {}))
                config_ui_instance.pack(fill='both', expand=True)
                form_vars['config_ui'] = config_ui_instance
            else:
                config_frame_container.configure(padding=(0, 0))
        trigger_combobox.bind("<<ComboboxSelected>>", on_trigger_selected)
        if form_vars['trigger_id'].get(): on_trigger_selected()
        bottom_frame = ttk.Frame(main_frame)
        bottom_frame.pack(side='bottom', fill='x', pady=(10,0))
        ttk.Checkbutton(bottom_frame, text=self.loc.get('trigger_form_enable'), variable=form_vars['is_enabled']).pack(side='left')
        button_container = ttk.Frame(bottom_frame)
        button_container.pack(side='right')
        def _save_rule():
            if not form_vars['trigger_id'].get():
                messagebox.showerror(self.loc.get('error_title'), self.loc.get('trigger_err_no_type_selected'))
                return
            new_rule_data = {
                "name": form_vars['name'].get(),
                "trigger_id": form_vars['trigger_id'].get(),
                "preset_to_run": form_vars['preset_to_run'].get(),
                "is_enabled": form_vars['is_enabled'].get(),
                "config": {}
            }
            if 'config_ui' in form_vars and hasattr(form_vars['config_ui'], 'get_config'):
                new_rule_data['config'] = form_vars['config_ui'].get_config()
            if rule_id:
                success, _ = self.api_client.update_trigger_rule(rule_id, new_rule_data)
            else:
                success, _ = self.api_client.create_trigger_rule(new_rule_data)
            if success:
                self._save_and_reload()
                editor_window.destroy()
            else:
                messagebox.showerror(self.loc.get('error_title'), "Failed to save the rule via API.")
        ttk.Button(button_container, text=self.loc.get('button_save'), command=_save_rule, style="success.TButton").pack(side="right")
        ttk.Button(button_container, text=self.loc.get('button_cancel'), command=editor_window.destroy, style="secondary.TButton").pack(side="right", padx=10)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\upload_dialog.py
# JUMLAH BARIS : 60
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, messagebox
from tkinter.scrolledtext import ScrolledText
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class UploadDialog(ttk.Toplevel):
    """
    A dialog for users to enter details before uploading a component to the marketplace.
    """
    def __init__(self, parent, kernel, component_name):
        self.api_client = ApiClient()
        super().__init__(parent)
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        self.title(self.loc.get('marketplace_upload_dialog_title', fallback="Upload to Community"))
        self.result = None
        self.description_var = StringVar()
        self.tier_var = StringVar()
        main_frame = ttk.Frame(self, padding=20)
        main_frame.pack(fill="both", expand=True)
        ttk.Label(main_frame, text=self.loc.get('marketplace_upload_dialog_header', component_name=component_name, fallback=f"You are about to upload: {component_name}")).pack(pady=(0, 10))
        ttk.Label(main_frame, text=self.loc.get('marketplace_upload_dialog_desc_label', fallback="Description:")).pack(anchor='w')
        self.description_text = ScrolledText(main_frame, height=5, wrap="word")
        self.description_text.pack(fill="x", pady=(0, 10))
        self.description_text.insert("1.0", f"A great component: {component_name}")
        ttk.Label(main_frame, text=self.loc.get('marketplace_upload_dialog_tier_label', fallback="Select Tier:")).pack(anchor='w')
        tier_options = list(self.kernel.TIER_HIERARCHY.keys())
        tier_combo = ttk.Combobox(main_frame, textvariable=self.tier_var, values=tier_options, state="readonly")
        tier_combo.pack(fill="x")
        tier_combo.set("free") # Default to free tier
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill="x", pady=(20, 0))
        upload_button = ttk.Button(button_frame, text=self.loc.get('marketplace_upload_btn', fallback="Upload"), command=self._on_upload, bootstyle="success")
        upload_button.pack(side="right")
        cancel_button = ttk.Button(button_frame, text=self.loc.get('button_cancel', fallback="Cancel"), command=self.destroy, bootstyle="secondary")
        cancel_button.pack(side="right", padx=(0, 10))
        self.transient(parent)
        self.grab_set()
        self.wait_window(self)
    def _on_upload(self):
        """
        Validates the input and sets the result.
        """
        description = self.description_text.get("1.0", "end-1c").strip()
        tier = self.tier_var.get()
        if not description or not tier:
            messagebox.showwarning(self.loc.get('warning_title', fallback="Warning"), self.loc.get('marketplace_upload_dialog_validation_error', fallback="Description and Tier cannot be empty."), parent=self)
            return
        self.result = {
            "description": description,
            "tier": tier
        }
        self.destroy()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\components\recorder_control_panel.py
# JUMLAH BARIS : 107
#######################################################################

```py
import ttkbootstrap as ttk
import pyaudio
import mss
from flowork_gui.views.custom_widgets.tooltip import ToolTip # PENAMBAHAN: Importing from the new local GUI path.
from flowork_gui.api_client.client import ApiClient
class RecorderControlPanel(ttk.Toplevel):
    """
    The control panel for the screen recorder.
    [V5] Added a gain/amplification slider.
    """
    def __init__(self, parent, kernel, recorder_service):
        self.api_client = ApiClient()
        super().__init__(parent)
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        self.recorder_service = recorder_service
        self.transient(parent)
        self.title(self.loc.get("recorder_panel_title", fallback="Tutorial Studio"))
        self.geometry("400x320") # (MODIFIED) A bit taller for the gain slider
        self.resizable(False, False)
        self.selected_screen = ttk.IntVar(value=1)
        self.record_audio_var = ttk.BooleanVar(value=True)
        self.gain_var = ttk.DoubleVar(value=1.5) # Default gain is 1.5x
        self.mic_device_map = {}
        self._build_widgets()
        self.protocol("WM_DELETE_WINDOW", self._on_close)
        self._refresh_audio_devices()
    def _build_widgets(self):
        main_frame = ttk.Frame(self, padding=15)
        main_frame.pack(fill="both", expand=True)
        screen_frame = ttk.Frame(main_frame)
        screen_frame.pack(fill='x', pady=(0, 10))
        ttk.Label(screen_frame, text=self.loc.get("recorder_select_screen", fallback="Record Screen:")).pack(side="left")
        with mss.mss() as sct:
            monitors = sct.monitors
        self.screen_combo = ttk.Combobox(screen_frame, textvariable=self.selected_screen, state="readonly", values=list(range(1, len(monitors))))
        self.screen_combo.pack(side="right", fill="x", expand=True, padx=(10,0))
        if len(monitors) > 1:
            self.screen_combo.set(1)
        audio_frame = ttk.Frame(main_frame)
        audio_frame.pack(fill='x', pady=(0, 5))
        self.audio_check = ttk.Checkbutton(
            audio_frame,
            text=self.loc.get("recorder_use_default_mic", fallback="Record Audio (uses default microphone)"),
            variable=self.record_audio_var,
            command=self._toggle_gain_slider_state # (ADDED) Link to toggle function
        )
        self.audio_check.pack(anchor='w')
        self.gain_frame = ttk.Frame(main_frame)
        self.gain_frame.pack(fill='x', pady=(0, 15), padx=20)
        self.gain_label = ttk.Label(self.gain_frame, text=self.loc.get("recorder_gain_label", fallback="Amplification (Gain):"))
        self.gain_label.pack(side="left")
        self.gain_slider = ttk.Scale(self.gain_frame, from_=1.0, to=5.0, variable=self.gain_var)
        self.gain_slider.pack(side="left", fill="x", expand=True, padx=10)
        self.gain_value_label = ttk.Label(self.gain_frame, text=f"{self.gain_var.get():.1f}x", width=4)
        self.gain_value_label.pack(side="left")
        self.gain_slider.config(command=lambda val: self.gain_value_label.config(text=f"{float(val):.1f}x"))
        self.start_button = ttk.Button(main_frame, text=self.loc.get("recorder_start_button", fallback="Start Recording"), command=self._start_recording, bootstyle="danger")
        self.start_button.pack(fill="x", ipady=10, side="bottom")
    def _toggle_gain_slider_state(self):
        """(ADDED) Enables/disables the gain slider based on the checkbox."""
        if self.record_audio_var.get():
            self.gain_label.config(state="normal")
            self.gain_slider.config(state="normal")
            self.gain_value_label.config(state="normal")
        else:
            self.gain_label.config(state="disabled")
            self.gain_slider.config(state="disabled")
            self.gain_value_label.config(state="disabled")
    def _refresh_audio_devices(self):
        try:
            p = pyaudio.PyAudio()
            mic_count = 0
            for i in range(p.get_device_count()):
                if p.get_device_info_by_index(i).get('maxInputChannels') > 0:
                    mic_count += 1
            p.terminate()
            if mic_count == 0:
                self.audio_check.config(state="disabled")
                self.record_audio_var.set(False)
                self._toggle_gain_slider_state()
        except Exception as e:
            self.audio_check.config(state="disabled")
            self.record_audio_var.set(False)
            self._toggle_gain_slider_state()
    def _start_recording(self):
        record_audio = self.record_audio_var.get()
        monitor_number = self.selected_screen.get()
        gain = self.gain_var.get()
        self.recorder_service.start_recording(
            monitor_num=monitor_number,
            record_audio=record_audio,
            gain=gain
        )
        self.destroy()
    def _on_close(self):
        if self.recorder_service.floating_widget:
            self.recorder_service.floating_widget.control_panel_closed()
        self.destroy()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\generator_components\base_component.py
# JUMLAH BARIS : 52
#######################################################################

```py
from abc import ABC, abstractmethod
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class BaseGeneratorComponent(ABC):
    """
    The abstract contract that all UI component definitions for the Generator must implement.
    Each component knows how to draw itself and generate its own code snippets.
    """
    def __init__(self, kernel):
        self.api_client = ApiClient()
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
    @abstractmethod
    def get_toolbox_label(self) -> str:
        """Returns the text for the button in the toolbox."""
        pass
    @abstractmethod
    def get_component_type(self) -> str:
        """Returns the unique string identifier for this component type (e.g., 'text_input')."""
        pass
    @abstractmethod
    def create_canvas_widget(self, parent_frame, component_id, config):
        """Creates and returns the visual representation of the component on the design canvas."""
        pass
    @abstractmethod
    def create_properties_ui(self, parent_frame, config):
        """Creates the specific UI for the properties panel and returns a dict of tk.Vars."""
        pass
    @abstractmethod
    def generate_manifest_entry(self, config) -> dict:
        """Generates the dictionary entry for this property for the manifest.json file."""
        pass
    @abstractmethod
    def generate_processor_ui_code(self, config) -> list:
        """
        Generates a list of strings, where each string is a line of Python code
        for creating the properties UI in the final processor.py file.
        """
        pass
    def get_required_imports(self) -> set:
        """
        Returns a set of import strings required by this component.
        e.g., {"from tkinter import filedialog"}
        """
        return set()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\generator_components\checkbox.py
# JUMLAH BARIS : 54
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, BooleanVar
from .base_component import BaseGeneratorComponent
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class CheckboxComponent(BaseGeneratorComponent):
    def get_toolbox_label(self) -> str:
        return self.loc.get('generator_toolbox_checkbox', fallback="Checkbox")
    def get_component_type(self) -> str:
        return 'checkbox'
    def create_canvas_widget(self, parent_frame, component_id, config):
        label_text = config.get('label', "My Checkbox")
        label = ttk.Checkbutton(parent_frame, text=label_text)
        label.pack(anchor='w')
        return label
    def create_properties_ui(self, parent_frame, config):
        prop_vars = {}
        prop_vars['id'] = StringVar(value=config.get('id', ''))
        prop_vars['label'] = StringVar(value=config.get('label', ''))
        default_value = config.get('default', False)
        if not isinstance(default_value, bool):
            default_value = str(default_value).lower() in ['true', '1', 'yes']
        prop_vars['default'] = BooleanVar(value=default_value)
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_id', fallback="Variable ID:")).pack(fill='x', anchor='w')
        ttk.Entry(parent_frame, textvariable=prop_vars['id']).pack(fill='x', pady=(0,10))
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_label', fallback="Display Label:")).pack(fill='x', anchor='w')
        ttk.Entry(parent_frame, textvariable=prop_vars['label']).pack(fill='x', pady=(0,10))
        ttk.Checkbutton(parent_frame, text=self.loc.get('generator_comp_prop_checked_by_default', fallback="Checked by default?"), variable=prop_vars['default']).pack(fill='x', pady=(0,10))
        return prop_vars
    def generate_manifest_entry(self, config) -> dict:
        return {
            "id": config['id'],
            "type": "boolean",
            "label": config['label'],
            "default": config.get('default', False)
        }
    def generate_processor_ui_code(self, config) -> list:
        comp_id = config['id']
        comp_label = config['label']
        return [
            f"        # --- {comp_label} ---",
            f"        property_vars['{comp_id}'] = BooleanVar(value=config.get('{comp_id}'))",
            f"        ttk.Checkbutton(parent_frame, text=\"{comp_label}\", variable=property_vars['{comp_id}']).pack(anchor='w', padx=5, pady=5)",
            ""
        ]
    def get_required_imports(self) -> set:
        return {"from tkinter import BooleanVar, StringVar"}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\generator_components\dropdown.py
# JUMLAH BARIS : 62
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, Text
from .base_component import BaseGeneratorComponent
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class DropdownComponent(BaseGeneratorComponent):
    def get_toolbox_label(self) -> str:
        return self.loc.get('generator_toolbox_dropdown', fallback="Dropdown")
    def get_component_type(self) -> str:
        return 'dropdown'
    def create_canvas_widget(self, parent_frame, component_id, config):
        label_text = config.get('label', "My Dropdown")
        options = config.get('options', ['Option 1', 'Option 2'])
        label = ttk.Label(parent_frame, text=label_text)
        label.pack(anchor='w')
        ttk.Combobox(parent_frame, values=options).pack(fill='x')
        return label
    def create_properties_ui(self, parent_frame, config):
        prop_vars = {}
        prop_vars['id'] = StringVar(value=config.get('id', ''))
        prop_vars['label'] = StringVar(value=config.get('label', ''))
        prop_vars['default'] = StringVar(value=config.get('default', ''))
        options_text = Text(parent_frame, height=4, font=("Helvetica", 9))
        options_text.insert('1.0', "\n".join(config.get('options', [])))
        prop_vars['options'] = options_text
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_id', fallback="Variable ID:")).pack(fill='x', anchor='w')
        ttk.Entry(parent_frame, textvariable=prop_vars['id']).pack(fill='x', pady=(0,10))
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_label', fallback="Display Label:")).pack(fill='x', anchor='w')
        ttk.Entry(parent_frame, textvariable=prop_vars['label']).pack(fill='x', pady=(0,10))
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_default', fallback="Default Value:")).pack(fill='x', anchor='w')
        ttk.Entry(parent_frame, textvariable=prop_vars['default']).pack(fill='x', pady=(0,10))
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_options', fallback="Options (one per line):")).pack(fill='x', anchor='w')
        options_text.pack(fill='x', pady=(0,10))
        return prop_vars
    def generate_manifest_entry(self, config) -> dict:
        return {
            "id": config['id'],
            "type": "enum",
            "label": config['label'],
            "default": config['default'],
            "options": config.get('options', [])
        }
    def generate_processor_ui_code(self, config) -> list:
        comp_id = config['id']
        comp_label = config['label']
        options = config.get('options', [])
        return [
            f"        # --- {comp_label} ---",
            f"        property_vars['{comp_id}'] = StringVar(value=config.get('{comp_id}'))",
            f"        ttk.Label(parent_frame, text=\"{comp_label}\").pack(fill='x', padx=5, pady=(5,0))",
            f"        ttk.Combobox(parent_frame, textvariable=property_vars['{comp_id}'], values={options}, state='readonly').pack(fill='x', padx=5, pady=(0, 5))",
            ""
        ]
    def get_required_imports(self) -> set:
        return {"from tkinter import StringVar, Text"}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\generator_components\file_path.py
# JUMLAH BARIS : 63
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, filedialog
from .base_component import BaseGeneratorComponent
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class FilePathComponent(BaseGeneratorComponent):
    def get_toolbox_label(self) -> str:
        return self.loc.get('generator_toolbox_file_path', fallback="File/Folder Path")
    def get_component_type(self) -> str:
        return 'file_path'
    def create_canvas_widget(self, parent_frame, component_id, config):
        label_text = config.get('label', "My File Path")
        label = ttk.Label(parent_frame, text=label_text)
        label.pack(anchor='w')
        path_frame = ttk.Frame(parent_frame)
        path_frame.pack(fill='x')
        ttk.Entry(path_frame).pack(side='left', fill='x', expand=True)
        ttk.Button(path_frame, text="...").pack(side='left')
        return label
    def create_properties_ui(self, parent_frame, config):
        prop_vars = {}
        prop_vars['id'] = StringVar(value=config.get('id', ''))
        prop_vars['label'] = StringVar(value=config.get('label', ''))
        prop_vars['default'] = StringVar(value=config.get('default', ''))
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_id', fallback="Variable ID:")).pack(fill='x', anchor='w')
        ttk.Entry(parent_frame, textvariable=prop_vars['id']).pack(fill='x', pady=(0,10))
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_label', fallback="Display Label:")).pack(fill='x', anchor='w')
        ttk.Entry(parent_frame, textvariable=prop_vars['label']).pack(fill='x', pady=(0,10))
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_default', fallback="Default Path:")).pack(fill='x', anchor='w')
        ttk.Entry(parent_frame, textvariable=prop_vars['default']).pack(fill='x', pady=(0,10))
        return prop_vars
    def generate_manifest_entry(self, config) -> dict:
        return {
            "id": config['id'],
            "type": "filepath",
            "label": config['label'],
            "default": config['default']
        }
    def generate_processor_ui_code(self, config) -> list:
        comp_id = config['id']
        comp_label = config['label']
        return [
            f"        # --- {comp_label} ---",
            f"        ttk.Label(parent_frame, text=\"{comp_label}\").pack(fill='x', padx=5, pady=(5,0))",
            f"        path_frame_{comp_id} = ttk.Frame(parent_frame)",
            f"        path_frame_{comp_id}.pack(fill='x', padx=5, pady=(0, 5))",
            f"        property_vars['{comp_id}'] = StringVar(value=config.get('{comp_id}'))",
            f"        ttk.Entry(path_frame_{comp_id}, textvariable=property_vars['{comp_id}']).pack(side='left', fill='x', expand=True)",
            f"        def _browse_{comp_id}():",
            f"            path = filedialog.askdirectory() # or askopenfilename()",
            f"            if path: property_vars['{comp_id}'].set(path)",
            f"        ttk.Button(path_frame_{comp_id}, text='...', command=_browse_{comp_id}, width=4).pack(side='left', padx=(5,0))",
            ""
        ]
    def get_required_imports(self) -> set:
        return {"from tkinter import filedialog", "from tkinter import StringVar"}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\generator_components\info_label.py
# JUMLAH BARIS : 39
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar
from .base_component import BaseGeneratorComponent
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class InfoLabelComponent(BaseGeneratorComponent):
    def get_toolbox_label(self) -> str:
        return self.loc.get('generator_toolbox_info_label', fallback="Info Label")
    def get_component_type(self) -> str:
        return 'info_label'
    def create_canvas_widget(self, parent_frame, component_id, config):
        label_text = config.get('label', "This is an informational message.")
        label = ttk.Label(parent_frame, text=label_text, bootstyle="secondary", wraplength=200)
        label.pack(anchor='w', pady=5)
        return label
    def create_properties_ui(self, parent_frame, config):
        prop_vars = {}
        prop_vars['label'] = StringVar(value=config.get('label', ''))
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_info_text', fallback="Informational Text:")).pack(fill='x', anchor='w')
        ttk.Entry(parent_frame, textvariable=prop_vars['label']).pack(fill='x', pady=(0,10))
        return prop_vars
    def generate_manifest_entry(self, config) -> dict:
        return None # InfoLabel doesn't create a manifest property
    def generate_processor_ui_code(self, config) -> list:
        comp_label = config['label']
        return [
            f"        # --- Info Label ---",
            f"        ttk.Label(parent_frame, text=\"{comp_label}\", wraplength=400, justify='left', bootstyle='secondary').pack(fill='x', padx=5, pady=5)",
            ""
        ]
    def get_required_imports(self) -> set:
        return {"from tkinter import StringVar"}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\generator_components\logic_builder_canvas.py
# JUMLAH BARIS : 116
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import ttk as tk_ttk
from views.canvas_manager import CanvasManager # PENAMBAHAN: Ini adalah alamat impor yang benar.
from api_client.client import ApiClient # PENAMBAHAN: Ini adalah alamat impor yang benar.
class LogicBuilderCanvas(ttk.Frame):
    """
    Kanvas visual untuk merancang logika 'execute' dari sebuah modul baru.
    Ini adalah implementasi dari "Logic Builder Canvas" pada Manifesto Flowork.
    [FIXED V2] Toolbox now dynamically loads all available LOGIC and ACTION modules.
    """
    def __init__(self, parent, kernel):
        self.api_client = ApiClient()
        super().__init__(parent)
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        self.canvas_manager = None
        self._drag_data = {}
        self._create_widgets()
    def _create_widgets(self):
        main_pane = ttk.PanedWindow(self, orient='horizontal')
        main_pane.pack(fill="both", expand=True)
        toolbox_frame = ttk.LabelFrame(main_pane, text="Node Logika Dasar", padding=10) # English Hardcode "Logic Node"
        main_pane.add(toolbox_frame, weight=0)
        self.logic_node_tree = tk_ttk.Treeview(toolbox_frame, show="tree", selectmode="browse")
        self.logic_node_tree.pack(expand=True, fill='both')
        self._populate_logic_toolbox()
        canvas_container = ttk.Frame(main_pane)
        main_pane.add(canvas_container, weight=4)
        theme_manager = self.kernel.get_service("theme_manager")
        colors = theme_manager.get_colors() if theme_manager else {'bg': '#222'}
        class DummyCoordinatorTab(ttk.Frame):
            def __init__(self, kernel, logic_builder_instance):
                super().__init__(logic_builder_instance)
                self.kernel = kernel
                self._execution_state = "IDLE"
                self.logic_builder_instance = logic_builder_instance
            def on_drag_start(self, event):
                self.logic_builder_instance.on_drag_start(event)
            def on_drag_motion(self, event):
                self.logic_builder_instance.on_drag_motion(event)
            def on_drag_release(self, event):
                self.logic_builder_instance.on_drag_release(event)
        dummy_tab = DummyCoordinatorTab(self.kernel, self)
        self.canvas = ttk.Canvas(canvas_container, background=colors.get('bg', '#222'))
        self.canvas.pack(expand=True, fill='both')
        self.canvas_manager = CanvasManager(canvas_container, dummy_tab, self.canvas, self.kernel)
        self.logic_node_tree.bind("<ButtonPress-1>", self.on_drag_start)
    def _populate_logic_toolbox(self):
        module_manager = self.kernel.get_service("module_manager_service")
        if not module_manager:
            self.logic_node_tree.insert('', 'end', text="Error: ModuleManager not found.")
            return
        logic_modules = {}
        action_modules = {}
        for mod_id, mod_data in module_manager.loaded_modules.items():
            manifest = mod_data.get("manifest", {})
            mod_type = manifest.get("type")
            if mod_type == "LOGIC" or mod_type == "CONTROL_FLOW":
                logic_modules[mod_id] = manifest.get("name", mod_id)
            elif mod_type == "ACTION":
                action_modules[mod_id] = manifest.get("name", mod_id)
        if logic_modules:
            logic_category = self.logic_node_tree.insert('', 'end', iid='logic_category', text='Logic & Control Flow', open=True) # English Hardcode
            for mod_id, name in sorted(logic_modules.items(), key=lambda item: item[1]):
                 self.logic_node_tree.insert(logic_category, 'end', iid=mod_id, text=f" {name}")
        if action_modules:
            action_category = self.logic_node_tree.insert('', 'end', iid='action_category', text='Actions', open=True) # English Hardcode
            for mod_id, name in sorted(action_modules.items(), key=lambda item: item[1]):
                 self.logic_node_tree.insert(action_category, 'end', iid=mod_id, text=f" {name}")
    def get_logic_data(self):
        """Mengambil data dari kanvas untuk disimpan."""
        if self.canvas_manager:
            return self.canvas_manager.get_workflow_data()
        return {"nodes": [], "connections": []}
    def load_logic_data(self, logic_data):
        """Memuat data ke kanvas."""
        if self.canvas_manager and logic_data:
            self.canvas_manager.load_workflow_data(logic_data)
    def on_drag_start(self, event):
        tree_widget = event.widget
        item_id = tree_widget.identify_row(event.y)
        if not item_id or 'category' in tree_widget.item(item_id, "tags") or not tree_widget.parent(item_id):
            return
        self._drag_data = {
            "item_id": item_id,
            "widget": ttk.Label(self.winfo_toplevel(), text=tree_widget.item(item_id, "text").strip(), style='Ghost.TLabel'),
            "tree_widget": tree_widget
        }
        self.winfo_toplevel().bind("<B1-Motion>", self.on_drag_motion)
        self.winfo_toplevel().bind("<ButtonRelease-1>", self.on_drag_release)
    def on_drag_motion(self, event):
        if self._drag_data.get("widget"):
            self._drag_data['widget'].place(
                x=event.x_root - self.winfo_toplevel().winfo_rootx(),
                y=event.y_root - self.winfo_toplevel().winfo_rooty()
            )
    def on_drag_release(self, event):
        if self._drag_data.get("widget"):
            self._drag_data["widget"].destroy()
        if self.canvas_manager and self._drag_data.get("item_id"):
            self.canvas_manager.interaction_manager.on_drag_release(
                event,
                self._drag_data["item_id"],
                self._drag_data["tree_widget"]
            )
        self._drag_data = {}
        self.winfo_toplevel().unbind("<B1-Motion>")
        self.winfo_toplevel().unbind("<ButtonRelease-1>")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\generator_components\separator.py
# JUMLAH BARIS : 30
#######################################################################

```py
import ttkbootstrap as ttk
from .base_component import BaseGeneratorComponent
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class SeparatorComponent(BaseGeneratorComponent):
    def get_toolbox_label(self) -> str:
        return self.loc.get('generator_toolbox_separator', fallback="Separator")
    def get_component_type(self) -> str:
        return 'separator'
    def create_canvas_widget(self, parent_frame, component_id, config):
        label = ttk.Separator(parent_frame, orient='horizontal')
        label.pack(fill='x', pady=10, padx=5)
        return label
    def create_properties_ui(self, parent_frame, config):
        ttk.Label(parent_frame, text=self.loc.get('generator_no_props', fallback="No properties to configure."), bootstyle="secondary").pack(pady=10)
        return {} # No properties
    def generate_manifest_entry(self, config) -> dict:
        return None # Separator doesn't create a manifest property
    def generate_processor_ui_code(self, config) -> list:
        return [
            "        ttk.Separator(parent_frame).pack(fill='x', pady=10, padx=5)",
            ""
        ]
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\generator_components\textarea.py
# JUMLAH BARIS : 61
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, scrolledtext
from .base_component import BaseGeneratorComponent
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class TextAreaComponent(BaseGeneratorComponent):
    def get_toolbox_label(self) -> str:
        return self.loc.get('generator_toolbox_textarea', fallback="Text Area")
    def get_component_type(self) -> str:
        return 'textarea'
    def create_canvas_widget(self, parent_frame, component_id, config):
        label_text = config.get('label', "My Text Area")
        label = ttk.Label(parent_frame, text=label_text)
        label.pack(anchor='w')
        text_widget = scrolledtext.ScrolledText(parent_frame, height=3, font=("Helvetica", 9))
        text_widget.pack(fill='x')
        text_widget.insert('1.0', str(config.get('default', '')))
        text_widget.config(state='disabled')
        return label
    def create_properties_ui(self, parent_frame, config):
        prop_vars = {}
        prop_vars['id'] = StringVar(value=config.get('id', ''))
        prop_vars['label'] = StringVar(value=config.get('label', ''))
        default_text = scrolledtext.ScrolledText(parent_frame, height=4, font=("Helvetica", 9))
        default_text.insert('1.0', str(config.get('default', '')))
        prop_vars['default'] = default_text
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_id', fallback="Variable ID:")).pack(fill='x', anchor='w')
        ttk.Entry(parent_frame, textvariable=prop_vars['id']).pack(fill='x', pady=(0,10))
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_label', fallback="Display Label:")).pack(fill='x', anchor='w')
        ttk.Entry(parent_frame, textvariable=prop_vars['label']).pack(fill='x', pady=(0,10))
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_default', fallback="Default Value:")).pack(fill='x', anchor='w')
        default_text.pack(fill='x', pady=(0,10))
        return prop_vars
    def generate_manifest_entry(self, config) -> dict:
        return {
            "id": config['id'],
            "type": "textarea",
            "label": config['label'],
            "default": config['default']
        }
    def generate_processor_ui_code(self, config) -> list:
        comp_id = config['id']
        comp_label = config['label']
        return [
            f"        # --- {comp_label} ---",
            f"        ttk.Label(parent_frame, text=\"{comp_label}\").pack(fill='x', padx=5, pady=(5,0))",
            f"        {comp_id}_widget = scrolledtext.ScrolledText(parent_frame, height=8, font=(\"Consolas\", 10))",
            f"        {comp_id}_widget.pack(fill=\"both\", expand=True, padx=5, pady=(0, 5))",
            f"        {comp_id}_widget.insert('1.0', config.get('{comp_id}', ''))",
            f"        property_vars['{comp_id}'] = {comp_id}_widget",
            ""
        ]
    def get_required_imports(self) -> set:
        return {"from tkinter import scrolledtext, StringVar"}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\generator_components\text_input.py
# JUMLAH BARIS : 57
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar
from .base_component import BaseGeneratorComponent
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class TextInputComponent(BaseGeneratorComponent):
    def get_toolbox_label(self) -> str:
        return self.loc.get('generator_toolbox_text_input', fallback="Text Input")
    def get_component_type(self) -> str:
        return 'text_input'
    def create_canvas_widget(self, parent_frame, component_id, config):
        label_text = config.get('label', "My Text Input")
        label = ttk.Label(parent_frame, text=label_text)
        label.pack(anchor='w')
        ttk.Entry(parent_frame).pack(fill='x')
        return label # Return the primary widget for label updates
    def create_properties_ui(self, parent_frame, config):
        prop_vars = {}
        prop_vars['id'] = StringVar(value=config.get('id', ''))
        prop_vars['label'] = StringVar(value=config.get('label', ''))
        prop_vars['default'] = StringVar(value=config.get('default', ''))
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_id', fallback="Variable ID:")).pack(fill='x', anchor='w')
        ttk.Entry(parent_frame, textvariable=prop_vars['id']).pack(fill='x', pady=(0,10))
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_label', fallback="Display Label:")).pack(fill='x', anchor='w')
        ttk.Entry(parent_frame, textvariable=prop_vars['label']).pack(fill='x', pady=(0,10))
        ttk.Label(parent_frame, text=self.loc.get('generator_comp_prop_default', fallback="Default Value:")).pack(fill='x', anchor='w')
        ttk.Entry(parent_frame, textvariable=prop_vars['default']).pack(fill='x', pady=(0,10))
        return prop_vars
    def generate_manifest_entry(self, config) -> dict:
        return {
            "id": config['id'],
            "type": "string", # Text input produces a string
            "label": config['label'],
            "default": config['default']
        }
    def generate_processor_ui_code(self, config) -> list:
        comp_id = config['id']
        comp_label = config['label']
        return [
            f"        # --- {comp_label} ---",
            f"        property_vars['{comp_id}'] = StringVar(value=config.get('{comp_id}'))",
            f"        ttk.Label(parent_frame, text=\"{comp_label}\").pack(fill='x', padx=5, pady=(5,0))",
            f"        ttk.Entry(parent_frame, textvariable=property_vars['{comp_id}']).pack(fill='x', padx=5, pady=(0, 5))",
            "" # Add a blank line for spacing
        ]
    def get_required_imports(self) -> set:
        """
        Declares that this component requires 'StringVar' from tkinter.
        """
        return {"from tkinter import StringVar"}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\locales\en.json
# JUMLAH BARIS : 41
#######################################################################

```json
{
    "marketplace_page_title": "Marketplace",
    "marketplace_install_btn": "Install from Zip...",
    "marketplace_disable_btn": "Disable Selected",
    "marketplace_enable_btn": "Enable Selected",
    "marketplace_uninstall_btn": "Uninstall Selected",
    "marketplace_tab_modules": "Modules",
    "marketplace_tab_plugins": "Plugins",
    "marketplace_tab_widgets": "Widgets",
    "marketplace_col_name": "Name",
    "marketplace_col_version": "Version",
    "marketplace_col_status": "Status",
    "marketplace_restart_needed": "Action successful. A restart is required for changes to take full effect.",
    "marketplace_uninstall_confirm": "Are you sure you want to uninstall '{component_name}'? This action cannot be undone.",
    "marketplace_install_dialog_title": "Select Component Zip File",
    "menu_title_prompt_manager": "Prompt Manager",
    "prompt_manager_editor_title": "Prompt Editor",
    "prompt_manager_name_label": "Template Name:",
    "prompt_manager_content_label": "Template Content:",
    "button_save_changes": "Save Changes",
    "prompt_manager_tutorial_title": "Guide & How-To",
    "prompt_manager_tutorial_content": "**Concept:**\nThe Prompt Manager is your \"recipe book\" for AI. Store complex and frequently used prompt templates here so they can be reused across many workflows.\n\n**How to Use:**\n1.  **Create New:** Click 'New' to create a blank template.\n2.  **Fill Details:** Provide a descriptive 'Template Name' and write the prompt's content in the 'Template Content' area.\n3.  **Use Variables:** You can insert dynamic placeholders like `{objective}` or `{user_input}` within the content. These placeholders will later be filled by data from the payload when the workflow runs.\n4.  **Save:** Click 'Save Changes' to save your template to the database.\n5.  **Use in a Workflow:** On the canvas, use the 'Prompt Template' module to select and load the template you've saved.",
    "model_converter_guide_title": "Model Factory Guide & Concepts",
    "model_converter_guide_content": "**IMPORTANT: THE BRIDGE FROM TRAINING TO USAGE**\nAfter you fine-tune an AI model using the **AI Trainer**, the result is a **Hugging Face (HF) model folder**. This folder cannot be used directly by Flowork for inference (running tasks). You **MUST** use this page to convert it into the efficient **GGUF** format.\n\n**Concept:**\nThe Model Factory is your \"foundry\" for converting and optimizing AI models to run efficiently locally. The main process is **quantization**, which shrinks the model's size with minimal precision loss, making it much faster and memory-friendly.\n\n**Tab 1: Convert HF to GGUF**\nUse this for models from the **AI Trainer** or models you've downloaded from Hugging Face.\n1.  **Fine-Tuned Model Folder:** Select the HF model folder you have prepared in `ai_models/text`.\n2.  **New .gguf Filename:** Give a name for the converted file (without `.gguf`).\n3.  **Quantization Method:** Choose the compression level. **Q4_K_M** is a balanced choice between size and quality.\n\n**Tab 2: Re-Quantize Existing GGUF**\nUse this if you already have a `.gguf` file but want to make it even smaller.\n1.  **Source .gguf File:** Select the `.gguf` file you want to re-quantize.\n2.  **New Quantized Filename:** Give a new name for the quantized output file.",
    "ai_trainer_guide_title": "AI Training Guide & Workflow",
    "ai_trainer_guide_content": "**Concept:**\nThe AI Trainer is your facility for *fine-tuning*—retraining an existing AI model with your specific data. The goal is to make the AI an \"expert\" on a particular topic or style you desire.\n\n**The Training Workflow (MANDATORY):**\n1.  **Prepare Data (Here):**\n    - Create a new dataset (e.g., `chatbot_training_data`).\n    - Fill the dataset with `question;answer` format, one per line. The more high-quality data you provide, the smarter the AI will become.\n2.  **Train the Model (Here):**\n    - Select a 'Base Model' (the foundation model to train).\n    - Choose the 'Dataset' you just prepared.\n    - Give your new model a name (e.g., `chatbot_v1`).\n    - Click 'Start Fine-Tuning Job'. This process will output a **model folder** in `ai_models/text/chatbot_v1`.\n3.  **Convert the Model (in Model Factory):**\n    - **THIS IS THE CRUCIAL STEP.** The trained model is not yet usable.\n    - Go to the **Model Factory** page -> **Convert HF to GGUF** tab.\n    - Select your model folder (`chatbot_v1`).\n    - Provide an output filename (e.g., `chatbot_v1_q4`).\n    - Click 'Start Conversion'. This will produce a single file: `chatbot_v1_q4.gguf`.\n4.  **Use the Model:**\n    - This `chatbot_v1_q4.gguf` file is now ready to be selected and used in AI modules within Flowork.",
    "generator_guide_title": "Module Factory Guide",
    "generator_guide_content": "**Concept:**\nThe Module Factory is your advanced \"workshop\" for creating your own Flowork modules without writing lots of boilerplate code. You can visually design the properties interface (UI) and define its logic.\n\n**Module Creation Workflow:**\n1.  **Design Properties (Tab 1 - Left):**\n    - Drag & drop UI components from the Toolbox onto the design canvas.\n    - Click a component on the canvas to edit its properties in the bottom-right panel (ID, Label, etc.).\n    - The ID will become the key in the `config` dictionary when your module is executed.\n2.  **Design Logic (Tab 2 - Left):**\n    - Design your module's internal execution flow on this canvas.\n    - Use the `Set Variable` node as an input to get values from the properties you designed. Example: `config.get('your_component_id')`.\n    - The final result of this logic flow will be the output of your module.\n3.  **Fill in Module Info (Top-Right Panel):**\n    - Give your module a name, description, and author info. A Unique ID will be generated automatically.\n4.  **Finalize & Generate (Bottom-Right Panel):**\n    - Click the 'Generate Module ZIP File' button.\n    - Name and save your .zip file.\n5.  **Installation:**\n    - Go to the **Addon Manager** page, click 'Install from Zip...', and select the .zip file you just created.",
    "core_editor_guide_title": "Core Editor Guide & Concepts",
    "core_editor_guide_content": "**Core Concept:**\nThe Core Editor is a \"Meta-Developer\" mode. Here, you are not creating a regular workflow; you are designing the **internal logic of a Service** itself. The Service you create here will be loaded by the Kernel when the application first starts.\n\n**Anatomy of a Service:**\n- **Filename (`service_name.flowork`):** Becomes the base for the Python Class name (e.g., `ServiceNameService`).\n- **Each Flow:** Every flow that has no input (a starting node) will be translated into a **method** within that Service Class. The method name is taken from the starting node's name.\n- **Return Value:** The `payload` from the final node in a flow becomes the `return value` of that method.\n\n**Design Workflow:**\n1.  **Select Service:** Choose the `.flowork` file from the dropdown above.\n2.  **Design Logic:** Drag & drop modules from the Toolbox onto the canvas to build the method's logic.\n3.  **Use `Function Runner (Nano)`:** This module is your main workhorse. The Python code inside it becomes the body of your service method. The variables `payload`, `log`, `kernel`, and `args` are automatically available.\n4.  **Save Changes:** Click the \"Save Changes\" button. This overwrites the `.flowork` file.\n5.  **Compile!:** Open the `Core Compiler` module, select the service you just edited, and run it. This will regenerate the `service.py` file in the `generated_services` folder.\n\n**IMPORTANT WARNING:**\nBecause you are editing core logic, a mistake here can cause the **application to fail on startup**. Always back up the `.flowork` file before making major changes.",
    "ai_architect_guide_title": "AI Architect Guide",
    "ai_architect_guide_content": "**Core Concept:**\nThe AI Architect is your magic translator. It converts plain human language commands into a ready-to-use visual workflow. You simply describe what you want, and the AI will attempt to design the nodes for you.\n\n**PRIMARY REQUIREMENT (MANDATORY!):**\nThis feature **fully depends** on the AI model you configure on the **Settings -> Default AI Model Configuration -> Text & Analysis** page. Ensure you have selected an AI provider (like Gemini) or a local GGUF model there. Otherwise, the AI Architect won't know who to ask and will fail.\n\n**How to Use:**\n1.  **Write Command:** In the main text box, clearly write the objective for your workflow.\n2.  **Click Generate:** Press the \"🚀 Generate Workflow\" button.\n3.  **Wait:** The AI will think and design the workflow. This might take a moment.\n4.  **New Tab:** If successful, a new tab will open with the generated workflow.\n\n**Tips for Effective Prompts:**\n-   **Be Specific:** The more detailed your command, the better the result. Mention module names if you know them (e.g., \"use the *Advanced Web Scraper*\").\n-   **Mention URLs:** If it involves the web, provide the full URL (e.g., \"from the website *cnn.com*\").\n-   **Clear Sequence:** Explain the steps. Example: \"First, get data from an API. Second, filter for data containing the word 'important'. Third, save the results to a CSV file.\"",
    "button_new": "New",
    "button_delete": "Delete",
    "marketplace_install_community_btn": "Install from Community",
    "theme_manager_guide_title": "Theme Manager Guide",
    "theme_manager_guide_content": "**Concept:**\nThis is where you manage the look and feel of your Flowork application. A theme is a simple `.json` file that defines the color palette for all UI components.\n\n**How to Use:**\n1.  **Viewing Themes:** All installed themes will appear in the list.\n2.  **Editing a Theme:** Click the pencil icon (✏️) to open the theme's `.json` file in your default text editor. You can change the color hex values there. Save the file to see the changes (an application restart may be required).\n3.  **Deleting a Theme:** Click the cross icon (❌) to delete a theme. The default theme cannot be deleted.\n4.  **Uploading a New Theme:** Use the 'Upload Theme' button to add a new theme `.json` file from your computer.\n\n**Tips:**\n-   You can duplicate an existing theme file, rename it, and edit it to create a new theme quickly.\n-   Share your theme `.json` files with other users!",
    "diagnostics_guide_title": "System Diagnostics Guide",
    "diagnostics_guide_content": "**Concept:**\nThis is the \"engine room\" of Flowork. This tool runs a series of automated scans to check the \"health\" and integrity of the application's internal code, manifests, and caches.\n\n**Purpose:**\n-   **Find Regressions:** Ensures that new updates or changes do not break the stable core architecture.\n-   **Maintain Code Quality:** Automatically detects if any modules are not following standards (e.g., missing a `TIER` attribute).\n-   **Advanced Debugging:** Helps developers find hidden issues like missing files or corrupted caches.\n\n**How to Use:**\n1.  **Select Scanners:** Check which scanners you want to run from the list on the left.\n2.  **Run Scan:** Click 'Run Selected' or 'Run All'.\n3.  **View Report:** The results will appear in the right-hand panel. Pay attention to the levels: **CRITICAL** and **MAJOR** are serious issues that should be fixed immediately.",
    "marketplace_upload_duplicate_error": "This component '{component_id}' already exists in the repository."
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\locales\id.json
# JUMLAH BARIS : 41
#######################################################################

```json
{
    "marketplace_page_title": "Marketplace",
    "marketplace_install_btn": "Install dari Zip...",
    "marketplace_disable_btn": "Nonaktifkan Pilihan",
    "marketplace_enable_btn": "Aktifkan Pilihan",
    "marketplace_uninstall_btn": "Copot Pilihan",
    "marketplace_tab_modules": "Modul",
    "marketplace_tab_plugins": "Plugin",
    "marketplace_tab_widgets": "Widget",
    "marketplace_col_name": "Nama",
    "marketplace_col_version": "Versi",
    "marketplace_col_status": "Status",
    "marketplace_restart_needed": "Aksi berhasil. Restart aplikasi diperlukan agar perubahan berlaku sepenuhnya.",
    "marketplace_uninstall_confirm": "Anda yakin ingin mencopot '{component_name}'? Aksi ini tidak bisa dibatalkan.",
    "marketplace_install_dialog_title": "Pilih File Zip Komponen",
    "menu_title_prompt_manager": "Manajer Prompt",
    "prompt_manager_editor_title": "Editor Prompt",
    "prompt_manager_name_label": "Nama Template:",
    "prompt_manager_content_label": "Isi Template:",
    "button_save_changes": "Simpan Perubahan",
    "prompt_manager_tutorial_title": "Panduan & Cara Penggunaan",
    "prompt_manager_tutorial_content": "**Konsep:**\nManajer Prompt adalah \"buku resep\" Anda untuk AI. Simpan template prompt yang kompleks dan sering digunakan di sini agar bisa dipakai kembali di banyak workflow.\n\n**Cara Penggunaan:**\n1.  **Buat Baru:** Klik 'New' untuk membuat template kosong.\n2.  **Isi Detail:** Beri 'Nama Template' yang deskriptif dan tulis isi prompt di area 'Template Content'.\n3.  **Gunakan Variabel:** Anda bisa memasukkan placeholder dinamis seperti `{objective}` atau `{user_input}` di dalam konten. Placeholder ini nantinya akan diisi oleh data dari payload saat workflow berjalan.\n4.  **Simpan:** Klik 'Save Changes' untuk menyimpan template Anda ke database.\n5.  **Gunakan di Workflow:** Di kanvas, gunakan modul 'Prompt Template' untuk memilih dan memuat template yang sudah Anda simpan.",
    "model_converter_guide_title": "Panduan & Konsep Model Factory",
    "model_converter_guide_content": "**PENTING: JEMBATAN DARI TRAINING KE PENGGUNAAN**\nSetelah Anda melatih (fine-tuning) model AI menggunakan **AI Trainer**, hasilnya adalah sebuah **folder model Hugging Face (HF)**. Folder ini belum bisa langsung digunakan oleh Flowork untuk inferensi (menjalankan tugas). Anda **WAJIB** menggunakan halaman ini untuk mengubahnya menjadi format **GGUF** yang efisien.\n\n**Konsep:**\nModel Factory adalah \"pabrik\" Anda untuk mengubah dan mengoptimalkan model AI agar efisien dijalankan secara lokal. Proses utamanya adalah **kuantisasi**, yaitu mengecilkan ukuran model dengan presisi minimal agar jauh lebih cepat dan hemat memori.\n\n**Tab 1: Convert HF to GGUF**\nGunakan ini untuk model hasil **AI Trainer** atau model yang Anda download dari Hugging Face.\n1.  **Fine-Tuned Model Folder:** Pilih folder model HF yang sudah Anda siapkan di `ai_models/text`.\n2.  **New .gguf Filename:** Beri nama untuk file hasil konversi (tanpa `.gguf`).\n3.  **Quantization Method:** Pilih tingkat kompresi. **Q4_K_M** adalah pilihan seimbang antara ukuran dan kualitas.\n\n**Tab 2: Re-Quantize Existing GGUF**\nGunakan ini jika Anda sudah punya file `.gguf` tapi ingin membuatnya lebih kecil lagi.\n1.  **Source .gguf File:** Pilih file `.gguf` yang ingin Anda kuantisasi ulang.\n2.  **New Quantized Filename:** Beri nama baru untuk file hasil kuantisasi.",
    "ai_trainer_guide_title": "Panduan & Alur Kerja Pelatihan AI",
    "ai_trainer_guide_content": "**Konsep:**\nAI Trainer adalah fasilitas Anda untuk melakukan *fine-tuning*—melatih ulang model AI yang sudah ada dengan data spesifik Anda. Tujuannya adalah membuat AI menjadi \"ahli\" dalam topik atau gaya tertentu yang Anda inginkan.\n\n**Alur Kerja Pelatihan (WAJIB DIIKUTI):**\n1.  **Siapkan Data (di sini):**\n    - Buat dataset baru (misal: `data_latihan_chatbot`).\n    - Isi dataset dengan format `pertanyaan;jawaban` per baris. Semakin banyak dan berkualitas data Anda, semakin pintar AI-nya.\n2.  **Latih Model (di sini):**\n    - Pilih 'Base Model' (model dasar untuk dilatih).\n    - Pilih 'Dataset' yang sudah Anda siapkan.\n    - Beri nama untuk model baru Anda (misal: `chatbot_v1`).\n    - Klik 'Start Fine-Tuning Job'. Proses ini akan menghasilkan sebuah **folder model** di `ai_models/text/chatbot_v1`.\n3.  **Konversi Model (di Model Factory):**\n    - **INI LANGKAH KRUSIAL.** Model hasil training belum bisa dipakai.\n    - Buka halaman **Model Factory** -> tab **Convert HF to GGUF**.\n    - Pilih folder model Anda (`chatbot_v1`).\n    - Beri nama file output (misal: `chatbot_v1_q4`).\n    - Klik 'Start Conversion'. Proses ini akan menghasilkan satu file: `chatbot_v1_q4.gguf`.\n4.  **Gunakan Model:**\n    - File `chatbot_v1_q4.gguf` inilah yang sekarang bisa Anda pilih dan gunakan di modul-modul AI di dalam Flowork.",
    "generator_guide_title": "Panduan Module Factory",
    "generator_guide_content": "**Konsep:**\nModule Factory adalah \"bengkel\" canggih Anda untuk menciptakan modul Flowork Anda sendiri tanpa perlu menulis banyak kode boilerplate. Anda bisa merancang antarmuka properti (UI) secara visual dan mendefinisikan logikanya.\n\n**Alur Kerja Pembuatan Modul:**\n1.  **Desain Properti (Tab 1 - Kiri):**\n    - Drag & drop komponen UI dari Toolbox ke kanvas desain.\n    - Klik komponen di kanvas untuk mengedit propertinya di panel kanan bawah (ID, Label, dll).\n    - ID akan menjadi kunci di `config` saat modul dieksekusi.\n2.  **Desain Logika (Tab 2 - Kiri):**\n    - Rancang alur logika internal modul Anda di kanvas ini.\n    - Gunakan node `Set Variabel` sebagai input untuk mengambil nilai dari properti yang Anda desain. Contoh: `config.get('id_komponen_anda')`.\n    - Hasil akhir dari alur logika ini akan menjadi output dari modul Anda.\n3.  **Isi Info Modul (Panel Kanan Atas):**\n    - Beri nama, deskripsi, dan info pembuat modul Anda. ID Unik akan dibuat secara otomatis.\n4.  **Finalisasi & Generate (Panel Kanan Bawah):**\n    - Klik tombol 'Generate Module ZIP File'.\n    - Beri nama dan simpan file .zip Anda.\n5.  **Instalasi:**\n    - Buka halaman **Addon Manager**, klik 'Install from Zip...', dan pilih file .zip yang baru saja Anda buat.",
    "core_editor_guide_title": "Panduan & Konsep Core Editor",
    "core_editor_guide_content": "**Konsep Inti:**\nCore Editor adalah mode \"Meta-Developer\". Di sini, kamu tidak membuat workflow biasa, tapi kamu mendesain **logika internal dari sebuah Service** itu sendiri. Service yang kamu buat di sini akan dimuat oleh Kernel saat aplikasi pertama kali berjalan.\n\n**Anatomi Service:**\n- **Nama File (`nama_service.flowork`):** Akan menjadi dasar nama Class Python (misal: `NamaServiceService`).\n- **Setiap Alur (Flow):** Setiap alur yang tidak memiliki input (node awal) akan diterjemahkan menjadi sebuah **method** di dalam Class Service tersebut. Nama method diambil dari nama node awal.\n- **Return Value:** Nilai `payload` dari node terakhir di sebuah alur akan menjadi `return value` dari method tersebut.\n\n**Alur Kerja Desain:**\n1.  **Pilih Service:** Pilih file `.flowork` dari dropdown di atas.\n2.  **Rancang Logika:** Drag & drop modul dari Toolbox ke kanvas untuk membangun logika method.\n3.  **Gunakan `Function Runner (Nano)`:** Modul ini adalah pekerja utamamu. Kode Python di dalamnya akan menjadi isi dari method servicemu. Variabel `payload`, `log`, `kernel`, dan `args` sudah tersedia otomatis.\n4.  **Simpan Perubahan:** Klik tombol \"Save Changes\". Ini akan menulis ulang file `.flowork`.\n5.  **Kompilasi!:** Buka modul `Core Compiler`, pilih service yang baru kamu edit, dan jalankan. Ini akan meng-generate ulang file `service.py` di folder `generated_services`.\n\n**PERINGATAN PENTING:**\nKarena kamu mengedit logika inti, kesalahan di sini bisa menyebabkan **aplikasi gagal startup**. Selalu backup file `.flowork` sebelum melakukan perubahan besar.",
    "ai_architect_guide_title": "Panduan AI Architect",
    "ai_architect_guide_content": "**Konsep Inti:**\nAI Architect adalah \"penerjemah\" ajaibmu. Ia mengubah perintah bahasa manusia biasa menjadi sebuah alur kerja (workflow) visual yang siap pakai. Kamu cukup jelaskan apa yang kamu mau, dan AI akan mencoba merancang nodenya untukmu.\n\n**SYARAT UTAMA (WAJIB!):**\nFitur ini **bergantung penuh** pada model AI yang kamu atur di halaman **Settings -> Default AI Model Configuration -> Text & Analysis**. Pastikan kamu sudah memilih provider AI (seperti Gemini) atau model GGUF lokal di sana. Jika tidak, AI Architect tidak akan tahu harus bertanya ke siapa dan akan gagal.\n\n**Cara Penggunaan:**\n1.  **Tulis Perintah:** Di kotak teks utama, tuliskan tujuan alur kerjamu secara jelas.\n2.  **Klik Generate:** Tekan tombol \"🚀 Generate Workflow\".\n3.  **Tunggu:** AI akan berpikir dan merancang alur kerja. Proses ini mungkin butuh beberapa saat.\n4.  **Tab Baru:** Jika berhasil, sebuah tab baru akan terbuka dengan alur kerja yang sudah jadi.\n\n**Tips untuk Prompt yang Efektif:**\n-   **Spesifik:** Semakin detail perintahmu, semakin baik hasilnya. Sebutkan nama modul jika kamu tahu (misal: \"gunakan *Advanced Web Scraper*\").\n-   **Sebutkan URL:** Jika melibatkan web, sebutkan URL lengkapnya (misal: \"dari situs *detik.com*\").\n-   **Urutan Jelas:** Jelaskan langkah demi langkah. Contoh: \"Pertama, ambil data dari API. Kedua, filter data yang mengandung kata 'penting'. Ketiga, simpan hasilnya ke file CSV.\"",
    "button_new": "Baru",
    "button_delete": "Hapus",
    "marketplace_install_community_btn": "Install dari Komunitas",
    "theme_manager_guide_title": "Panduan Manajer Tema",
    "theme_manager_guide_content": "**Konsep:**\nDi sinilah Anda mengelola tampilan dan nuansa aplikasi Flowork Anda. Tema adalah file `.json` sederhana yang mendefinisikan palet warna untuk semua komponen UI.\n\n**Cara Penggunaan:**\n1.  **Melihat Tema:** Semua tema yang terinstal akan muncul di daftar.\n2.  **Mengedit Tema:** Klik ikon pensil (✏️) untuk membuka file `.json` tema di editor teks default Anda. Anda bisa mengubah nilai hex warna di sana. Simpan file untuk melihat perubahan (mungkin perlu me-restart aplikasi).\n3.  **Menghapus Tema:** Klik ikon silang (❌) untuk menghapus tema. Tema default tidak bisa dihapus.\n4.  **Mengunggah Tema Baru:** Gunakan tombol 'Unggah Tema' untuk menambahkan file `.json` tema baru dari komputer Anda.\n\n**Tips:**\n-   Anda bisa menduplikasi file tema yang ada, mengganti namanya, dan mengeditnya untuk membuat tema baru dengan cepat.\n-   Bagikan file `.json` tema Anda dengan pengguna lain!",
    "diagnostics_guide_title": "Panduan Diagnostik Sistem",
    "diagnostics_guide_content": "**Konsep:**\nIni adalah \"ruang mesin\" Flowork. Alat ini menjalankan serangkaian pemindaian otomatis untuk memeriksa \"kesehatan\" dan integritas kode internal aplikasi, manifest, dan cache.\n\n**Tujuan:**\n-   **Menemukan Regresi:** Memastikan pembaruan atau perubahan baru tidak merusak arsitektur inti yang sudah stabil.\n-   **Menjaga Kualitas Kode:** Secara otomatis mendeteksi jika ada modul yang tidak mengikuti standar (misalnya, tidak punya atribut `TIER`).\n-   **Debugging Lanjutan:** Membantu developer menemukan masalah tersembunyi seperti file yang hilang atau cache yang rusak.\n\n**Cara Penggunaan:**\n1.  **Pilih Scanner:** Centang pemindai mana yang ingin Anda jalankan dari daftar di kiri.\n2.  **Jalankan Scan:** Klik 'Run Selected' atau 'Run All'.\n3.  **Lihat Laporan:** Hasilnya akan muncul di panel kanan. Perhatikan levelnya: **CRITICAL** dan **MAJOR** adalah masalah serius yang harus segera diperbaiki.",
    "marketplace_upload_duplicate_error": "Komponen '{component_id}' ini sudah ada di repositori."
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\settings_components\agent_dialog.py
# JUMLAH BARIS : 113
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, messagebox, scrolledtext
from ui_shell.custom_widgets.DualListbox import DualListbox # PENAMBAHAN OTOMATIS
import os
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class AgentDialog(ttk.Toplevel):
    """
    A dialog for creating and editing an AI Agent's properties.
    (MODIFIED) Now fetches ALL available AI endpoints (local models and providers) for the brain.
    """
    DEFAULT_PROMPT_TEMPLATE = "" # It's better to provide an empty default or a minimal placeholder.
    def __init__(self, parent, kernel, agent_data=None):
        super().__init__(parent)
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        self.api_client = ApiClient(kernel=self.kernel)
        self.agent_data = agent_data or {}
        self.result = None
        title = self.loc.get('agent_dialog_title_edit' if self.agent_data else 'agent_dialog_title_new')
        self.title(title)
        self.geometry("800x850")
        self.name_var = StringVar(value=self.agent_data.get('name', ''))
        self.brain_display_name_var = StringVar()
        self._build_ui()
        self.transient(parent)
        self.grab_set()
        self.wait_window(self)
    def _build_ui(self):
        main_frame = ttk.Frame(self, padding=20)
        main_frame.pack(fill="both", expand=True)
        main_frame.rowconfigure(5, weight=1)
        main_frame.columnconfigure(0, weight=1)
        ttk.Label(main_frame, text=self.loc.get('agent_dialog_name_label')).grid(row=0, column=0, sticky="w", pady=(0,2))
        ttk.Entry(main_frame, textvariable=self.name_var).grid(row=1, column=0, sticky="ew", pady=(0,10))
        ttk.Label(main_frame, text=self.loc.get('agent_dialog_desc_label')).grid(row=2, column=0, sticky="w", pady=(0,2))
        self.desc_text = scrolledtext.ScrolledText(main_frame, height=3, wrap="word")
        self.desc_text.grid(row=3, column=0, sticky="ew", pady=(0,10))
        self.desc_text.insert("1.0", self.agent_data.get('description', ''))
        config_pane = ttk.PanedWindow(main_frame, orient='horizontal')
        config_pane.grid(row=4, column=0, sticky="ew", pady=(0,15))
        brain_frame = ttk.LabelFrame(config_pane, text=self.loc.get('agent_dialog_brain_label'), padding=10)
        config_pane.add(brain_frame, weight=1)
        ai_manager = self.kernel.get_service("ai_provider_manager_service")
        all_endpoints = ai_manager.get_available_providers() if ai_manager else {}
        self.id_to_display_map = {endpoint_id: display_name for endpoint_id, display_name in all_endpoints.items()}
        self.display_to_id_map = {display_name: endpoint_id for endpoint_id, display_name in all_endpoints.items()}
        available_brains_display = sorted(list(self.display_to_id_map.keys()))
        self.brain_combo = ttk.Combobox(brain_frame, textvariable=self.brain_display_name_var, values=available_brains_display, state="readonly")
        self.brain_combo.pack(fill="x")
        saved_brain_id = self.agent_data.get('brain_model_id', '')
        if saved_brain_id in self.id_to_display_map:
            self.brain_display_name_var.set(self.id_to_display_map[saved_brain_id])
        tools_frame = ttk.LabelFrame(config_pane, text=self.loc.get('agent_dialog_tools_label'), padding=10)
        config_pane.add(tools_frame, weight=2)
        modules_success, modules_data = self.api_client.get_components('modules')
        plugins_success, plugins_data = self.api_client.get_components('plugins')
        if not modules_success:
            self.kernel.write_to_log(f"AgentDialog: Failed to get modules from API: {modules_data}", "ERROR")
            modules_data = []
        if not plugins_success:
            self.kernel.write_to_log(f"AgentDialog: Failed to get plugins from API: {plugins_data}", "ERROR")
            plugins_data = []
        all_tools_dict = {item['id']: item['name'] for item in modules_data + plugins_data}
        available_tools = sorted(all_tools_dict.values())
        selected_tool_ids = self.agent_data.get('tool_ids', [])
        selected_tool_names = [all_tools_dict[tid] for tid in selected_tool_ids if tid in all_tools_dict]
        self.tool_selector = DualListbox(tools_frame, self.kernel, available_items=available_tools, selected_items=selected_tool_names)
        self.tool_selector.pack(fill="both", expand=True)
        prompt_frame = ttk.LabelFrame(main_frame, text="Agent Prompt Template", padding=10)
        prompt_frame.grid(row=5, column=0, sticky="nsew", pady=(0,15))
        prompt_frame.rowconfigure(0, weight=1)
        prompt_frame.columnconfigure(0, weight=1)
        self.prompt_text = scrolledtext.ScrolledText(prompt_frame, wrap="word", height=15)
        self.prompt_text.grid(row=0, column=0, sticky="nsew")
        prompt_placeholder = self.agent_data.get('prompt_template') or "# The prompt template is now managed by the 'Prompt Engineer' module.\n# This field is for reference or overrides."
        self.prompt_text.insert("1.0", prompt_placeholder)
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=6, column=0, sticky="e")
        save_button = ttk.Button(button_frame, text=self.loc.get("button_save"), command=self._on_save, bootstyle="success")
        save_button.pack(side="right")
        cancel_button = ttk.Button(button_frame, text=self.loc.get("button_cancel"), command=self.destroy, bootstyle="secondary")
        cancel_button.pack(side="right", padx=(0, 10))
    def _on_save(self):
        name = self.name_var.get().strip()
        brain_display_name = self.brain_display_name_var.get()
        brain_id = self.display_to_id_map.get(brain_display_name)
        selected_tool_names = self.tool_selector.get_selected_items()
        if not name or not brain_id:
            messagebox.showerror("Validation Error", "Agent Name and Brain Model are required.", parent=self)
            return
        modules_success, modules_data = self.api_client.get_components('modules')
        plugins_success, plugins_data = self.api_client.get_components('plugins')
        safe_modules = modules_data if modules_success else []
        safe_plugins = plugins_data if plugins_success else []
        name_to_id_map = {item['name']: item['id'] for item in safe_modules + safe_plugins}
        selected_tool_ids = [name_to_id_map[name] for name in selected_tool_names if name in name_to_id_map]
        self.result = {
            "id": str(self.agent_data.get('id', '')),
            "name": name,
            "description": self.desc_text.get("1.0", "end-1c").strip(),
            "brain_model_id": brain_id,
            "tool_ids": selected_tool_ids,
            "prompt_template": self.prompt_text.get("1.0", "end-1c").strip()
        }
        self.destroy()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\settings_components\ai_model_manager_frame.py
# JUMLAH BARIS : 56
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import messagebox
import os
import threading
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class AiModelManagerFrame(ttk.LabelFrame):
    """UI component for managing the on-demand download of AI models."""
    def __init__(self, parent, kernel):
        self.api_client = ApiClient()
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        super().__init__(parent, text="Manajemen Model AI Lokal", padding=15)
        self.status_label = ttk.Label(self, text="Mengecek status...", anchor="center")
        self.status_label.pack(pady=5, fill="x")
        self.download_button = ttk.Button(self, text="Download Model AI (~70 GB)", command=self._start_download_action)
        self.download_button.pack(pady=5, fill="x", ipady=5)
        self.progress_bar = ttk.Progressbar(self, mode='determinate')
        self.progress_bar.pack(pady=5, fill="x")
        self.progress_bar.pack_forget() # Sembunyikan dulu
        self.check_status()
    def check_status(self):
        """Checks if models are installed and updates the UI accordingly."""
        ai_models_path = os.path.join(self.kernel.project_root_path, "ai_models")
        if os.path.isdir(ai_models_path):
            self.status_label.config(text="Model AI Lokal sudah terinstall.", bootstyle="success")
            self.download_button.pack_forget()
            self.progress_bar.pack_forget()
        else:
            self.status_label.config(text="Model AI Lokal belum terinstall.", bootstyle="warning")
            self.download_button.pack(pady=5, fill="x", ipady=5) # Tampilkan tombol
            if self.kernel.is_tier_sufficient('pro'):
                self.download_button.config(state="normal")
            else:
                self.download_button.config(state="disabled")
                self.status_label.config(text="Model AI membutuhkan lisensi PRO atau lebih tinggi.")
    def _start_download_action(self):
        """Starts the download process in a background thread."""
        if messagebox.askyesno("Konfirmasi Download", "Proses ini akan mengunduh file berukuran sangat besar (~70 GB) dan mungkin memakan waktu lama. Lanjutkan?"):
            self.download_button.config(state="disabled")
            self.progress_bar.pack(pady=5, fill="x")
            self.status_label.config(text="Fitur download sedang dalam pengembangan...")
            self.kernel.write_to_log("TODO: Implement asset downloader service call.", "WARN")
    def load_settings_data(self, settings_data):
        """This component is stateful and doesn't load from settings."""
        self.check_status()
    def get_settings_data(self):
        """This component doesn't save any settings."""
        return {}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\settings_components\ai_provider_settings_frame.py
# JUMLAH BARIS : 98
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar
import os
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class AiProviderSettingsFrame(ttk.LabelFrame):
    """
    [MODIFIED V2] Displays a granular, task-based configuration for default AI models
    instead of a single master AI. Each task type can be mapped to a different provider.
    """
    def __init__(self, parent, kernel):
        self.api_client = ApiClient()
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        super().__init__(parent, text=self.loc.get('setting_ai_config_title', fallback="Default AI Model Configuration"), padding=15)
        self.provider_vars = {}
        self.endpoint_display_to_id_map = {}
        self.task_types = {
            "text": "setting_ai_for_text",
            "music": "setting_ai_for_music",
            "tts": "setting_ai_for_tts",
            "image": "setting_ai_for_image",
            "video": "setting_ai_for_video",
            "other": "setting_ai_for_other"
        }
        self.gpu_layers_var = StringVar()
        self._build_widgets()
    def _build_widgets(self):
        """Builds the UI components for this frame."""
        self.columnconfigure(1, weight=1)
        help_text = ttk.Label(self, text=self.loc.get('setting_ai_config_help', fallback="Select the default AI model for each task type. Features like AI Architect will use these settings."), wraplength=400, justify="left", bootstyle="secondary")
        help_text.grid(row=0, column=0, columnspan=2, padx=5, pady=(0,15), sticky="w")
        row_counter = 1
        for key, label_key in self.task_types.items():
            self.provider_vars[key] = StringVar()
            label_text = self.loc.get(label_key, fallback=f"{key.title()}:")
            label = ttk.Label(self, text=label_text)
            label.grid(row=row_counter, column=0, padx=(0, 10), pady=5, sticky="w")
            provider_combo = ttk.Combobox(self, textvariable=self.provider_vars[key], state="readonly")
            provider_combo.grid(row=row_counter, column=1, padx=5, pady=5, sticky="ew")
            row_counter += 1
        ttk.Separator(self).grid(row=row_counter, column=0, columnspan=2, sticky="ew", pady=10)
        row_counter += 1
        gpu_label = ttk.Label(self, text="GPU Offload Layers (GGUF):") # English Hardcode
        gpu_label.grid(row=row_counter, column=0, padx=5, pady=5, sticky="w")
        gpu_entry = ttk.Entry(self, textvariable=self.gpu_layers_var, width=10)
        gpu_entry.grid(row=row_counter, column=1, padx=5, pady=5, sticky="w")
    def load_settings_data(self, settings_data):
        """Loads the list of endpoints and sets the current settings for each task type."""
        self.gpu_layers_var.set(str(settings_data.get("ai_gpu_layers", 40)))
        ai_manager = self.kernel.get_service("ai_provider_manager_service")
        if not ai_manager:
            for i, (key, label_key) in enumerate(self.task_types.items()):
                combo = self.grid_slaves(row=i + 1, column=1)[0]
                combo['values'] = ["AI Manager Service not found"]
            return
        all_endpoints = ai_manager.get_available_providers()
        self.endpoint_display_to_id_map.clear()
        display_names = []
        for endpoint_id, display_name in all_endpoints.items():
             self.endpoint_display_to_id_map[display_name] = endpoint_id
             display_names.append(display_name)
        sorted_display_names = sorted(display_names)
        for i, (key, label_key) in enumerate(self.task_types.items()):
            combo = self.grid_slaves(row=i + 1, column=1)[0]
            combo['values'] = sorted_display_names
            setting_key = f"ai_model_for_{key}"
            saved_endpoint_id = settings_data.get(setting_key)
            found_saved = False
            if saved_endpoint_id:
                for display, endpoint_id in self.endpoint_display_to_id_map.items():
                    if endpoint_id == saved_endpoint_id:
                        self.provider_vars[key].set(display)
                        found_saved = True
                        break
            if not found_saved and sorted_display_names:
                self.provider_vars[key].set(sorted_display_names[0])
    def get_settings_data(self):
        """Returns all the configured AI settings to be saved."""
        settings_to_save = {}
        for key, var in self.provider_vars.items():
            selected_display_name = var.get()
            if selected_display_name in self.endpoint_display_to_id_map:
                endpoint_id_to_save = self.endpoint_display_to_id_map[selected_display_name]
                setting_key = f"ai_model_for_{key}"
                settings_to_save[setting_key] = endpoint_id_to_save
        try:
            settings_to_save["ai_gpu_layers"] = int(self.gpu_layers_var.get())
        except (ValueError, TypeError):
            settings_to_save["ai_gpu_layers"] = 40
        return settings_to_save
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\settings_components\error_handler_frame.py
# JUMLAH BARIS : 40
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, BooleanVar
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class ErrorHandlerFrame(ttk.LabelFrame):
    def __init__(self, parent, kernel):
        self.api_client = ApiClient()
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        super().__init__(parent, text=self.loc.get("settings_error_handler_title", fallback="Global Error Handler Settings"), padding=15)
        self.error_handler_enabled_var = BooleanVar()
        self.error_handler_preset_var = StringVar()
        self._build_widgets()
    def _build_widgets(self):
        enabled_check = ttk.Checkbutton(self, text=self.loc.get("settings_error_handler_enable_label", fallback="Enable Global Error Handler"), variable=self.error_handler_enabled_var)
        enabled_check.grid(row=0, column=0, columnspan=2, padx=5, pady=5, sticky="w")
        preset_label = ttk.Label(self, text=self.loc.get("settings_error_handler_preset_label", fallback="Select Error Handler Preset:"))
        preset_label.grid(row=1, column=0, padx=5, pady=5, sticky="w")
        preset_manager = self.kernel.get_service("preset_manager")
        preset_list = [""] + preset_manager.get_preset_list() if preset_manager else [""]
        preset_combo = ttk.Combobox(self, textvariable=self.error_handler_preset_var, values=preset_list, state="readonly")
        preset_combo.grid(row=1, column=1, padx=5, pady=5, sticky="ew")
        self.columnconfigure(1, weight=1)
    def load_settings_data(self, settings_data):
        """Loads error handler settings from the provided data dictionary."""
        self.error_handler_enabled_var.set(settings_data.get("global_error_handler_enabled", False))
        self.error_handler_preset_var.set(settings_data.get("global_error_workflow_preset", ""))
    def get_settings_data(self):
        """Returns the current error handler settings from the UI."""
        return {
            "global_error_handler_enabled": self.error_handler_enabled_var.get(),
            "global_error_workflow_preset": self.error_handler_preset_var.get()
        }
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\settings_components\general_settings_frame.py
# JUMLAH BARIS : 56
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class GeneralSettingsFrame(ttk.LabelFrame):
    def __init__(self, parent, kernel):
        self.api_client = ApiClient()
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        super().__init__(parent, text=self.loc.get("settings_general_title", fallback="General Settings"), padding=15)
        self.lang_var = StringVar()
        self.theme_var = StringVar()
        self.available_themes = {}
        self._build_widgets()
    def _build_widgets(self):
        lang_label = ttk.Label(self, text=self.loc.get("settings_language_label", fallback="Interface Language:"))
        lang_label.grid(row=0, column=0, padx=5, pady=5, sticky="w")
        lang_combo = ttk.Combobox(self, textvariable=self.lang_var, values=self.loc.get_available_languages_display(), state="readonly")
        lang_combo.grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        theme_label = ttk.Label(self, text=self.loc.get("settings_theme_label", fallback="Application Theme:"))
        theme_label.grid(row=1, column=0, padx=5, pady=5, sticky="w")
        self.theme_combo = ttk.Combobox(self, textvariable=self.theme_var, values=[], state="readonly")
        self.theme_combo.grid(row=1, column=1, padx=5, pady=5, sticky="ew")
        self.columnconfigure(1, weight=1)
    def load_settings_data(self, settings_data):
        """Loads settings data provided by the parent coordinator."""
        theme_manager = self.kernel.get_service("theme_manager")
        if theme_manager:
            self.available_themes = theme_manager.get_all_themes()
            theme_names = [d.get('name', 'Unknown') for d in self.available_themes.values()]
            self.theme_combo['values'] = sorted(theme_names)
        else:
            self.available_themes = {}
        active_theme_id = settings_data.get("theme", "flowork_default")
        active_theme_name = self.available_themes.get(active_theme_id, {}).get('name', '')
        lang_code = settings_data.get("language", "id")
        lang_display_name = self.loc.language_map.get(lang_code, "Bahasa Indonesia")
        self.lang_var.set(lang_display_name)
        self.theme_var.set(active_theme_name)
    def get_settings_data(self) -> dict:
        """Returns the current settings from the UI as a dictionary."""
        selected_theme_name = self.theme_var.get()
        theme_id_to_save = next((tid for tid, data in self.available_themes.items() if data.get('name') == selected_theme_name), "flowork_default")
        selected_lang_display = self.lang_var.get()
        lang_code_to_save = next((code for code, display in self.loc.language_map.items() if display == selected_lang_display), "id")
        return {
            "language": lang_code_to_save,
            "theme": theme_id_to_save
        }
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\settings_components\license_management_frame.py
# JUMLAH BARIS : 72
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import messagebox
import os
import threading
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class LicenseManagementFrame(ttk.LabelFrame):
    def __init__(self, parent, kernel):
        self.kernel = kernel
        self.loc = self.kernel.loc
        super().__init__(parent, text=self.loc.get("settings_license_title", fallback="License Management"), padding=15)
        self.api_client = ApiClient(kernel=self.kernel)
        self._build_widgets()
        self.load_settings_data(None)
    def _build_widgets(self):
        self.deactivate_button = ttk.Button(
            self,
            text=self.loc.get("settings_license_deactivate_button", fallback="Deactivate License on This Computer"),
            command=self._deactivate_license_action,
            bootstyle="danger-outline"
        )
        self.deactivate_button.pack(pady=5, padx=5, fill='x')
    def refresh_content(self):
        """Refreshes the UI state of the component based on the current kernel license status."""
        if hasattr(self, 'deactivate_button') and self.deactivate_button.winfo_exists():
            if self.kernel.current_user and self.kernel.is_premium_user():
                self.deactivate_button.config(state="normal")
            else:
                self.deactivate_button.config(state="disabled")
    def _deactivate_license_action(self):
        """
        Prompts for confirmation and then runs the license deactivation in a thread.
        """
        if messagebox.askyesno(
            self.loc.get("settings_license_deactivate_confirm_title", fallback="Confirm Deactivation"),
            self.loc.get("settings_license_deactivate_confirm_message"),
            parent=self
        ):
            self.deactivate_button.config(state="disabled")
            threading.Thread(target=self._deactivate_worker, daemon=True).start()
    def _deactivate_worker(self):
        """
        Worker function to call the deactivation method via ApiClient.
        """
        success, message = self.api_client.deactivate_license()
        self.after(0, self._on_deactivate_complete, success, message)
    def _on_deactivate_complete(self, success, message):
        """
        (MODIFIKASI) UI callback yang disederhanakan untuk mencegah race condition.
        """
        if success:
            messagebox.showinfo(
                self.loc.get("messagebox_success_title", fallback="Success"),
                message
            )
        else:
            messagebox.showerror(self.loc.get("messagebox_error_title", fallback="Failed"), message, parent=self)
            if hasattr(self, 'deactivate_button') and self.deactivate_button.winfo_exists():
                self.deactivate_button.config(state="normal")
    def load_settings_data(self, settings_data):
        """This frame's UI is updated based on kernel state, not settings data."""
        self.refresh_content()
    def get_settings_data(self):
        """This frame doesn't save any settings, it only performs actions."""
        return {}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\settings_components\notification_settings_frame.py
# JUMLAH BARIS : 48
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, BooleanVar
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class NotificationSettingsFrame(ttk.LabelFrame):
    def __init__(self, parent, kernel):
        self.api_client = ApiClient()
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        super().__init__(parent, text=self.loc.get("settings_notifications_title", fallback="Popup Notification Settings"), padding=15)
        self.notifications_enabled_var = BooleanVar()
        self.notifications_duration_var = StringVar()
        self.notifications_position_var = StringVar()
        self._build_widgets()
    def _build_widgets(self):
        enabled_check = ttk.Checkbutton(self, text=self.loc.get("settings_notifications_enable_label", fallback="Enable Popup Notifications"), variable=self.notifications_enabled_var)
        enabled_check.grid(row=0, column=0, columnspan=2, padx=5, pady=5, sticky="w")
        duration_label = ttk.Label(self, text=self.loc.get("settings_notifications_duration_label", fallback="Display Duration (seconds):"))
        duration_label.grid(row=1, column=0, padx=5, pady=5, sticky="w")
        duration_entry = ttk.Entry(self, textvariable=self.notifications_duration_var, width=10)
        duration_entry.grid(row=1, column=1, padx=5, pady=5, sticky="w")
        position_label = ttk.Label(self, text=self.loc.get("settings_notifications_position_label", fallback="Popup Position:"))
        position_label.grid(row=2, column=0, padx=5, pady=5, sticky="w")
        position_combo = ttk.Combobox(self, textvariable=self.notifications_position_var, values=["bottom_right", "top_right", "bottom_left", "top_left"], state="readonly")
        position_combo.grid(row=2, column=1, padx=5, pady=5, sticky="w")
    def load_settings_data(self, settings_data):
        """Loads notification settings from the provided data dictionary."""
        self.notifications_enabled_var.set(settings_data.get("notifications_enabled", True))
        self.notifications_duration_var.set(str(settings_data.get("notifications_duration_seconds", 5)))
        self.notifications_position_var.set(settings_data.get("notifications_position", "bottom_right"))
    def get_settings_data(self):
        """Returns the current notification settings from the UI."""
        try:
            duration = int(self.notifications_duration_var.get())
            return {
                "notifications_enabled": self.notifications_enabled_var.get(),
                "notifications_duration_seconds": duration,
                "notifications_position": self.notifications_position_var.get()
            }
        except ValueError:
            raise ValueError("Duration must be a valid number.")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\settings_components\recorder_settings_frame.py
# JUMLAH BARIS : 50
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, filedialog
import os
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class RecorderSettingsFrame(ttk.LabelFrame):
    """
    Manages the UI for screen recorder settings.
    """
    def __init__(self, parent, kernel):
        self.api_client = ApiClient()
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        super().__init__(parent, text="Screen Recorder Settings", padding=15)
        self.save_path_var = StringVar()
        self._build_widgets()
    def _build_widgets(self):
        """Builds the UI components for this frame."""
        path_label = ttk.Label(self, text="Default Save Location:")
        path_label.grid(row=0, column=0, padx=5, pady=5, sticky="w")
        entry_frame = ttk.Frame(self)
        entry_frame.grid(row=1, column=0, columnspan=2, sticky="ew", padx=5)
        entry_frame.columnconfigure(0, weight=1)
        path_entry = ttk.Entry(entry_frame, textvariable=self.save_path_var)
        path_entry.pack(side="left", fill="x", expand=True)
        browse_button = ttk.Button(entry_frame, text="Browse...", command=self._browse_folder, width=10)
        browse_button.pack(side="left", padx=(5, 0))
        self.columnconfigure(1, weight=1)
    def _browse_folder(self):
        """Opens a dialog to select a folder."""
        default_path = os.path.join(os.path.expanduser("~"), "Videos")
        folder_selected = filedialog.askdirectory(initialdir=default_path)
        if folder_selected:
            self.save_path_var.set(folder_selected)
    def load_settings_data(self, settings_data):
        """Loads recorder settings from the provided data dictionary."""
        default_path = os.path.join(os.path.expanduser("~"), "Videos", "Flowork Tutorials")
        self.save_path_var.set(settings_data.get("recorder_save_path", default_path))
    def get_settings_data(self) -> dict:
        """Returns the current recorder settings from the UI."""
        return {
            "recorder_save_path": self.save_path_var.get()
        }
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\settings_components\variable_dialog.py
# JUMLAH BARIS : 90
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, BooleanVar, messagebox, scrolledtext
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class VariableDialog(ttk.Toplevel):
    def __init__(self, parent, title, kernel, existing_name=None, existing_data=None):
        self.api_client = ApiClient()
        super().__init__(parent)
        self.title(title)
        self.transient(parent)
        self.grab_set()
        self.loc = kernel.get_service("localization_manager")
        self.result = None
        existing_data = existing_data or {}
        self.name_var = StringVar(value=existing_name or "")
        initial_mode = existing_data.get('mode', 'single')
        initial_value_text = ""
        if initial_mode == 'single':
            if existing_data.get('is_secret'):
                 initial_value_text = self.loc.get("settings_variables_dialog_secret_placeholder")
            else:
                 initial_value_text = existing_data.get('value', '')
        else: # (ADDED) For 'random' or 'sequential', join the list with newlines
            initial_value_text = "\n".join(existing_data.get('values', []))
        self.value_var_text = initial_value_text # (COMMENT) We use this to populate the text widget directly
        self.is_secret_var = BooleanVar(value=existing_data.get('is_secret', False))
        self.mode_var = StringVar(value=initial_mode)
        main_frame = ttk.Frame(self, padding=20)
        main_frame.pack(fill="both", expand=True)
        name_label = ttk.Label(main_frame, text=self.loc.get("settings_variables_dialog_name", fallback="Name:"))
        name_label.grid(row=0, column=0, columnspan=2, padx=5, pady=5, sticky="w")
        self.name_entry = ttk.Entry(main_frame, textvariable=self.name_var, width=50)
        self.name_entry.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        if existing_name:
            self.name_entry.config(state="readonly")
        value_label = ttk.Label(main_frame, text=self.loc.get("settings_variables_dialog_value", fallback="Value:"))
        value_label.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="w")
        self.value_entry = scrolledtext.ScrolledText(main_frame, width=50, height=8, wrap="word")
        self.value_entry.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        self.value_entry.insert("1.0", self.value_var_text)
        options_frame = ttk.Frame(main_frame)
        options_frame.grid(row=4, column=0, columnspan=2, pady=(10,0), sticky="ew")
        secret_check = ttk.Checkbutton(options_frame, text=self.loc.get("settings_variables_dialog_secret_check", fallback="Mask this value (secret)"), variable=self.is_secret_var)
        secret_check.pack(side="left", anchor="w")
        if existing_name:
            secret_check.config(state="disabled")
        mode_combo = ttk.Combobox(options_frame, textvariable=self.mode_var, values=["single", "random", "sequential"], state="readonly", width=12)
        mode_combo.pack(side="right", anchor="e")
        ttk.Label(options_frame, text="Retrieval Mode:").pack(side="right", padx=(0, 5)) # English Hardcode
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=5, column=0, columnspan=2, pady=(20,0), sticky="e")
        ok_button = ttk.Button(button_frame, text=self.loc.get("button_save", fallback="Save"), command=self._on_ok, bootstyle="success")
        ok_button.pack(side="right", padx=5)
        cancel_button = ttk.Button(button_frame, text=self.loc.get("button_cancel", fallback="Cancel"), command=self.destroy, bootstyle="secondary")
        cancel_button.pack(side="right")
        self.wait_window(self)
    def _on_ok(self):
        name = self.name_var.get().strip().upper()
        value_str = self.value_entry.get("1.0", "end-1c").strip()
        is_secret = self.is_secret_var.get()
        mode = self.mode_var.get()
        if not name:
            messagebox.showerror(self.loc.get("messagebox_error_title", fallback="Error"), self.loc.get("settings_variables_warn_name_empty", fallback="Name cannot be empty."), parent=self)
            return
        if not name.replace('_', '').isalnum():
            messagebox.showerror(self.loc.get("messagebox_error_title", fallback="Error"), self.loc.get("settings_variables_warn_name_format"), parent=self)
            return
        if value_str == "" or (self.name_entry.cget('state') == 'readonly' and value_str == self.loc.get("settings_variables_dialog_secret_placeholder")):
             messagebox.showerror(self.loc.get("messagebox_error_title", fallback="Error"), self.loc.get("settings_variables_warn_value_empty", fallback="Value cannot be empty."), parent=self)
             return
        final_value = None
        if mode == 'single':
            if '\n' in value_str:
                messagebox.showerror(self.loc.get("messagebox_error_title", fallback="Error"), "Single value mode cannot contain multiple lines.", parent=self)
                return
            final_value = value_str
        else: # random or sequential
            final_value = [line.strip() for line in value_str.split('\n') if line.strip()]
            if not final_value:
                messagebox.showerror(self.loc.get("messagebox_error_title", fallback="Error"), "Please provide at least one value for the pool.", parent=self)
                return
        self.result = (name, final_value, is_secret, mode)
        self.destroy()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\settings_components\variable_manager_frame.py
# JUMLAH BARIS : 163
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import messagebox
from .variable_dialog import VariableDialog
import threading
import base64
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class VariableManagerFrame(ttk.LabelFrame):
    def __init__(self, parent, kernel):
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        super().__init__(parent, text=self.loc.get("settings_variables_title", fallback="Variable & Secret Management"), padding=15)
        self.variables_data_cache = []
        self.api_client = ApiClient(kernel=self.kernel)
        self._build_widgets()
        self.load_variables_to_ui()
    def _build_widgets(self):
        self.columnconfigure(0, weight=1)
        self.rowconfigure(0, weight=1)
        tree_frame = ttk.Frame(self)
        tree_frame.grid(row=0, column=0, sticky="nsew", columnspan=3)
        tree_frame.columnconfigure(0, weight=1)
        tree_frame.rowconfigure(0, weight=1)
        columns = ("name", "value", "status")
        self.var_tree = ttk.Treeview(tree_frame, columns=columns, show="headings", height=10)
        self.var_tree.heading("name", text=self.loc.get("settings_variables_col_name", fallback="Variable Name"))
        self.var_tree.heading("value", text=self.loc.get("settings_variables_col_value", fallback="Value"))
        self.var_tree.heading("status", text=self.loc.get("settings_variables_col_status", fallback="Status"))
        self.var_tree.column("name", width=150, anchor="w")
        self.var_tree.column("value", width=300, anchor="w")
        self.var_tree.column("status", width=80, anchor="center")
        vsb = ttk.Scrollbar(tree_frame, orient="vertical", command=self.var_tree.yview)
        hsb = ttk.Scrollbar(tree_frame, orient="horizontal", command=self.var_tree.xview)
        self.var_tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        self.var_tree.grid(row=0, column=0, sticky="nsew")
        vsb.grid(row=0, column=1, sticky="ns")
        hsb.grid(row=1, column=0, sticky="ew")
        button_frame = ttk.Frame(self)
        button_frame.grid(row=1, column=0, columnspan=3, sticky="ew", pady=(10,0))
        add_button = ttk.Button(button_frame, text=self.loc.get("settings_variables_btn_add", fallback="Add"), command=self._add_variable)
        add_button.pack(side="left", padx=5)
        edit_button = ttk.Button(button_frame, text=self.loc.get("settings_variables_btn_edit", fallback="Edit"), command=self._edit_variable, bootstyle="info")
        edit_button.pack(side="left", padx=5)
        self.toggle_button = ttk.Button(button_frame, text=self.loc.get("settings_variables_btn_disable", fallback="Disable"), command=self._toggle_variable_state, bootstyle="warning")
        self.toggle_button.pack(side="left", padx=5)
        delete_button = ttk.Button(button_frame, text=self.loc.get("settings_variables_btn_delete", fallback="Delete"), command=self._delete_variable, bootstyle="danger")
        delete_button.pack(side="left", padx=5)
        copy_button = ttk.Button(button_frame, text=self.loc.get("settings_variables_action_copy", fallback="[ Copy ]"), command=self._copy_variable_placeholder, bootstyle="secondary-outline")
        copy_button.pack(side="right", padx=5)
        self.var_tree.bind('<<TreeviewSelect>>', self._update_button_state)
    def load_variables_to_ui(self):
        for item in self.var_tree.get_children():
            self.var_tree.delete(item)
        threading.Thread(target=self._load_variables_worker, daemon=True).start()
    def _load_variables_worker(self):
        success, data = self.api_client.get_variables()
        self.after(0, self._populate_tree_from_data, success, data)
    def _populate_tree_from_data(self, success, data):
        for item in self.var_tree.get_children():
            self.var_tree.delete(item)
        if success:
            self.variables_data_cache = data
            for var_data in self.variables_data_cache:
                is_enabled = var_data.get('is_enabled', True)
                status_text = self.loc.get("status_enabled") if is_enabled else self.loc.get("status_disabled")
                value_for_display = ""
                mode = var_data.get('mode', 'single')
                if mode != 'single':
                    count = len(var_data.get('values', []))
                    value_for_display = f"[Pool: {count} keys] - Mode: {mode.capitalize()}"
                elif var_data.get('is_secret'):
                    value_for_display = '*****'
                else:
                    value_for_display = var_data.get('value')
                tags = ('secret' if var_data.get('is_secret') else 'normal',)
                if not is_enabled:
                    tags += ('disabled',)
                self.var_tree.insert("", "end", iid=var_data["name"], values=(var_data["name"], value_for_display, status_text), tags=tags)
        else:
            messagebox.showerror(self.loc.get("messagebox_error_title"), f"Failed to load variables from API: {data}")
        self.var_tree.tag_configure('secret', foreground='orange')
        self.var_tree.tag_configure('disabled', foreground='grey')
        self._update_button_state()
    def _add_variable(self):
        dialog = VariableDialog(self, title=self.loc.get("settings_variables_dialog_add_title", fallback="Add New Variable"), kernel=self.kernel)
        if dialog.result:
            name, value, is_secret, mode = dialog.result
            success, response = self.api_client.update_variable(name, value, is_secret, is_enabled=True, mode=mode)
            if success:
                self.load_variables_to_ui()
            else:
                messagebox.showerror(self.loc.get("messagebox_error_title"), f"API Error: {response}")
    def _edit_variable(self):
        selected_item = self.var_tree.focus()
        if not selected_item:
            messagebox.showwarning(self.loc.get("messagebox_warning_title"), self.loc.get("settings_variables_warn_select_to_edit"), parent=self)
            return
        var_name = selected_item
        var_backend_data = next((vc for vc in self.variables_data_cache if vc['name'] == var_name), None)
        if not var_backend_data:
            messagebox.showerror(self.loc.get("messagebox_error_title"), "Could not find variable data to edit. Please refresh.")
            return
        dialog = VariableDialog(self, title=self.loc.get("settings_variables_dialog_edit_title"), kernel=self.kernel, existing_name=var_name, existing_data=var_backend_data)
        if dialog.result:
            _name, value, is_secret, mode = dialog.result
            success, response = self.api_client.update_variable(var_name, value, is_secret, var_backend_data.get('is_enabled', True), mode=mode)
            if success:
                self.load_variables_to_ui()
            else:
                messagebox.showerror(self.loc.get("messagebox_error_title"), f"API Error: {response}")
    def _toggle_variable_state(self):
        selected_item = self.var_tree.focus()
        if not selected_item: return
        var_name = selected_item
        var_cache = next((vc for vc in self.variables_data_cache if vc['name'] == var_name), None)
        if not var_cache: return
        new_state = not var_cache.get('is_enabled', True)
        success, response = self.api_client.update_variable_state(var_name, new_state)
        if success:
            self.load_variables_to_ui()
        else:
            messagebox.showerror(self.loc.get("messagebox_error_title"), f"API Error: {response}")
    def _update_button_state(self, event=None):
        selected_item = self.var_tree.focus()
        if not selected_item:
            self.toggle_button.config(state="disabled")
            return
        self.toggle_button.config(state="normal")
        var_cache = next((vc for vc in self.variables_data_cache if vc['name'] == selected_item), None)
        if var_cache:
            if var_cache.get('is_enabled', True):
                self.toggle_button.config(text=self.loc.get("settings_variables_btn_disable", fallback="Disable"))
            else:
                self.toggle_button.config(text=self.loc.get("settings_variables_btn_enable", fallback="Enable"))
    def _delete_variable(self):
        selected_item = self.var_tree.focus()
        if not selected_item:
            messagebox.showwarning(self.loc.get("messagebox_warning_title"), self.loc.get("settings_variables_warn_select_to_delete"), parent=self)
            return
        var_name = selected_item
        if messagebox.askyesno(self.loc.get("messagebox_confirm_title"), self.loc.get("settings_variables_confirm_delete", var_name=var_name), parent=self):
            success, response = self.api_client.delete_variable(var_name)
            if success:
                self.load_variables_to_ui()
            else:
                 messagebox.showerror(self.loc.get("messagebox_error_title"), f"API Error: {response}")
    def _copy_variable_placeholder(self):
        selected_item = self.var_tree.focus()
        if not selected_item:
            messagebox.showwarning(self.loc.get("messagebox_warning_title"), self.loc.get("settings_variables_warn_select_to_copy"), parent=self)
            return
        var_name = selected_item
        placeholder = f"{{{{vars.{var_name}}}}}"
        self.clipboard_clear()
        self.clipboard_append(placeholder)
        self.kernel.write_to_log(self.loc.get("settings_variables_copy_success", fallback=f"Placeholder '{placeholder}' has been copied to clipboard."), "SUCCESS")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\flowork_core_ui\settings_components\webhook_settings_frame.py
# JUMLAH BARIS : 41
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, BooleanVar
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class WebhookSettingsFrame(ttk.LabelFrame):
    def __init__(self, parent, kernel):
        self.api_client = ApiClient()
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        super().__init__(parent, text=self.loc.get("settings_webhook_title", fallback="Webhook Settings"), padding=15)
        self.webhook_enabled_var = BooleanVar()
        self.webhook_port_var = StringVar()
        self._build_widgets()
    def _build_widgets(self):
        webhook_check = ttk.Checkbutton(self, text=self.loc.get("settings_webhook_enable_label", fallback="Enable Webhook/API Server"), variable=self.webhook_enabled_var)
        webhook_check.grid(row=0, column=0, columnspan=2, padx=5, pady=5, sticky="w")
        port_label = ttk.Label(self, text=self.loc.get("settings_webhook_port_label", fallback="Server Port:"))
        port_label.grid(row=1, column=0, padx=5, pady=5, sticky="w")
        port_entry = ttk.Entry(self, textvariable=self.webhook_port_var, width=10)
        port_entry.grid(row=1, column=1, padx=5, pady=5, sticky="w")
    def load_settings_data(self, settings_data):
        """Loads webhook settings from the provided data dictionary."""
        self.webhook_enabled_var.set(settings_data.get("webhook_enabled", False))
        self.webhook_port_var.set(str(settings_data.get("webhook_port", 8989)))
    def get_settings_data(self) -> dict:
        """Returns the current webhook settings from the UI."""
        try:
            port = int(self.webhook_port_var.get())
            return {
                "webhook_enabled": self.webhook_enabled_var.get(),
                "webhook_port": port
            }
        except ValueError:
            raise ValueError("Port must be a valid number.")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\metrics_dashboard\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "908560da1d25d541e53af52ca375ab80437cf7ac27d93dcbb982702d1544c127",
    "manifest_hash": "ff97f23f0ae51e2df442a4cb542943aa2ea721024e8ada32d6021e292a00cbe5",
    "timestamp": 1757229842.8362782
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\metrics_dashboard\manifest.json
# JUMLAH BARIS : 21
#######################################################################

```json
{
    "id": "metrics_dashboard",
    "name": "Plugin Dashboard Metrik",
    "version": "1.0",
    "icon_file": "icon.png",
    "author": "Awenk Audico",
    "email": "Contributor@teetah.art",
    "website": "www.teetah.art",
    "description": "Menyediakan UI dashboard untuk menampilkan metrik sistem.",
    "type": "ACTION",
    "entry_point": "processor.MetricsDashboardModule",
    "requires_services": [
        "logger",
        "loc",
        "state_manager",
        "kernel"
    ],
    "permissions": [
        "ui_provider"
    ]
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\metrics_dashboard\processor.py
# JUMLAH BARIS : 51
#######################################################################

```py
from api_contract import BaseModule, BaseUIProvider # PENAMBAHAN OTOMATIS
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class MetricsDashboardModule(BaseModule, BaseUIProvider):
    TIER = "free"  # ADDED BY SCANNER: Default tier
    """
    Plugin yang menyediakan UI untuk menampilkan metrik eksekusi workflow.
    """
    def __init__(self, module_id, services):
        self.api_client = ApiClient()
        super().__init__(module_id, services)
        self.kernel.write_to_log(f"Plugin Dashboard Metrik ({self.module_id}) berhasil diinisialisasi.", "SUCCESS")
    def execute(self, payload, config, status_updater, ui_callback, mode='EXECUTE'):
        status_updater("Tidak ada aksi", "INFO")
        return payload
    def get_ui_tabs(self):
        """
        Mendaftarkan halaman dashboard metrik ke Kernel.
        """
        self.kernel.write_to_log(f"MetricsDashboard: Kernel meminta tab UI dari saya.", "DEBUG")
        return []
        """
        return [
            {
                'key': 'metrics_dashboard',
                'title': self.loc.get('metrics_dashboard_title', fallback="Dashboard Metrik"),
                'frame_class': MetricsDashboardView
            }
        ]
        """
    def get_menu_items(self):
        """
        Menambahkan item menu untuk membuka dashboard metrik.
        """
        return []
        """
        return [
            {
                "parent": "Bantuan",
                "label": self.loc.get('menu_open_metrics_dashboard', fallback="Buka Dashboard Metrik"),
                "command": lambda: self.kernel.create_ui_tab_by_key('metrics_dashboard')
            }
        ]
        """
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\metrics_dashboard\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "908560da1d25d541e53af52ca375ab80437cf7ac27d93dcbb982702d1544c127",
    "manifest_hash": "ff97f23f0ae51e2df442a4cb542943aa2ea721024e8ada32d6021e292a00cbe5",
    "timestamp": 1757204699.3778577
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\metrics_dashboard\locales\en.json
# JUMLAH BARIS : 3
#######################################################################

```json
{
    "metrics_dashboard_title": "System Metrics Dashboard"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\metrics_dashboard\locales\id.json
# JUMLAH BARIS : 3
#######################################################################

```json
{
    "metrics_dashboard_title": "Dasbor Metrik Sistem"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\metrics_logger_plugin\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "d535e0d2d07c26d849d25c6d43481d9dcfcbc4072fc8e004d992b9e10eef6604",
    "manifest_hash": "2497694a9532a6470a51043e76ea56077cdd620b3e41e097752a87910c4c1667",
    "timestamp": 1757229847.4522552
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\metrics_logger_plugin\manifest.json
# JUMLAH BARIS : 17
#######################################################################

```json
{
    "id": "metrics_logger_plugin",
    "name": "Metrics Logger Service",
    "version": "1.0",
    "icon_file": "icon.png",
    "author": "awenk audico & gemini",
    "email": "Contributor@teetah.art",
    "website": "www.teetah.art",
    "description": "A service plugin that listens to metric updates and logs them for historical analysis.",
    "type": "SERVICE",
    "entry_point": "metrics_logger.MetricsLogger",
    "requires_services": [
        "kernel",
        "event_bus"
    ],
    "is_service": true
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\metrics_logger_plugin\metrics_logger.py
# JUMLAH BARIS : 46
#######################################################################

```py
import os
import json
import time
from api_contract import BaseModule # PENAMBAHAN OTOMATIS
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class MetricsLogger(BaseModule):
    TIER = "free"  # ADDED BY SCANNER: Default tier
    """
    Service that runs in the background, listens for NODE_EXECUTION_METRIC events,
    and logs them to a file for later analysis by other widgets.
    """
    def __init__(self, module_id, services):
        self.api_client = ApiClient()
        super().__init__(module_id, services)
        self.history_file_path = os.path.join(self.kernel.data_path, "metrics_history.jsonl")
    def on_load(self):
        """When the plugin loads, subscribe to the event bus."""
        self.logger("Metrics Logger: Ready to record detailed execution metrics.", "INFO")
        self.event_bus.subscribe(
            event_name="NODE_EXECUTION_METRIC",
            subscriber_id=self.module_id,
            callback=self.on_metrics_updated
        )
    def on_metrics_updated(self, metrics_data):
        """
        Callback executed whenever a NODE_EXECUTION_METRIC event occurs.
        """
        log_entry = {
            "timestamp": time.time(),
            "metrics": metrics_data
        }
        try:
            with open(self.history_file_path, 'a', encoding='utf-8') as f:
                f.write(json.dumps(log_entry) + '\n')
        except Exception as e:
            self.logger(f"Metrics Logger: Failed to write to history file: {e}", "ERROR")
    def execute(self, payload, config, status_updater, ui_callback, mode):
        return payload
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\plugins\metrics_logger_plugin\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "d535e0d2d07c26d849d25c6d43481d9dcfcbc4072fc8e004d992b9e10eef6604",
    "manifest_hash": "2497694a9532a6470a51043e76ea56077cdd620b3e41e097752a87910c4c1667",
    "timestamp": 1757204703.6979885
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\scanners\diagnostics_page.py
# JUMLAH BARIS : 110
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import scrolledtext, BooleanVar, messagebox
import os
import re
import threading
import time
import json
from views.custom_widgets.scrolled_frame import ScrolledFrame
from api_client.client import ApiClient
class DiagnosticsPage(ttk.Frame):
    """
    The main UI frame for the System Diagnostics tab.
    This is the GUI-side representation.
    """
    def __init__(self, parent_notebook, api_client, loc_service, tab_id=None, is_new_tab=False):
        super().__init__(parent_notebook, padding=0)
        self.api_client = api_client
        self.loc = loc_service
        self.scanner_vars = {}
        self.animation_labels = {}
        self.animation_jobs = {}
        self.animation_frames = ['|', '/', '-', '\\']
        self._all_report_entries = []
        self.filter_vars = {
            'CRITICAL': BooleanVar(value=True),
            'MAJOR': BooleanVar(value=True),
            'MINOR': BooleanVar(value=True),
            'INFO': BooleanVar(value=True),
            'SCAN': BooleanVar(value=True),
            'OK': BooleanVar(value=True)
        }
        self.guide_is_pinned = False
        self.hide_guide_job = None
        self._build_ui()
        self._populate_guide()
    def _apply_markdown_to_text_widget(self, text_widget, content):
        text_widget.config(state="normal")
        text_widget.delete("1.0", "end")
        parts = re.split(r'(\*\*.*?\*\*)', content)
        for part in parts:
            if part.startswith('**') and part.endswith('**'):
                text_widget.insert("end", part[2:-2], "bold")
            else:
                text_widget.insert("end", part)
        text_widget.config(state="disabled")
    def _populate_guide(self):
        guide_content = self.loc.get("diagnostics_guide_content")
        self._apply_markdown_to_text_widget(self.guide_text, guide_content)
        self.guide_text.tag_configure("bold", font="-size 9 -weight bold")
    def _build_ui(self):
        main_content_frame = ttk.Frame(self, padding=15)
        main_content_frame.place(relx=0, rely=0, relwidth=1, relheight=1)
        ttk.Label(main_content_frame, text="Diagnostics Page", font=("Helvetica", 16, "bold")).pack(pady=10)
        ttk.Label(main_content_frame, text="This feature is being re-integrated.", wraplength=400).pack(pady=10)
        self.run_all_button = ttk.Button(main_content_frame, text=self.loc.get('diagnostics_run_all_button', fallback="Run All Scanners"), command=self._start_scan_thread, bootstyle="success")
        self.run_all_button.pack(pady=20, ipady=10)
        self.report_text = scrolledtext.ScrolledText(main_content_frame, wrap='word', state='disabled', font=("Consolas", 9))
        self.report_text.pack(fill='both', expand=True, padx=10, pady=(0,10))
    def _start_scan_thread(self):
        self.run_all_button.config(state="disabled")
        self.report_text.config(state='normal')
        self.report_text.delete('1.0', 'end')
        self.report_text.insert('1.0', "Sending scan request to the server...\n")
        self.report_text.config(state='disabled')
        threading.Thread(target=self._scan_worker, daemon=True).start()
    def _scan_worker(self):
        success, response = self.api_client.trigger_scan_by_api()
        if success:
            job_id = response.get('job_id')
            self.after(0, self._add_report_line, f"Scan job started with ID: {job_id}\nChecking status periodically...\n", "INFO")
            self.after(2000, self._check_scan_status, job_id)
        else:
            self.after(0, self._add_report_line, f"Failed to start scan: {response}", "ERROR")
            self.after(0, lambda: self.run_all_button.config(state="normal"))
    def _check_scan_status(self, job_id):
        success, response = self.api_client.get_job_status(job_id)
        if success:
            status = response.get('status')
            if status in ["QUEUED", "RUNNING"]:
                self.after(5000, self._check_scan_status, job_id) # Check again in 5 seconds
            elif status == "COMPLETED":
                result = response.get('result', {})
                summary = result.get('summary', 'No summary.')
                full_log = result.get('full_log', 'No full log.')
                report = f"--- SCAN COMPLETE ---\n\nSUMMARY:\n{summary}\n\nFULL LOG:\n{full_log}"
                self.after(0, self._add_report_line, report, "SUCCESS")
                self.after(0, lambda: self.run_all_button.config(state="normal"))
            elif status == "FAILED":
                error = response.get('error', 'Unknown error.')
                self.after(0, self._add_report_line, f"SCAN FAILED: {error}", "ERROR")
                self.after(0, lambda: self.run_all_button.config(state="normal"))
        else:
            self.after(0, self._add_report_line, f"Failed to get scan status: {response}", "ERROR")
            self.after(0, lambda: self.run_all_button.config(state="normal"))
    def _add_report_line(self, message, level="INFO"):
        if not self.winfo_exists(): return
        self.report_text.config(state='normal')
        self.report_text.insert('end', f"[{level}] {message}\n")
        self.report_text.see('end')
        self.report_text.config(state='disabled')
    def _populate_guide(self):
        pass
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\utils\performance_logger.py
# JUMLAH BARIS : 26
#######################################################################

```py
import time
from functools import wraps
def log_performance(log_message: str):
    """
    A decorator that logs the execution time of a function.
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.perf_counter()
            result = func(*args, **kwargs)
            end_time = time.perf_counter()
            duration_ms = (end_time - start_time) * 1000
            log_entry = f"PERF-GUI: {log_message} - Execution Time: {duration_ms:.2f} ms"
            print(log_entry) # Simple print for GUI-side logging
            return result
        return wrapper
    return decorator
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\authentication_dialog.py
# JUMLAH BARIS : 138
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import messagebox, simpledialog # (DITAMBAHKAN)
import threading
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class AuthenticationDialog(ttk.Toplevel):
    """
    A single dialog window that handles both Login and Registration forms.
    (MODIFIED) Now stores user data in the kernel and publishes an event on successful login.
    """
    def __init__(self, parent, kernel):
        super().__init__(parent)
        self.kernel = kernel
        self.api_client = ApiClient(kernel=self.kernel)
        self.title("Login or Register")
        self.geometry("400x520") # (MODIFIKASI) Ditinggikan sedikit untuk tombol baru
        self.resizable(False, False)
        self.transient(parent)
        self.grab_set()
        self.login_email_var = ttk.StringVar()
        self.login_password_var = ttk.StringVar()
        self.reg_username_var = ttk.StringVar()
        self.reg_email_var = ttk.StringVar()
        self.reg_password_var = ttk.StringVar()
        self.container = ttk.Frame(self)
        self.container.pack(fill="both", expand=True)
        self.login_frame = self._create_login_frame(self.container)
        self.register_frame = self._create_register_frame(self.container)
        self.show_login()
        self.wait_window()
    def show_login(self):
        self.register_frame.pack_forget()
        self.login_frame.pack(fill="both", expand=True)
    def show_register(self):
        self.login_frame.pack_forget()
        self.register_frame.pack(fill="both", expand=True)
    def _create_login_frame(self, parent):
        frame = ttk.Frame(parent, padding=40)
        ttk.Label(frame, text="FLOWORK", font=("-size 24 -weight bold"), bootstyle="primary").pack(pady=(0, 10))
        ttk.Label(frame, text="Welcome Back!", font=("-size 12"), bootstyle="secondary").pack(pady=(0, 30))
        ttk.Label(frame, text="Email", font=("-size 10")).pack(fill="x", pady=(0,2))
        ttk.Entry(frame, textvariable=self.login_email_var).pack(fill="x", pady=(0,15))
        ttk.Label(frame, text="Password", font=("-size 10")).pack(fill="x", pady=(0,2))
        ttk.Entry(frame, textvariable=self.login_password_var, show="*").pack(fill="x", pady=(0,25))
        self.login_button = ttk.Button(frame, text="Login", command=self._perform_login_thread, bootstyle="primary")
        self.login_button.pack(fill="x", ipady=8, pady=(0,10))
        links_frame = ttk.Frame(frame)
        links_frame.pack(fill='x', pady=5)
        register_link = ttk.Button(links_frame, text="Don't have an account? Register", command=self.show_register, bootstyle="link-secondary")
        register_link.pack(side="left")
        forgot_password_link = ttk.Button(links_frame, text="Forgot Password?", command=self._prompt_for_password_reset, bootstyle="link-primary")
        forgot_password_link.pack(side="right")
        return frame
    def _create_register_frame(self, parent):
        frame = ttk.Frame(parent, padding=40)
        ttk.Label(frame, text="Create Account", font=("-size 24 -weight bold"), bootstyle="success").pack(pady=(0, 20))
        ttk.Label(frame, text="Username:", font=("-size 10")).pack(fill="x", pady=(0,2))
        ttk.Entry(frame, textvariable=self.reg_username_var).pack(fill="x", pady=(0,10))
        ttk.Label(frame, text="Email:", font=("-size 10")).pack(fill="x", pady=(0,2))
        ttk.Entry(frame, textvariable=self.reg_email_var).pack(fill="x", pady=(0,10))
        ttk.Label(frame, text="Password:", font=("-size 10")).pack(fill="x", pady=(0,2))
        ttk.Entry(frame, textvariable=self.reg_password_var, show="*").pack(fill="x", pady=(0,20))
        self.register_button = ttk.Button(frame, text="Register", command=self._perform_register_thread, bootstyle="success")
        self.register_button.pack(fill="x", ipady=8, pady=(0,10))
        login_link = ttk.Button(frame, text="Already have an account? Login", command=self.show_login, bootstyle="link-secondary")
        login_link.pack()
        return frame
    def _prompt_for_password_reset(self):
        """Asks the user for their email to send a reset link."""
        email = simpledialog.askstring("Password Reset", "Please enter your registered email address:", parent=self)
        if email and email.strip():
            threading.Thread(target=self._perform_password_reset, args=(email.strip(),), daemon=True).start()
    def _perform_password_reset(self, email):
        """Calls the API client to initiate the password reset process."""
        self.kernel.write_to_log(f"Initiating password reset for email: {email}", "INFO")
        success, response = self.api_client.forgot_password(email)
        self.after(0, messagebox.showinfo, "Request Sent", "If an account exists for that email, a password reset link has been sent.")
    def _perform_login_thread(self):
        self.login_button.config(state="disabled", text="Logging in...")
        threading.Thread(target=self._perform_login, daemon=True).start()
    def _perform_login(self):
        email = self.login_email_var.get().strip()
        password = self.login_password_var.get().strip()
        if not email or not password:
            self.after(0, self._on_login_failed, "Email and Password are required.")
            return
        success, response = self.api_client.login_user(email, password)
        if success:
            response['email'] = email
            self.after(0, self._on_login_success, response)
        else:
            self.after(0, self._on_login_failed, response)
    def _on_login_success(self, login_data):
        self.kernel.write_to_log(f"User '{self.login_email_var.get()}' logged in successfully.", "SUCCESS")
        self.kernel.current_user = login_data
        user_tier = login_data.get('tier', 'free')
        self.kernel.license_tier = user_tier
        self.kernel.is_premium = self.kernel.TIER_HIERARCHY.get(user_tier, 0) > 0
        state_manager = self.kernel.get_service("state_manager")
        if state_manager:
            state_manager.set("user_session_token", login_data.get('session_token'))
        event_bus = self.kernel.get_service("event_bus")
        if event_bus:
            event_bus.publish("USER_LOGGED_IN", login_data)
        messagebox.showinfo("Login Success", f"Welcome back! You are logged in with '{user_tier}' tier access.", parent=self.master)
        self.destroy()
    def _on_login_failed(self, error_message):
        messagebox.showerror("Login Failed", f"Error: {error_message}", parent=self)
        self.login_button.config(state="normal", text="Login")
    def _perform_register_thread(self):
        self.register_button.config(state="disabled", text="Registering...")
        threading.Thread(target=self._perform_register, daemon=True).start()
    def _perform_register(self):
        username = self.reg_username_var.get().strip()
        email = self.reg_email_var.get().strip()
        password = self.reg_password_var.get().strip()
        if not all([username, email, password]):
            self.after(0, self._on_register_failed, "All fields are required.")
            return
        success, response = self.api_client.register_user(username, email, password)
        if success:
            self.after(0, self._on_register_success)
        else:
            self.after(0, self._on_register_failed, response)
    def _on_register_success(self):
        self.register_button.config(state="normal", text="Register")
        messagebox.showinfo("Success", "Registration successful! You can now log in.", parent=self)
        self.show_login()
    def _on_register_failed(self, error_message):
        messagebox.showerror("Registration Failed", f"Error: {error_message}", parent=self)
        self.register_button.config(state="normal", text="Register")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\canvas_manager.py
# JUMLAH BARIS : 229
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import Menu, messagebox, TclError, Text, simpledialog, scrolledtext
import uuid
import json
import re
from .properties_popup import PropertiesPopup # MODIFIED: Corrected relative import
from .custom_widgets.tooltip import ToolTip # MODIFIED: Corrected relative import
from api_contract import LoopConfig, EnumVarWrapper
from .canvas_components.node_manager import NodeManager
from .canvas_components.connection_manager import ConnectionManager
from .canvas_components.interaction_manager import InteractionManager
from .canvas_components.visual_manager import VisualManager
from .canvas_components.properties_manager import PropertiesManager
from api_client.client import ApiClient
class _TextEditorPopup(ttk.Toplevel):
    """A custom Toplevel window for multi-line text input."""
    def __init__(self, parent, loc_service, title, prompt, initial_text=""):
        super().__init__(parent)
        self.loc = loc_service
        self.title(title)
        self.result = None
        main_frame = ttk.Frame(self, padding=15)
        main_frame.pack(fill="both", expand=True)
        ttk.Label(main_frame, text=prompt, wraplength=380).pack(fill='x', pady=(0, 10))
        self.text_widget = scrolledtext.ScrolledText(main_frame, wrap="word", height=10, width=50)
        self.text_widget.pack(fill="both", expand=True)
        self.text_widget.insert("1.0", initial_text)
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill='x', pady=(10, 0))
        ttk.Button(button_frame, text=self.loc.get('button_save', fallback="Save"), command=self._on_save, bootstyle="success").pack(side="right")
        ttk.Button(button_frame, text=self.loc.get('button_cancel', fallback="Cancel"), command=self.destroy, bootstyle="secondary").pack(side="right", padx=(0, 10))
        self.transient(parent)
        self.grab_set()
        self.wait_window(self)
    def _on_save(self):
        self.result = self.text_widget.get("1.0", "end-1c")
        self.destroy()
class CanvasManager:
    """
    Manages all specialized managers for the canvas.
    Holds the primary state (nodes, connections, labels) and delegates tasks.
    """
    def __init__(self, visual_container, coordinator_tab, canvas_widget, kernel):
        self.parent_widget = visual_container
        self.coordinator_tab = coordinator_tab
        self.canvas = canvas_widget
        self.kernel = kernel
        self.loc = self.kernel.loc
        self.canvas_nodes = {}
        self.canvas_connections = {}
        self.canvas_labels = {}
        self.tooltips = {}
        self.selected_node_id = None
        self.colors = {} # ADDED: Using fallback
        self.node_manager = NodeManager(self, self.kernel, self.canvas)
        self.connection_manager = ConnectionManager(self, self.kernel, self.canvas)
        self.interaction_manager = InteractionManager(self, self.kernel, self.canvas)
        self.visual_manager = VisualManager(self, self.kernel, self.canvas)
        self.properties_manager = PropertiesManager(self, self.kernel)
        self.interaction_manager.bind_events()
        self.visual_manager.draw_watermark()
    def _apply_markdown_to_text_widget(self, text_widget, content):
        text_widget.config(state="normal")
        text_widget.delete("1.0", "end")
        parts = re.split(r'(\*\*.*?\*\*)', content)
        for part in parts:
            if part.startswith('**') and part.endswith('**'):
                text_widget.insert("end", part[2:-2], "bold")
            else:
                text_widget.insert("end", part)
        text_widget.config(state="disabled")
    def get_workflow_data(self):
        nodes_data = [{"id": n_id, "name": d["name"], "x": d["x"], "y": d["y"], "description": d.get("description", ""), "module_id": d.get("module_id"), "config_values": d.get("config_values", {})} for n_id, d in self.canvas_nodes.items()]
        connections_data = [
            {
                "id": c_id,
                "from": d["from"],
                "to": d["to"],
                "source_port_name": d.get("source_port_name"),
                "target_port_name": d.get("target_port_name"),
                "type": d.get("type", "data")
            } for c_id, d in self.canvas_connections.items()
        ]
        labels_data = [{"id": l_id, "text": d["text"], "x": d["x"], "y": d["y"], "width": d["widget"].winfo_width(), "height": d["widget"].winfo_height()} for l_id, d in self.canvas_labels.items()]
        return {"nodes": nodes_data, "connections": connections_data, "labels": labels_data}
    def load_workflow_data(self, workflow_data):
        self.clear_canvas(feedback=False)
        for node_data in workflow_data.get("nodes", []):
            self.node_manager.create_node_on_canvas(
                name=node_data.get("name"),
                x=node_data.get("x"),
                y=node_data.get("y"),
                existing_id=node_data.get("id"),
                description=node_data.get("description", ""),
                module_id=node_data.get("module_id"),
                config_values=node_data.get("config_values")
            )
        for label_data in workflow_data.get("labels", []):
            self.create_label(
                x=label_data.get("x"),
                y=label_data.get("y"),
                text=label_data.get("text"),
                existing_id=label_data.get("id"),
                width=label_data.get("width", 200),
                height=label_data.get("height", 80)
            )
        self.coordinator_tab.after(50, lambda: self.connection_manager.recreate_connections(workflow_data.get("connections", [])))
        if not self.canvas_nodes and not self.canvas_labels:
            self.visual_manager.draw_watermark()
    def clear_canvas(self, feedback=True):
        if self.coordinator_tab._execution_state != "IDLE":
            messagebox.showwarning("Action Denied", "Cannot clear the canvas while a workflow is running.") # English Hardcode
            return
        if feedback: print("INFO: Clearing the canvas...") # English Log
        for node_id in list(self.canvas_nodes.keys()):
            self.node_manager.delete_node(node_id, feedback=False)
        for label_id in list(self.canvas_labels.keys()):
            self.delete_label(label_id, feedback=False)
        self.canvas.delete("all")
        self.visual_manager.draw_grid()
        if self.interaction_manager:
            self.interaction_manager._reset_all_actions()
        self.canvas_nodes.clear()
        self.canvas_connections.clear()
        self.canvas_labels.clear()
        self.selected_node_id = None
        self.visual_manager.draw_watermark()
    def create_label(self, x, y, text=None, existing_id=None, width=200, height=80):
        label_id = existing_id or str(uuid.uuid4())
        initial_text = text or self.loc.get('canvas_new_label_text', fallback="Double click to edit...")
        label_frame = ttk.Frame(self.canvas, width=width, height=height, style="success.TFrame", borderwidth=1, relief="solid")
        label_frame.pack_propagate(False)
        text_widget = ttk.Text(label_frame, wrap="word", relief="flat", borderwidth=0,
                               foreground="black", background="#D4EDDA",
                               font=("Helvetica", 10, "normal"),
                               padx=5, pady=5)
        text_widget.pack(fill="both", expand=True)
        text_widget.tag_configure("bold", font=("Helvetica", 10, "bold"))
        self._apply_markdown_to_text_widget(text_widget, initial_text)
        sizegrip = ttk.Sizegrip(label_frame, style='success.TSizegrip')
        sizegrip.place(relx=1.0, rely=1.0, anchor="se")
        self.canvas.create_window(x, y, window=label_frame, anchor="nw", tags=("label_widget", label_id))
        self.canvas_labels[label_id] = {
            "widget": label_frame,
            "text_widget": text_widget,
            "text": initial_text,
            "x": x,
            "y": y
        }
        for widget in [label_frame, text_widget]:
            widget.bind("<ButtonPress-1>", lambda e, lid=label_id: self._on_label_press(e, lid))
            widget.bind("<B1-Motion>", lambda e, lid=label_id: self._on_label_drag(e, lid))
            widget.bind("<ButtonRelease-1>", lambda e, lid=label_id: self._on_label_release(e, lid))
            widget.bind("<Double-1>", lambda e, lid=label_id: self._edit_label_text(e, lid))
            widget.bind("<Button-3>", lambda e, lid=label_id: self._show_label_context_menu(e, lid))
        sizegrip.bind("<ButtonPress-1>", lambda e, lid=label_id: self._start_label_resize(e, lid))
        sizegrip.bind("<B1-Motion>", lambda e, lid=label_id: self._on_label_resize_drag(e, lid))
        sizegrip.bind("<ButtonRelease-1>", lambda e, lid=label_id: self._on_label_resize_release(e, lid))
        self.visual_manager.hide_watermark()
        return label_id
    def delete_label(self, label_id, feedback=True):
        if label_id in self.canvas_labels:
            widget = self.canvas_labels[label_id]['widget']
            if widget.winfo_exists():
                widget.destroy()
            del self.canvas_labels[label_id]
            self.canvas.delete(label_id)
            if feedback:
                print(f"INFO: Text note '{label_id[:8]}' deleted.") # English Log
    def _on_label_press(self, event, label_id):
        self.interaction_manager._drag_data = {"x": event.x, "y": event.y, "id": label_id}
        widget = self.canvas_labels[label_id]['widget']
        widget.lift()
    def _on_label_drag(self, event, label_id):
        if self.interaction_manager._drag_data.get("id") != label_id: return
        new_x = self.canvas.canvasx(event.x_root - self.canvas.winfo_rootx()) - self.interaction_manager._drag_data['x']
        new_y = self.canvas.canvasy(event.y_root - self.canvas.winfo_rooty()) - self.interaction_manager._drag_data['y']
        self.canvas.coords(label_id, new_x, new_y)
    def _on_label_release(self, event, label_id):
        if self.interaction_manager._drag_data.get("id") != label_id: return
        coords = self.canvas.coords(label_id)
        self.canvas_labels[label_id]['x'] = coords[0]
        self.canvas_labels[label_id]['y'] = coords[1]
        self.interaction_manager._drag_data = {}
    def _edit_label_text(self, event, label_id):
        current_text = self.canvas_labels[label_id]['text']
        popup = _TextEditorPopup(
            parent=self.canvas, loc_service=self.loc,
            title=self.loc.get('edit_note_title', fallback="Edit Note"),
            prompt=self.loc.get('edit_note_prompt', fallback="Enter new text for the note:"),
            initial_text=current_text
        )
        new_text = popup.result
        if new_text is not None:
            self.canvas_labels[label_id]['text'] = new_text
            text_widget = self.canvas_labels[label_id]['text_widget']
            self._apply_markdown_to_text_widget(text_widget, new_text)
    def _show_label_context_menu(self, event, label_id):
        context_menu = Menu(self.canvas, tearoff=0)
        context_menu.add_command(label=self.loc.get('context_menu_edit_note', fallback="Edit Note..."), command=lambda: self._edit_label_text(event, label_id))
        context_menu.add_command(label=self.loc.get('context_menu_delete_note', fallback="Delete Note"), command=lambda: self.delete_label(label_id))
        context_menu.tk_popup(event.x_root, event.y_root)
    def _start_label_resize(self, event, label_id):
        widget = self.canvas_labels[label_id]['widget']
        self.interaction_manager._resize_data = {
            'widget': widget,
            'start_x': event.x_root,
            'start_y': event.y_root,
            'start_width': widget.winfo_width(),
            'start_height': widget.winfo_height()
        }
    def _on_label_resize_drag(self, event, label_id):
        resize_data = self.interaction_manager._resize_data
        if not resize_data.get('widget'): return
        dx = event.x_root - resize_data['start_x']
        dy = event.y_root - resize_data['start_y']
        new_width = max(100, resize_data['start_width'] + dx)
        new_height = max(50, resize_data['start_height'] + dy)
        resize_data['widget'].configure(width=new_width, height=new_height)
    def _on_label_resize_release(self, event, label_id):
        self.interaction_manager._resize_data = {}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\custom_tab.py
# JUMLAH BARIS : 74
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import Menu, messagebox
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class CustomTab(ttk.Frame):
    """
    Sebuah frame kosong yang menjadi dasar untuk tab kustom.
    Berisi tombol untuk menambahkan modul.
    """
    def __init__(self, parent_notebook, kernel_instance):
        super().__init__(parent_notebook, style='TFrame')
        self.kernel = kernel_instance
        self.loc = self.kernel.get_service("localization_manager")
        self.api_client = ApiClient(kernel=self.kernel)
        placeholder_label = ttk.Label(
            self,
            text=self.loc.get('custom_tab_placeholder_text', fallback="This is Your Custom Tab.\\n\\nRight-click to add modules or other widgets."),
            font=("Helvetica", 14, "italic"),
            justify="center"
        )
        placeholder_label.pack(expand=True, padx=20, pady=20)
        watermark_label = ttk.Label(
            self,
            text=self.loc.get('custom_tab_watermark', fallback="WWW.TEETAH.ART"),
            font=("Helvetica", 10, "italic"),
            foreground="grey",
            anchor="se"
        )
        watermark_label.pack(side="bottom", fill="x", padx=10, pady=5)
        self.bind("<Button-3>", self._show_context_menu)
        placeholder_label.bind("<Button-3>", self._show_context_menu)
    def _show_context_menu(self, event):
        context_menu = Menu(self, tearoff=0)
        success, loaded_modules_data = self.api_client.get_components('modules')
        modules_to_display = []
        if success:
            modules_to_display = sorted([
                (mod_data['id'], mod_data.get('name', mod_data['id']))
                for mod_data in loaded_modules_data
            ], key=lambda x: x[1].lower())
        if not modules_to_display:
            context_menu.add_command(label=self.loc.get('no_modules_found', fallback="No modules available."))
            context_menu.entryconfig(self.loc.get('no_modules_found', fallback="No modules available."), state="disabled")
        else:
            for module_id, module_name in modules_to_display:
                context_menu.add_command(
                    label=module_name,
                    command=lambda mid=module_id, mname=module_name: self._simulate_add_module_to_canvas(mid, mname)
                )
        try:
            context_menu.tk_popup(event.x_root, event.y_root)
        finally:
            context_menu.grab_release()
    def _simulate_add_module_to_canvas(self, module_id, module_name):
        messagebox.showinfo(
            self.loc.get('info_title', fallback="Information"),
            self.loc.get(
                'simulate_add_module_message',
                module_name=module_name,
                module_id=module_id,
                fallback=f"Module '{module_name}' (ID: {module_id}) would be added to the workflow canvas if this feature were fully integrated."
            )
        )
        self.kernel.write_to_log(
            self.loc.get('log_simulate_add_module', module_name=module_name, module_id=module_id, fallback=f"Simulation: Module '{module_name}' (ID: {module_id}) 'added' from CustomTab."),
            "INFO"
        )
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\dashboard_frame.py
# JUMLAH BARIS : 58
#######################################################################

```py
import ttkbootstrap as ttk
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class DashboardFrame(ttk.Frame):
    """
    Sebuah bingkai yang membungkus setiap widget di dashboard.
    Menyediakan title bar untuk dragging, tombol close, dan pegangan resize.
    [FIXED V2] Now uses an explicit 'is_docked' flag to control drag/resize behavior correctly.
    """
    def __init__(self, parent, manager, widget_id, title, content_widget_class, content_widget_id: str, is_docked=False, **kwargs): # MODIFIED: Added is_docked parameter
        self.api_client = ApiClient()
        super().__init__(parent, style='primary.TFrame', borderwidth=1, relief="solid")
        self.manager = manager
        self.widget_id = widget_id
        self.is_docked = is_docked # ADDED: Store the docked state
        title_bar = ttk.Frame(self, style='primary.TFrame', height=30)
        title_bar.pack(side="top", fill="x", padx=1, pady=1)
        title_bar.pack_propagate(False)
        close_button = ttk.Button(title_bar, text="X", width=3, style="danger.TButton", command=self.close_widget)
        close_button.pack(side="right", padx=(0, 5), pady=2)
        title_label = ttk.Label(title_bar, text=title, style="primary.inverse.TLabel", font=("Helvetica", 10, "bold"))
        title_label.pack(side="left", padx=10)
        content_frame = ttk.Frame(self, style='light.TFrame', padding=5)
        content_frame.pack(expand=True, fill="both", padx=1, pady=(0, 1))
        if not self.is_docked:
            sizegrip = ttk.Sizegrip(self, style='primary.TSizegrip')
            sizegrip.place(relx=1.0, rely=1.0, anchor="se")
            sizegrip.bind("<ButtonPress-1>", self.on_resize_press)
            sizegrip.bind("<B1-Motion>", self.on_resize_motion)
            sizegrip.bind("<ButtonRelease-1>", self.on_resize_release)
        self.content_widget = content_widget_class(content_frame, self.manager.coordinator_tab, self.manager.kernel, widget_id=content_widget_id)
        self.content_widget.pack(expand=True, fill="both")
        title_bar.bind("<ButtonPress-1>", self.on_press)
        title_bar.bind("<B1-Motion>", self.on_drag)
        title_bar.bind("<ButtonRelease-1>", self.on_release)
        title_label.bind("<ButtonPress-1>", self.on_press)
        title_label.bind("<B1-Motion>", self.on_drag)
        title_label.bind("<ButtonRelease-1>", self.on_release)
    def on_press(self, event):
        if not self.is_docked:
            self.manager.start_drag(self, event)
    def on_drag(self, event):
        if not self.is_docked:
            self.manager.drag_widget(event)
    def on_release(self, event):
        if not self.is_docked:
            self.manager.stop_drag(event)
    def on_resize_press(self, event): self.manager.start_resize(self, event)
    def on_resize_motion(self, event): self.manager.resize_widget(event)
    def on_resize_release(self, event): self.manager.stop_resize(event)
    def close_widget(self): self.manager.remove_widget(self.widget_id)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\dashboard_manager.py
# JUMLAH BARIS : 301
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import Menu, messagebox
import uuid
from .dashboard_frame import DashboardFrame
from flowork_gui.utils.performance_logger import log_performance # PENAMBAHAN: Using the correct absolute import.
import threading
import time
from ..widgets.canvas_area.canvas_area_widget import CanvasAreaWidget
from ..widgets.logic_toolbox_widget.logic_toolbox_widget import LogicToolboxWidget
from ..widgets.plugin_toolbox_widget.plugin_toolbox_widget import PluginToolboxWidget
from ..widgets.widget_toolbox.widget_toolbox_widget import WidgetToolboxWidget
from ..widgets.log_viewer_widget.log_viewer_widget import LogViewerWidget
from ..widgets.prompt_sender_widget.prompt_sender_widget import PromptSenderWidget
class DashboardManager:
    """
    Manages adding, removing, moving, resizing, and saving the layout of widgets.
    (REFACTORED for GUI Independence) Now receives a mock_kernel for compatibility
    with child components that are not yet fully refactored.
    """
    def __init__(self, host_frame, coordinator_tab, kernel, tab_id, is_new_tab=False):
        self.host_frame = host_frame
        self.coordinator_tab = coordinator_tab
        self.kernel = kernel
        self.loc = self.kernel.loc
        self.api_client = self.kernel.api_client
        self.widgets = {}
        self.tab_id = tab_id
        self.is_new_tab = is_new_tab
        self.watermark_label = None
        self._drag_data = {'widget': None, 'x': 0, 'y': 0}
        self._resize_data = {'widget': None, 'start_x': 0, 'start_y': 0, 'start_width': 0, 'start_height': 0}
        self.available_widget_classes = {
            "canvas_area": CanvasAreaWidget,
            "logic_toolbox": LogicToolboxWidget,
            "plugin_toolbox": PluginToolboxWidget,
            "widget_toolbox": WidgetToolboxWidget,
            "log_viewer": LogViewerWidget,
            "prompt_sender_widget": PromptSenderWidget
        }
        self.available_widgets_from_api = {}
        self.docks = {}
        self.docked_widgets = {"left": [], "right": []}
        self.pinned_docks = {"left": False, "right": False}
        self.hide_jobs = {"left": None, "right": None}
        self._build_ui_with_docks()
        self.host_frame.after(50, self._load_initial_data_async)
    def _build_ui_with_docks(self):
        """(REFACTORED V3) Uses .place() for all main components to ensure stable geometry management."""
        self.canvas_area = ttk.Frame(self.host_frame)
        self.canvas_area.place(x=0, y=0, relwidth=1, relheight=1)
        self.canvas_area.bind("<Button-3>", self.show_context_menu)
        self.docks['left'] = self._create_dock_structure('left', '>')
        self.docks['right'] = self._create_dock_structure('right', '<')
        self.docks['left']['handle'].place(relx=0, rely=0, relheight=1)
        self.docks['right']['handle'].place(relx=1.0, rely=0, relheight=1, anchor='ne')
    def _create_dock_structure(self, side, handle_text):
        """(MODIFIED) Now creates handle as a direct child of host_frame for stable placement."""
        handle = ttk.Frame(self.host_frame, width=20, bootstyle="secondary")
        handle_label = ttk.Label(handle, text=handle_text, bootstyle="inverse-secondary", font=("Helvetica", 12, "bold"))
        handle_label.pack(expand=True)
        content_frame = ttk.Frame(self.host_frame, width=300, bootstyle="secondary")
        control_bar = ttk.Frame(content_frame, bootstyle="secondary")
        control_bar.pack(fill='x', padx=5, pady=2)
        add_button = ttk.Button(control_bar, text="+", bootstyle="success-link", width=2, command=lambda s=side: self._show_add_to_dock_menu(s))
        add_button.pack(side='left')
        pin_button = ttk.Button(control_bar, text="📌", bootstyle="light-link", command=lambda s=side: self._toggle_pin(s))
        pin_button.pack(side='right')
        handle.bind("<Enter>", lambda e, s=side: self._show_dock(s))
        content_frame.bind("<Leave>", lambda e, s=side: self._hide_dock_later(s))
        return {'frame': content_frame, 'content': content_frame, 'handle': handle, 'pin_button': pin_button}
    def _show_add_to_dock_menu(self, side):
        """Creates and shows a context menu to add any available widget to the specified dock."""
        add_menu = Menu(self.host_frame, tearoff=0)
        all_docked_widget_types = {w.content_widget.widget_id for w_list in self.docked_widgets.values() for w in w_list}
        available_for_docking = {k: v for k, v in self.available_widgets_from_api.items() if k not in all_docked_widget_types}
        if not available_for_docking:
            add_menu.add_command(label=self.loc.get('dock_no_widgets_available', fallback="No more widgets to add"), state="disabled")
        else:
            for key, info in sorted(available_for_docking.items(), key=lambda item: item[1]['name'].lower()):
                add_menu.add_command(label=info['name'], command=lambda k=key, s=side: self.add_widget_and_save(k, dock_side=s))
        try:
            add_menu.tk_popup(self.host_frame.winfo_pointerx(), self.host_frame.winfo_pointery())
        finally:
            add_menu.grab_release()
    def _toggle_pin(self, side):
        """Toggles the pinned state of a dock."""
        self.pinned_docks[side] = not self.pinned_docks[side]
        pin_char = "📌"
        self.docks[side]['pin_button'].config(text=pin_char)
        if not self.pinned_docks[side]:
            self._hide_dock_later(side)
    def _show_dock(self, side):
        """Shows a dock panel."""
        if self.hide_jobs[side]:
            self.host_frame.after_cancel(self.hide_jobs[side])
            self.hide_jobs[side] = None
        relx = 0 if side == 'left' else 1.0
        anchor = 'nw' if side == 'left' else 'ne'
        self.docks[side]['frame'].place(in_=self.host_frame, relx=relx, rely=0, relheight=1.0, anchor=anchor)
        self.docks[side]['frame'].lift()
    def _hide_dock_later(self, side):
        """Schedules a dock to be hidden after a short delay."""
        if not self.pinned_docks[side]:
            self.hide_jobs[side] = self.host_frame.after(300, lambda: self.docks[side]['frame'].place_forget())
    def _load_initial_data_async(self):
        self._create_watermark()
        threading.Thread(target=self._load_initial_data_worker, daemon=True).start()
    @log_performance("Fetching all initial data for DashboardManager")
    def _load_initial_data_worker(self):
        success_widgets, widgets_data = self.api_client.get_components('widgets')
        success_layout, layout_data = self.api_client.get_dashboard_layout(self.tab_id)
        self.host_frame.after(0, self._on_initial_data_loaded, success_widgets, widgets_data, success_layout, layout_data)
    def _on_initial_data_loaded(self, success_widgets, widgets_data, success_layout, layout_data):
        if not success_widgets:
            print(f"Failed to fetch available widgets via API: {widgets_data}") # English Log
        else:
            for widget_data in widgets_data:
                widget_id = widget_data.get('id')
                if not widget_data.get('is_paused', False):
                    self.available_widgets_from_api[widget_id] = widget_data
            print(f"Dashboard Manager: {len(self.available_widgets_from_api)} widgets available from API.") # English Log
        if not success_layout:
            print(f"Failed to load layout for tab {self.tab_id}: {layout_data}") # English Log
        elif layout_data:
            self._remove_watermark()
            for widget_id, config in layout_data.items():
                widget_type = config.get("type")
                if widget_type in self.available_widget_classes: # Check if we know how to render it
                    dock_side = config.get("dock")
                    self.add_widget(
                        widget_type,
                        config.get("x", 10),
                        config.get("y", 10),
                        config.get("width", 400),
                        config.get("height", 300),
                        existing_id=widget_id,
                        dock_side=dock_side
                    )
                else:
                    print(f"Widget type '{widget_type}' from saved layout could not be loaded (class not found in GUI).") # English Log
        canvas_area_exists = any(
            hasattr(frame, 'content_widget') and frame.content_widget.widget_id == 'canvas_area'
            for frame in self.widgets.values()
        )
        if not canvas_area_exists:
            self.add_widget("canvas_area", 0, 0, 0, 0)
            print("DashboardManager: Core 'canvas_area' was not in the layout, re-initializing it.") # English Log
        if not self.widgets:
            if self.is_new_tab:
                self._load_default_layout()
            else:
                 self._create_watermark()
    def _create_watermark(self):
        if not self.canvas_area.winfo_exists(): return
        if self.watermark_label and self.watermark_label.winfo_exists(): return
        self.watermark_label = ttk.Label(
            self.canvas_area, text="www.teetah.art", font=("Helvetica", 40, "bold"),
            foreground="#3a3a3a", anchor="center"
        )
        self.watermark_label.place(relx=0.5, rely=0.5, anchor="center")
        self.watermark_label.lower()
    def _remove_watermark(self):
        if self.watermark_label and self.watermark_label.winfo_exists():
            self.watermark_label.destroy()
            self.watermark_label = None
    def clear_all_widgets(self):
        for widget_id in list(self.widgets.keys()):
            self.remove_widget(widget_id)
        self.save_layout()
        self._create_watermark()
    @log_performance("Loading default dashboard layout")
    def _load_default_layout(self):
        print(f"DashboardManager for tab {self.tab_id} is loading a default layout.") # English Log
        self._remove_watermark()
        self.add_widget("canvas_area", 0, 0, 0, 0)
        self.save_layout()
    def save_layout(self):
        layout = {}
        for widget_id, frame in self.widgets.items():
            if hasattr(frame, 'content_widget') and hasattr(frame.content_widget, 'widget_id'):
                widget_type_key = frame.content_widget.widget_id
                dock_side = None
                if frame in self.docked_widgets['left']:
                    dock_side = 'left'
                elif frame in self.docked_widgets['right']:
                    dock_side = 'right'
                if dock_side:
                    layout[widget_id] = {"type": widget_type_key, "dock": dock_side}
                elif widget_type_key != 'canvas_area':
                    if widget_type_key in self.available_widgets_from_api:
                        layout[widget_id] = {"type": widget_type_key, "x": frame.winfo_x(), "y": frame.winfo_y(), "width": frame.winfo_width(), "height": frame.winfo_height()}
        success, response = self.api_client.save_dashboard_layout(self.tab_id, layout)
        if not success:
            print(f"Failed to save layout via API: {response}") # English Log
    def add_widget(self, widget_type_key, x=0, y=0, width=400, height=300, existing_id=None, dock_side=None):
        self._remove_watermark()
        widget_info_from_api = self.available_widgets_from_api.get(widget_type_key)
        WidgetClass = self.available_widget_classes.get(widget_type_key)
        if not widget_info_from_api or not WidgetClass:
            print(f"Failed to add widget: Type '{widget_type_key}' not found or its class is not registered in the GUI. ERROR") # English Log
            return
        widget_id = existing_id or str(uuid.uuid4())
        frame = None
        if dock_side == 'left':
            frame = DashboardFrame(self.docks['left']['content'], self, widget_id, widget_info_from_api["name"], WidgetClass, content_widget_id=widget_type_key, is_docked=True)
            frame.pack(fill='x', pady=5)
            self.docked_widgets['left'].append(frame)
        elif dock_side == 'right':
            frame = DashboardFrame(self.docks['right']['content'], self, widget_id, widget_info_from_api["name"], WidgetClass, content_widget_id=widget_type_key, is_docked=True)
            frame.pack(fill='both', expand=True, pady=5)
            self.docked_widgets['right'].append(frame)
        else:
            is_docked = (widget_type_key == 'canvas_area')
            frame = DashboardFrame(self.canvas_area, self, widget_id, widget_info_from_api["name"], WidgetClass, content_widget_id=widget_type_key, is_docked=is_docked)
            if widget_type_key == 'canvas_area':
                frame.place(x=0, y=0, relwidth=1, relheight=1)
            else:
                frame.place(x=x, y=y, width=width, height=height)
        self.widgets[widget_id] = frame
        if hasattr(frame.content_widget, 'on_widget_load'):
            frame.content_widget.on_widget_load()
        if widget_type_key == 'canvas_area':
            self.coordinator_tab.canvas_area_instance = frame.content_widget
    def remove_widget(self, widget_id):
        if widget_id in self.widgets:
            frame_to_remove = self.widgets[widget_id]
            widget_type_key = frame_to_remove.content_widget.widget_id
            if self.coordinator_tab.canvas_area_instance == frame_to_remove.content_widget:
                self.coordinator_tab.canvas_area_instance = None
            if hasattr(frame_to_remove.content_widget, 'on_widget_destroy'):
                frame_to_remove.content_widget.on_widget_destroy()
            if frame_to_remove in self.docked_widgets['left']:
                self.docked_widgets['left'].remove(frame_to_remove)
            if frame_to_remove in self.docked_widgets['right']:
                self.docked_widgets['right'].remove(frame_to_remove)
            frame_to_remove.destroy()
            del self.widgets[widget_id]
            if not self.widgets:
                self._create_watermark()
    def start_drag(self, widget, event):
        if not widget.is_docked:
            widget.lift()
            self._drag_data['widget'] = widget
            self._drag_data['x'] = event.x
            self._drag_data['y'] = event.y
    def drag_widget(self, event):
        if self._drag_data['widget']:
            dx = event.x - self._drag_data['x']
            dy = event.y - self._drag_data['y']
            x = self._drag_data['widget'].winfo_x() + dx
            y = self._drag_data['widget'].winfo_y() + dy
            self._drag_data['widget'].place(x=x, y=y)
    def stop_drag(self, event):
        self._drag_data['widget'] = None
        self.save_layout()
    def start_resize(self, widget, event):
        self._resize_data['widget'] = widget
        self._resize_data['start_x'] = event.x_root
        self._resize_data['start_y'] = event.y_root
        self._resize_data['start_width'] = widget.winfo_width()
        self._resize_data['start_height'] = widget.winfo_height()
    def resize_widget(self, event):
        if self._resize_data['widget']:
            dx = event.x_root - self._resize_data['start_x']
            dy = event.y_root - self._resize_data['start_y']
            new_width = self._resize_data['start_width'] + dx
            new_height = self._resize_data['start_height'] + dy
            if new_width > 150 and new_height > 100:
                self._resize_data['widget'].place(width=new_width, height=new_height)
    def stop_resize(self, event):
        self._resize_data['widget'] = None
        self.save_layout()
    def _create_add_widget_menu(self, event_x=10, event_y=10):
        context_menu = Menu(self.canvas_area, tearoff=0)
        sorted_widgets = sorted(self.available_widgets_from_api.items(), key=lambda item: item[1]['name'].lower())
        dock_exclusive_widgets = {"logic_toolbox_widget", "plugin_toolbox_widget", "widget_toolbox", "log_viewer_widget"}
        has_addable_widgets = False
        for key, info in sorted_widgets:
            if key not in dock_exclusive_widgets:
                context_menu.add_command(label=info['name'], command=lambda k=key, x=event_x, y=event_y: self.add_widget_and_save(k, x=x, y=y))
                has_addable_widgets = True
        if not has_addable_widgets:
            context_menu.add_command(label="No non-dockable widgets available", state="disabled") # English Hardcode
        return context_menu
    def show_context_menu(self, event):
        context_menu = self._create_add_widget_menu(event_x=event.x, event_y=event.y)
        try:
            context_menu.tk_popup(event.x_root, event.y_root)
        finally:
            context_menu.grab_release()
    def add_widget_and_save(self, widget_type_key, x=0, y=0, dock_side=None):
        self.add_widget(widget_type_key, x, y, dock_side=dock_side)
        self.save_layout()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\dashboard_tab.py
# JUMLAH BARIS : 39
#######################################################################

```py
import ttkbootstrap as ttk
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class DashboardTab(ttk.Frame):
    """
    Frame untuk Dashboard. Sekarang berisi pengalih bahasa.
    """
    def __init__(self, parent_notebook, kernel_instance):
        self.api_client = ApiClient()
        super().__init__(parent_notebook, style='TFrame')
        self.kernel = kernel_instance
        self.loc = self.kernel.loc
        container = ttk.Frame(self, style='TFrame', padding=20)
        container.pack(expand=True, fill='both', anchor='n')
        lang_frame = ttk.Frame(container, style='TFrame')
        lang_frame.pack(pady=10, anchor='w')
        lang_label = ttk.Label(lang_frame, text="Pilih Bahasa:", font=("Helvetica", 11, "bold"))
        lang_label.pack(side='left', padx=(0, 10))
        self.lang_combobox = ttk.Combobox(
            lang_frame,
            values=["id", "en"],
            state="readonly"
        )
        self.lang_combobox.set(self.loc.current_lang)
        self.lang_combobox.pack(side='left')
        self.lang_combobox.bind("<<ComboboxSelected>>", self.change_language)
    def change_language(self, event=None):
        """Memuat bahasa baru dan memuat ulang UI."""
        selected_lang = self.lang_combobox.get()
        print(f"Bahasa diubah ke: {selected_lang}")
        self.kernel.loc.load_language(selected_lang)
        self.kernel.reload_ui()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\node_properties_popup.py
# JUMLAH BARIS : 65
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import simpledialog
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class NodePropertiesPopup(ttk.Toplevel):
    """
    Jendela popup generik untuk menampilkan properti node.
    Popup ini akan dibuat dan dikelola oleh PropertiesManager.
    """
    def __init__(self, parent, kernel, node_id, module_instance, get_config_func, save_config_func, available_vars):
        self.api_client = ApiClient()
        super().__init__(parent)
        self.kernel = kernel
        self.loc = self.kernel.loc
        self.node_id = node_id
        self.module_instance = module_instance
        self.get_config_func = get_config_func
        self.save_config_func = save_config_func
        self.available_vars = available_vars
        self.property_vars = {}
        self.title(self.loc.get('properties_title', fallback="Properti Node") + f" ({node_id})")
        self.transient(parent)
        self.grab_set()
        self.main_frame = ttk.Frame(self, padding=15)
        self.main_frame.pack(fill="both", expand=True)
        self._build_ui()
        self.wait_window(self)
    def _build_ui(self):
        """Membangun antarmuka pengguna untuk jendela properti."""
        content_frame = ttk.Frame(self.main_frame, style='TFrame')
        content_frame.pack(fill="both", expand=True)
        if hasattr(self.module_instance, 'create_properties_ui'):
            self.property_vars = self.module_instance.create_properties_ui(
                parent_frame=content_frame,
                get_current_config=self.get_config_func,
                available_vars=self.available_vars
            )
        else:
            ttk.Label(content_frame, text="Modul ini tidak memiliki properti yang bisa diatur.").pack(pady=20)
        action_buttons_frame = ttk.Frame(self.main_frame, style='TFrame')
        action_buttons_frame.pack(side="bottom", fill="x", pady=(10, 0), padx=5)
        save_button = ttk.Button(action_buttons_frame, text=self.loc.get("button_save", fallback="Simpan"), command=self._save_and_close, bootstyle="success")
        save_button.pack(side="right", padx=5, pady=5)
        cancel_button = ttk.Button(action_buttons_frame, text=self.loc.get("button_cancel", fallback="Batal"), command=self.destroy, bootstyle="secondary")
        cancel_button.pack(side="right", padx=5, pady=5)
    def _save_and_close(self):
        """Menyimpan konfigurasi dan menutup jendela."""
        new_config = {}
        for key, var in self.property_vars.items():
            try:
                if hasattr(var, 'get_value'): # Ini adalah EnumVarWrapper
                    new_config[key] = var.get_value()
                else: # Variabel Tkinter biasa
                    new_config[key] = var.get()
            except Exception as e:
                self.kernel.write_to_log(f"Gagal mendapatkan nilai untuk properti '{key}': {e}", "WARN")
        self.save_config_func(new_config)
        self.destroy()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\properties_popup.py
# JUMLAH BARIS : 114
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import Text, TclError, Listbox
from api_contract import EnumVarWrapper
from api_client.client import ApiClient
class PropertiesPopup(ttk.Toplevel):
    def __init__(self, parent_canvas_manager, node_id):
        super().__init__(parent_canvas_manager.coordinator_tab)
        self.canvas_manager = parent_canvas_manager
        self.parent_tab = parent_canvas_manager.coordinator_tab
        self.kernel = self.parent_tab.kernel
        self.loc = self.kernel.get_service("localization_manager")
        self.api_client = ApiClient(kernel=self.kernel)
        self.node_id = node_id
        self.property_vars = {}
        self.dynamic_widgets = {}
        node_data = self.canvas_manager.canvas_nodes.get(self.node_id)
        if not node_data:
            self.destroy()
            return
        node_name = node_data.get('name', 'Unknown')
        self.title(f"{self.loc.get('properties_title', fallback='Node Properties')} - {node_name}")
        self.geometry("450x700")
        self.transient(self.parent_tab.winfo_toplevel())
        self.grab_set()
        self._create_widgets()
    def _create_widgets(self):
        main_frame = ttk.Frame(self, padding=15)
        main_frame.pack(expand=True, fill="both")
        top_static_frame = ttk.Frame(main_frame)
        top_static_frame.pack(side="top", fill="x", expand=False)
        button_frame = ttk.Frame(self)
        button_frame.pack(side="bottom", fill="x", padx=15, pady=(5, 15))
        self.save_button = ttk.Button(button_frame, text=self.loc.get('save_changes_button', fallback="Save Changes"), command=self._save_changes, bootstyle="success.TButton")
        self.save_button.pack(side="right")
        ttk.Button(button_frame, text=self.loc.get('button_cancel', fallback="Cancel"), command=self.destroy, bootstyle="secondary.TButton").pack(side="right", padx=(0, 10))
        scroll_container = ttk.Frame(main_frame)
        scroll_container.pack(side="top", fill="both", expand=True, pady=(10,0))
        scroll_canvas = ttk.Canvas(scroll_container, highlightthickness=0)
        scrollbar = ttk.Scrollbar(scroll_container, orient="vertical", command=scroll_canvas.yview)
        self.scrollable_frame = ttk.Frame(scroll_canvas)
        self.scrollable_frame.bind("<Configure>", lambda e: scroll_canvas.configure(scrollregion=scroll_canvas.bbox("all")))
        scroll_canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        scroll_canvas.configure(yscrollcommand=scrollbar.set)
        scroll_canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        self._populate_static_content(top_static_frame)
        self._populate_scrollable_content(self.scrollable_frame)
    def _populate_static_content(self, parent_frame):
        style = ttk.Style()
        theme_manager = self.kernel.get_service("theme_manager")
        colors = theme_manager.get_colors() if theme_manager else {}
        style.configure('Readonly.TEntry', fieldbackground=colors.get('dark', '#333333'), insertwidth=0)
        style.map('Readonly.TEntry', foreground=[('readonly', colors.get('light', '#ffffff'))], fieldbackground=[('readonly', colors.get('dark', '#333333'))])
        id_input_frame = ttk.Frame(parent_frame)
        id_input_frame.pack(fill='x', expand=True)
        ttk.Label(id_input_frame, text=self.loc.get('node_id_label', fallback="Node ID:")).pack(fill='x', anchor='w')
        id_entry_frame = ttk.Frame(id_input_frame)
        id_entry_frame.pack(fill='x', expand=True, pady=(2,0))
        node_id_var = ttk.StringVar(value=self.node_id)
        id_entry = ttk.Entry(id_entry_frame, textvariable=node_id_var, state="readonly", style='Readonly.TEntry')
        id_entry.pack(side='left', fill='x', expand=True)
        copy_button = ttk.Button(id_entry_frame, text=self.loc.get('copy_id_button', fallback="Copy ID"), command=self._copy_node_id, style="info.Outline.TButton")
        copy_button.pack(side='left', padx=(5,0))
        ttk.Separator(parent_frame).pack(fill='x', pady=(15, 0))
    def _populate_scrollable_content(self, parent_frame):
        node_data = self.canvas_manager.canvas_nodes.get(self.node_id)
        ttk.Label(parent_frame, text=self.loc.get('module_name_label', fallback="Node Name:")).pack(fill='x', padx=5, pady=(5,0))
        self.property_vars['name'] = ttk.StringVar(value=node_data['name'])
        ttk.Entry(parent_frame, textvariable=self.property_vars['name']).pack(fill='x', padx=5, pady=(0, 10))
        ttk.Label(parent_frame, text=self.loc.get('description_label', fallback="Description:")).pack(fill='x', padx=5, pady=(5,0))
        desc_text = Text(parent_frame, height=3, font=("Helvetica", 9))
        desc_text.pack(fill='x', expand=True, padx=5, pady=(0, 10))
        desc_text.insert('1.0', node_data.get('description', ''))
        self.property_vars['description'] = desc_text
        ttk.Separator(parent_frame).pack(fill='x', pady=10, padx=5)
        module_manager = self.kernel.get_service("module_manager_service")
        module_instance = module_manager.get_instance(node_data['module_id']) if module_manager else None
        if module_instance and hasattr(module_instance, 'create_properties_ui'):
            get_current_config = lambda: self.canvas_manager.canvas_nodes.get(self.node_id, {}).get('config_values', {})
            available_vars_for_module = self._get_incoming_variables()
            returned_vars = module_instance.create_properties_ui(parent_frame, get_current_config, available_vars_for_module)
            if returned_vars: self.property_vars.update(returned_vars)
    def _get_incoming_variables(self):
        incoming_vars = {}
        module_manager = self.kernel.get_service("module_manager_service")
        if not module_manager: return {}
        for conn in self.canvas_manager.canvas_connections.values():
            if conn['to'] == self.node_id:
                from_node_data = self.canvas_manager.canvas_nodes.get(conn['from'])
                if from_node_data:
                    from_module_id = from_node_data['module_id']
                    from_node_manifest = module_manager.get_manifest(from_module_id)
                    if from_node_manifest and 'output_schema' in from_node_manifest:
                        for var_info in from_node_manifest['output_schema']:
                            if var_info['name'] not in incoming_vars:
                                incoming_vars[var_info['name']] = var_info.get('description', '')
        if 'data' not in incoming_vars: incoming_vars['data'] = "Main payload data (dictionary)."
        if 'history' not in incoming_vars: incoming_vars['history'] = "Payload history (list)."
        return {k: incoming_vars[k] for k in sorted(incoming_vars.keys())}
    def _copy_node_id(self):
        self.clipboard_clear()
        self.clipboard_append(self.node_id)
        self.kernel.write_to_log(f"Node ID '{self.node_id}' copied to clipboard.", "INFO") # English Log
    def _save_changes(self):
        self.canvas_manager.properties_manager.save_node_properties(self.node_id, self.property_vars, self)
        self.destroy()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\shared_properties.py
# JUMLAH BARIS : 157
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import Text, StringVar, BooleanVar, IntVar, TclError
from api_contract import LoopConfig # # PENAMBAHAN OTOMATIS
from views.custom_widgets.tooltip import ToolTip # # PENAMBAHAN OTOMATIS
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
def create_debug_and_reliability_ui(parent, config, loc):
    """
    Membuat bagian UI untuk pengaturan Debug (breakpoint, timeout) dan Keandalan (retry).
    """
    created_vars = {}
    debug_frame = ttk.LabelFrame(parent, text=loc.get('debug_settings_title', fallback="Debug & Reliability Settings"))
    debug_frame.pack(fill='x', padx=5, pady=10, expand=False)
    created_vars['has_breakpoint'] = ttk.BooleanVar(value=config.get('has_breakpoint', False))
    bp_check = ttk.Checkbutton(debug_frame, text=loc.get('set_breakpoint_checkbox', fallback="Set Breakpoint on This Node"), variable=created_vars['has_breakpoint'])
    bp_check.pack(anchor='w', pady=5, padx=10)
    ToolTip(bp_check).update_text(loc.get('set_breakpoint_tooltip'))
    timeout_frame = ttk.Frame(debug_frame)
    timeout_frame.pack(fill='x', padx=10, pady=(5,5))
    ttk.Label(timeout_frame, text=loc.get('execution_timeout_label')).pack(side='left', anchor='w')
    created_vars['timeout_seconds'] = ttk.IntVar(value=config.get('timeout_seconds', 0))
    timeout_entry = ttk.Entry(timeout_frame, textvariable=created_vars['timeout_seconds'], width=8)
    timeout_entry.pack(side='left', padx=5)
    ToolTip(timeout_entry).update_text(loc.get('execution_timeout_tooltip'))
    ttk.Separator(debug_frame).pack(fill='x', pady=5)
    retry_title_label = ttk.Label(debug_frame, text=loc.get('retry_settings_title'))
    retry_title_label.pack(anchor='w', padx=10, pady=(10,0))
    retry_frame = ttk.Frame(debug_frame)
    retry_frame.pack(fill='x', padx=10, pady=(5,10))
    ttk.Label(retry_frame, text=loc.get('retry_attempts_label')).pack(side='left', anchor='w')
    created_vars['retry_attempts'] = ttk.IntVar(value=config.get('retry_attempts', 0))
    retry_attempts_entry = ttk.Entry(retry_frame, textvariable=created_vars['retry_attempts'], width=5)
    retry_attempts_entry.pack(side='left', padx=5)
    ToolTip(retry_attempts_entry).update_text(loc.get('retry_attempts_tooltip'))
    ttk.Label(retry_frame, text=loc.get('retry_delay_label')).pack(side='left', padx=10, anchor='w')
    created_vars['retry_delay_seconds'] = ttk.IntVar(value=config.get('retry_delay_seconds', 5))
    retry_delay_entry = ttk.Entry(retry_frame, textvariable=created_vars['retry_delay_seconds'], width=5)
    retry_delay_entry.pack(side='left', padx=5)
    ToolTip(retry_delay_entry).update_text(loc.get('retry_delay_tooltip'))
    ttk.Separator(debug_frame).pack(fill='x', pady=5)
    checkpoint_title_label = ttk.Label(debug_frame, text=loc.get('checkpoint_settings_title'))
    checkpoint_title_label.pack(anchor='w', padx=10, pady=(10,0))
    created_vars['is_checkpoint'] = ttk.BooleanVar(value=config.get('is_checkpoint', False))
    checkpoint_check = ttk.Checkbutton(debug_frame, text=loc.get('enable_checkpoint_checkbox'), variable=created_vars['is_checkpoint'])
    checkpoint_check.pack(anchor='w', pady=5, padx=10)
    ToolTip(checkpoint_check).update_text(loc.get('checkpoint_tooltip'))
    return created_vars
def create_loop_settings_ui(parent, config, loc, available_vars):
    """
    Membuat bagian UI untuk pengaturan Looping dan Jeda (Sleep).
    """
    created_vars = {}
    loop_frame = ttk.LabelFrame(parent, text=loc.get('loop_settings_title', fallback="Looping Settings"))
    loop_frame.pack(fill='x', padx=5, pady=10, expand=False)
    created_vars['enable_loop'] = ttk.BooleanVar(value=config.get('enable_loop', False))
    enable_loop_check = ttk.Checkbutton(loop_frame, text=loc.get('enable_loop_checkbox', fallback="Enable Looping"), variable=created_vars['enable_loop'])
    enable_loop_check.pack(anchor='w', padx=5)
    loop_options_frame = ttk.Frame(loop_frame)
    created_vars['loop_type'] = ttk.StringVar(value=config.get('loop_type', LoopConfig.LOOP_TYPE_COUNT))
    count_details_frame = ttk.Frame(loop_options_frame)
    condition_details_frame = ttk.Frame(loop_options_frame)
    count_radio = ttk.Radiobutton(loop_options_frame, text=loc.get('loop_type_count_radio', fallback="Repeat N Times"), variable=created_vars['loop_type'], value=LoopConfig.LOOP_TYPE_COUNT)
    count_radio.pack(anchor='w')
    count_details_frame.pack(fill='x', anchor='w', padx=20, pady=2)
    created_vars['loop_iterations'] = ttk.IntVar(value=config.get('loop_iterations', 1))
    count_entry = ttk.Entry(count_details_frame, textvariable=created_vars['loop_iterations'], width=10)
    count_entry.pack(anchor='w')
    ToolTip(count_entry).update_text(loc.get('loop_iterations_tooltip', fallback="Number of loop iterations."))
    condition_radio = ttk.Radiobutton(loop_options_frame, text=loc.get('loop_type_condition_radio', fallback="Repeat Until Condition"), variable=created_vars['loop_type'], value=LoopConfig.LOOP_TYPE_CONDITION)
    condition_radio.pack(anchor='w', pady=(10,0))
    condition_details_frame.pack(fill='x', padx=20, pady=5)
    ttk.Label(condition_details_frame, text=loc.get('condition_var_label', fallback="Condition Variable:")).pack(side='left', padx=(0,5))
    created_vars['loop_condition_var'] = ttk.StringVar(value=config.get('loop_condition_var', ''))
    loop_condition_var_combobox = ttk.Combobox(condition_details_frame, textvariable=created_vars['loop_condition_var'], values=list(available_vars.keys()), state="readonly")
    loop_condition_var_combobox.pack(side='left', expand=True, fill='x', padx=(0,5))
    ToolTip(loop_condition_var_combobox).update_text(loc.get('condition_var_tooltip', fallback="The DataPayload variable to evaluate."))
    created_vars['loop_condition_op'] = ttk.StringVar(value=config.get('loop_condition_op', '=='))
    all_operators = ['==', '!=', '>', '<', '>=', '<=', loc.get('operator_contains_text', fallback='contains'), loc.get('operator_not_contains_text', fallback='not contains'), loc.get('operator_starts_with', fallback='starts with'), loc.get('operator_ends_with', fallback='ends with')]
    ttk.Combobox(condition_details_frame, textvariable=created_vars['loop_condition_op'], values=all_operators, state="readonly", width=15).pack(side='left', padx=(0,5))
    created_vars['loop_condition_val'] = ttk.StringVar(value=config.get('loop_condition_val', ''))
    condition_val_entry = ttk.Entry(condition_details_frame, textvariable=created_vars['loop_condition_val'])
    condition_val_entry.pack(side='left', expand=True, fill='x')
    ToolTip(condition_val_entry).update_text(loc.get('condition_val_tooltip', fallback="The value to compare against."))
    ttk.Separator(loop_frame).pack(fill='x', pady=10, padx=5)
    sleep_control_frame = ttk.Frame(loop_frame)
    created_vars['enable_sleep'] = ttk.BooleanVar(value=config.get('enable_sleep', False))
    sleep_options_frame = ttk.Frame(sleep_control_frame)
    static_sleep_frame = ttk.Frame(sleep_options_frame)
    random_sleep_details_frame = ttk.Frame(sleep_options_frame)
    ttk.Checkbutton(sleep_control_frame, text=loc.get('enable_sleep_checkbox', fallback="Enable Delay Between Iterations"), variable=created_vars['enable_sleep']).pack(anchor='w', pady=5, padx=10)
    created_vars['sleep_type'] = ttk.StringVar(value=config.get('sleep_type', 'static'))
    static_radio = ttk.Radiobutton(sleep_options_frame, text=loc.get('sleep_type_static_radio', fallback="Static Delay (seconds)"), variable=created_vars['sleep_type'], value="static")
    static_radio.pack(anchor='w')
    static_sleep_frame.pack(anchor='w', padx=20, pady=2)
    created_vars['static_duration'] = ttk.IntVar(value=config.get('static_duration', 1))
    static_duration_entry = ttk.Entry(static_sleep_frame, textvariable=created_vars['static_duration'], width=10)
    static_duration_entry.pack(anchor='w')
    ToolTip(static_duration_entry).update_text(loc.get('static_duration_tooltip', fallback="Duration of the delay in seconds."))
    random_radio = ttk.Radiobutton(sleep_options_frame, text=loc.get('sleep_type_random_radio', fallback="Random Delay (seconds)"), variable=created_vars['sleep_type'], value="random_range")
    random_radio.pack(anchor='w', pady=(10,0))
    random_sleep_details_frame.pack(fill='x', padx=20, pady=5)
    ttk.Label(random_sleep_details_frame, text=loc.get('random_min_label', fallback="Min:")).pack(side='left', padx=(0,5))
    created_vars['random_min'] = ttk.IntVar(value=config.get('random_min', 1))
    random_min_entry = ttk.Entry(random_sleep_details_frame, textvariable=created_vars['random_min'], width=5)
    random_min_entry.pack(side='left', padx=(0,5))
    ToolTip(random_min_entry).update_text(loc.get('random_min_tooltip', fallback="Minimum delay duration (seconds)."))
    ttk.Label(random_sleep_details_frame, text=loc.get('random_max_label', fallback="Max:")).pack(side='left', padx=(0,5))
    created_vars['random_max'] = ttk.IntVar(value=config.get('random_max', 5))
    random_max_entry = ttk.Entry(random_sleep_details_frame, textvariable=created_vars['random_max'], width=5)
    random_max_entry.pack(side='left', padx=(0,5))
    ToolTip(random_max_entry).update_text(loc.get('random_max_tooltip', fallback="Maximum delay duration (seconds)."))
    def _toggle_sleep_details():
        is_static = created_vars['sleep_type'].get() == "static"
        if is_static:
            static_sleep_frame.pack(anchor='w', padx=20, pady=2)
            random_sleep_details_frame.pack_forget()
        else:
            static_sleep_frame.pack_forget()
            random_sleep_details_frame.pack(fill='x', padx=20, pady=5)
    def _toggle_sleep_options():
        if created_vars['enable_sleep'].get():
            sleep_options_frame.pack(fill='x', padx=10, pady=5)
            _toggle_sleep_details()
        else:
            sleep_options_frame.pack_forget()
    def _toggle_loop_details():
        is_count = created_vars['loop_type'].get() == LoopConfig.LOOP_TYPE_COUNT
        if is_count:
            count_details_frame.pack(fill='x', anchor='w', padx=20, pady=2)
            condition_details_frame.pack_forget()
        else:
            count_details_frame.pack_forget()
            condition_details_frame.pack(fill='x', padx=20, pady=5)
    def _toggle_loop_options():
        if created_vars['enable_loop'].get():
            loop_options_frame.pack(fill='x', padx=10, pady=5)
            sleep_control_frame.pack(fill='x', padx=0, pady=0)
            _toggle_loop_details()
            _toggle_sleep_options()
        else:
            loop_options_frame.pack_forget()
            sleep_control_frame.pack_forget()
    enable_loop_check.config(command=_toggle_loop_options)
    static_radio.config(command=_toggle_sleep_details)
    random_radio.config(command=_toggle_sleep_details)
    created_vars['enable_sleep'].trace_add('write', lambda *args: _toggle_sleep_options())
    count_radio.config(command=_toggle_loop_details)
    condition_radio.config(command=_toggle_loop_details)
    _toggle_loop_options()
    return created_vars
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\version_manager_popup.py
# JUMLAH BARIS : 117
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import Toplevel, messagebox, ttk as tk_ttk, Menu
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class VersionManagerPopup(Toplevel):
    def __init__(self, parent_workflow_tab, kernel_instance, preset_name):
        super().__init__(parent_workflow_tab)
        self.parent_workflow_tab = parent_workflow_tab
        self.kernel = kernel_instance
        self.loc = self.kernel.get_service("localization_manager")
        self.preset_name = preset_name
        self.api_client = ApiClient(kernel=self.kernel)
        self.title(self.loc.get('version_manager_title', preset_name=self.preset_name))
        self.transient(parent_workflow_tab)
        self.grab_set()
        self.resizable(False, False)
        theme_manager = self.kernel.get_service("theme_manager")
        self.colors = theme_manager.get_colors() if theme_manager else {}
        self.apply_styles(self.colors)
        self.create_widgets()
        self.populate_versions()
        self.update_idletasks()
        x = parent_workflow_tab.winfo_x() + (parent_workflow_tab.winfo_width() // 2) - (self.winfo_width() // 2)
        y = parent_workflow_tab.winfo_y() + (parent_workflow_tab.winfo_height() // 2) - (self.winfo_height() // 2)
        self.geometry(f"+{x}+{y}")
    def apply_styles(self, colors):
        style = tk_ttk.Style(self)
        style.configure('TFrame', background=colors.get('bg'))
        style.configure('TLabel', background=colors.get('bg'), foreground=colors.get('fg'))
        style.configure("Custom.Treeview", background=colors.get('dark'), foreground=colors.get('fg'), fieldbackground=colors.get('dark'), borderwidth=0, rowheight=25)
        style.configure("Custom.Treeview.Heading", background=colors.get('bg'), foreground=colors.get('info'), font=('Helvetica', 10, 'bold'))
        style.map('Custom.Treeview', background=[('selected', colors.get('selectbg'))], foreground=[('selected', colors.get('selectfg'))])
        self.configure(background=colors.get('bg'))
    def create_widgets(self):
        main_frame = ttk.Frame(self, padding=15, style='TFrame')
        main_frame.pack(fill='both', expand=True)
        ttk.Label(main_frame, text=self.loc.get('version_list_label'), style='TLabel').pack(anchor='w', pady=(0, 5))
        tree_frame = ttk.Frame(main_frame)
        tree_frame.pack(fill='both', expand=True, pady=(0, 10))
        columns = ("Nama Versi", "Tanggal & Waktu", "Aksi")
        self.version_tree = tk_ttk.Treeview(tree_frame, columns=columns, show="headings", style="Custom.Treeview")
        self.version_tree.heading("Nama Versi", text=self.loc.get('version_name_column', fallback="Version Name"))
        self.version_tree.heading("Tanggal & Waktu", text=self.loc.get('version_datetime_column', fallback="Date & Time"))
        self.version_tree.heading("Aksi", text=self.loc.get('version_actions_column', fallback="Actions"))
        self.version_tree.column("Nama Versi", width=250, anchor='w')
        self.version_tree.column("Tanggal & Waktu", width=150, anchor='center')
        self.version_tree.column("Aksi", width=120, anchor='center')
        tree_scrollbar_y = ttk.Scrollbar(tree_frame, orient="vertical", command=self.version_tree.yview)
        self.version_tree.configure(yscrollcommand=tree_scrollbar_y.set)
        self.version_tree.pack(side='left', fill='both', expand=True)
        tree_scrollbar_y.pack(side='right', fill='y')
        self.version_tree.bind("<Button-1>", self._on_tree_click)
        button_frame = ttk.Frame(main_frame, style='TFrame')
        button_frame.pack(fill='x', side='bottom', pady=(5, 0))
        ttk.Button(button_frame, text=self.loc.get('button_close', fallback="Close"), command=self.destroy, style='secondary.TButton').pack(side='right')
    def populate_versions(self):
        for item in self.version_tree.get_children():
            self.version_tree.delete(item)
        self.kernel.write_to_log(f"UI: Requesting versions for '{self.preset_name}' via API.", "DEBUG")
        success, versions = self.api_client.get_preset_versions(self.preset_name)
        if not versions or not success:
            self.version_tree.insert("", "end", values=(self.loc.get('no_versions_found'), "", ""), tags=("no_data",))
            return
        for version_info in versions:
            version_display_name = self.loc.get('version_name_format', timestamp=version_info['timestamp'])
            action_placeholder = self.loc.get('version_action_column_placeholder', fallback="Click for Actions...")
            self.version_tree.insert("", "end", values=(version_display_name, version_info['timestamp'], action_placeholder), tags=(version_info['filename'],))
    def _on_tree_click(self, event):
        region = self.version_tree.identify_region(event.x, event.y)
        column_id = self.version_tree.identify_column(event.x)
        if region == "cell" and column_id == "#3":
            item_id = self.version_tree.identify_row(event.y)
            if not item_id: return
            version_filename = self.version_tree.item(item_id, "tags")[0]
            if version_filename == "no_data": return
            self._show_action_menu(event, version_filename)
    def _show_action_menu(self, event, version_filename):
        context_menu = Menu(self, tearoff=0)
        context_menu.add_command(label=self.loc.get('version_action_load'), command=lambda: self._load_selected_version(version_filename))
        context_menu.add_command(label=self.loc.get('version_action_delete'), command=lambda: self._delete_selected_version(version_filename))
        try:
            context_menu.tk_popup(event.x_root, event.y_root)
        finally:
            context_menu.grab_release()
    def _load_selected_version(self, version_filename):
        if not messagebox.askyesno(
            self.loc.get('confirm_load_version_title', fallback="Load Version?"),
            self.loc.get('confirm_load_version_message', version_name=version_filename, preset_name=self.preset_name)
        ):
            return
        self.kernel.write_to_log(self.loc.get('log_loading_version', preset_name=self.preset_name, version_name=version_filename), "INFO")
        success, workflow_data = self.api_client.load_preset_version(self.preset_name, version_filename)
        if success and workflow_data:
            self.parent_workflow_tab.canvas_area_instance.canvas_manager.load_workflow_data(workflow_data)
            messagebox.showinfo(self.loc.get('success_title'), self.loc.get('log_version_loaded_success', preset_name=self.preset_name, version_name=version_filename))
            self.destroy()
        else:
            messagebox.showerror(self.loc.get('error_title'), self.loc.get('log_version_load_error', preset_name=self.preset_name, version_name=version_filename, error="Failed to load version file via API."))
    def _delete_selected_version(self, version_filename):
        if not messagebox.askyesno(
            self.loc.get('confirm_delete_version_title'),
            self.loc.get('confirm_delete_version_message', version_name=version_filename)
        ):
            return
        success, response = self.api_client.delete_preset_version(self.preset_name, version_filename)
        if success:
            messagebox.showinfo(self.loc.get('success_title'), self.loc.get('log_version_deleted_success', preset_name=self.preset_name, version_name=version_filename))
            self.populate_versions()
        else:
            messagebox.showerror(self.loc.get('error_title'), self.loc.get('log_version_delete_error', preset_name=self.preset_name, version_name=version_filename, error=response))
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\workflow_editor_tab.py
# JUMLAH BARIS : 194
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import filedialog, messagebox, simpledialog, TclError
import threading
import os
import shutil
import json
import uuid
import time
import random
from flowork_gui.views.dashboard_manager import DashboardManager # PENAMBAHAN: Correct absolute import.
from .ui_components.controllers.TabActionHandler import TabActionHandler
class WorkflowEditorTab(ttk.Frame):
    def __init__(self, parent_notebook, api_client, loc_service, tab_id=None, is_new_tab=False):
        super().__init__(parent_notebook)
        self.api_client = api_client
        self.loc = loc_service
        self.kernel = None # ADDED: Explicitly set kernel to None to catch any remaining direct calls.
        self.tab_id = tab_id or str(uuid.uuid4())
        self.is_new_tab = is_new_tab
        self._execution_state = "IDLE"
        self._drag_data_toplevel = {}
        self.active_suggestions = {}
        self.action_handler = TabActionHandler(self, self.api_client, self.loc)
        self.canvas_area_instance = None
        self.log_viewer_instance = None
        self.logic_toolbox_instance = None
        self.plugin_toolbox_instance = None
        self.widget_toolbox_instance = None
        self.cmd_widget_instance = None
        self.dashboard_manager = None
        self._content_initialized = False
        ttk.Label(self, text="Loading Dashboard...").pack(expand=True) # English Hardcode
    def _initialize_content(self):
        """Creates the actual widgets for the tab the first time it's viewed."""
        if self._content_initialized:
            return
        for widget in self.winfo_children():
            widget.destroy()
        class MockKernel:
            def __init__(self, api_client, loc):
                self.api_client = api_client
                self.loc = loc
                self.write_to_log = lambda msg, lvl="INFO": print(f"[{lvl}] {msg}") # Simple logger
                self.services = {} # Mock services dictionary
            def get_service(self, service_name):
                if service_name not in self.services:
                    class MockService:
                        def __init__(self, api_client):
                            self.api_client = api_client
                    self.services[service_name] = MockService(self.api_client)
                return self.services[service_name]
        mock_kernel = MockKernel(self.api_client, self.loc)
        self.dashboard_manager = DashboardManager(self, self, mock_kernel, self.tab_id, self.is_new_tab)
        self.create_widgets()
        self.apply_styles()
        self.after(50, self.refresh_content_and_states)
        self._subscribe_to_events()
        self._content_initialized = True
    def _subscribe_to_events(self):
        """
        Subscribes this tab to relevant events from the EventBus.
        """
        pass
    def _handle_suggestion_event(self, event_data):
        """
        Callback triggered when an AI Co-pilot suggestion is received.
        It now finds the node by its unique ID (UUID) instead of its name.
        """
        preset_name = event_data.get("preset_name")
        if not self.canvas_area_instance or not hasattr(self.canvas_area_instance, 'preset_combobox'):
            return
        current_preset_on_canvas = self.canvas_area_instance.preset_combobox.get()
        if preset_name != current_preset_on_canvas:
            return
        target_node_id = event_data.get("node_id")
        if not target_node_id or target_node_id not in self.canvas_area_instance.canvas_manager.canvas_nodes:
            return
        suggestion = event_data.get("suggestion_text")
        self.active_suggestions[target_node_id] = suggestion
        self.run_on_ui_thread(self._refresh_suggestion_indicators)
    def _refresh_suggestion_indicators(self):
        """Clears and redraws all suggestion indicators based on the current state."""
        if not self.canvas_area_instance or not self.canvas_area_instance.canvas_manager:
            return
        visual_manager = self.canvas_area_instance.canvas_manager.visual_manager
        visual_manager.clear_all_suggestion_indicators()
        for node_id, suggestion_text in self.active_suggestions.items():
            visual_manager.show_suggestion_indicator(node_id, suggestion_text)
    def _clear_all_suggestions(self):
        """
        Clears all active suggestions and their visual indicators from the canvas.
        """
        self.active_suggestions.clear()
        if self.canvas_area_instance and self.canvas_area_instance.canvas_manager:
            self.run_on_ui_thread(self._refresh_suggestion_indicators)
    def destroy(self):
        super().destroy()
    def run_workflow_from_preset(self, nodes, connections, initial_payload):
        self._clear_all_suggestions()
        self.action_handler.run_workflow_from_preset(nodes, connections, initial_payload)
    def refresh_content_and_states(self):
        self.populate_module_toolbox()
        self.populate_plugin_panel()
        self.populate_preset_dropdown()
        if hasattr(self, 'widget_toolbox_instance') and self.widget_toolbox_instance and hasattr(self.widget_toolbox_instance, 'populate_widget_toolbox'):
            self.widget_toolbox_instance.populate_widget_toolbox()
        self._update_button_states()
    def create_widgets(self):
        dashboard_area = ttk.Frame(self) # Removed style='TFrame' to use default
        dashboard_area.pack(expand=True, fill='both')
        add_widget_button = ttk.Button(dashboard_area, text="+", style="success.Outline.TButton", width=3, command=self.show_add_widget_menu)
        add_widget_button.place(relx=1.0, rely=0.0, x=-5, y=5, anchor="ne")
    def save_dashboard_layout(self):
        if self.dashboard_manager:
            self.dashboard_manager.save_layout()
    def clear_dashboard_widgets(self):
        if self.dashboard_manager:
            self.dashboard_manager.clear_all_widgets()
    def apply_styles(self, colors=None):
        pass
    def show_add_widget_menu(self):
        if not self.dashboard_manager: return
        menu = self.dashboard_manager._create_add_widget_menu(event_x=self.winfo_width() - 150, event_y=40)
        try:
            menu.tk_popup(self.winfo_rootx() + self.winfo_width() - 10, self.winfo_rooty() + 40)
        finally:
            menu.grab_release()
    def populate_module_toolbox(self):
        logic_toolbox = getattr(self, 'logic_toolbox_instance', None)
        if logic_toolbox and hasattr(logic_toolbox, 'populate_module_toolbox'):
            logic_toolbox.populate_module_toolbox()
    def populate_plugin_panel(self):
        plugin_toolbox = getattr(self, 'plugin_toolbox_instance', None)
        if plugin_toolbox and hasattr(plugin_toolbox, 'populate_plugin_panel'):
            plugin_toolbox.populate_plugin_panel()
    def populate_preset_dropdown(self):
        if self.canvas_area_instance and hasattr(self.canvas_area_instance, 'populate_preset_dropdown'):
            self.canvas_area_instance.populate_preset_dropdown()
    def on_drag_start(self, event):
        tree_widget = event.widget
        item_id = tree_widget.identify_row(event.y)
        if not item_id or tree_widget.tag_has('category', item_id): return
        self._drag_data_toplevel = {"item_id": item_id, "widget": None, "tree_widget": tree_widget}
    def on_drag_motion(self, event):
        if not hasattr(self, '_drag_data_toplevel') or not self._drag_data_toplevel.get("item_id"): return
        if not self._drag_data_toplevel.get("widget"):
            item_text = self._drag_data_toplevel["tree_widget"].item(self._drag_data_toplevel["item_id"], "text").strip()
            self._drag_data_toplevel["widget"] = ttk.Label(self.winfo_toplevel(), text=item_text, style="Module.TLabel", relief="solid", borderwidth=1)
        self._drag_data_toplevel["widget"].place(x=event.x_root - self.winfo_toplevel().winfo_rootx(), y=event.y_root - self.winfo_toplevel().winfo_rooty())
    def on_drag_release(self, event):
        if hasattr(self, '_drag_data_toplevel') and self._drag_data_toplevel.get("widget"):
            self._drag_data_toplevel["widget"].destroy()
        if self.canvas_area_instance and hasattr(self.canvas_area_instance, 'canvas_manager') and self.canvas_area_instance.canvas_manager and hasattr(self, '_drag_data_toplevel') and self._drag_data_toplevel.get("item_id"):
            self.canvas_area_instance.canvas_manager.interaction_manager.on_drag_release(event, self._drag_data_toplevel["item_id"], self._drag_data_toplevel["tree_widget"])
        self._drag_data_toplevel = {}
    def run_on_ui_thread(self, func, *args):
        if self.winfo_exists():
            self.after(0, func, *args)
    def _set_execution_state_from_thread(self, new_state):
        self._execution_state = new_state
        self._update_button_states()
    def _update_button_states(self):
        if not self._content_initialized or not self.canvas_area_instance or not hasattr(self.canvas_area_instance, 'run_button'): return
        is_idle = self._execution_state == "IDLE"
        preset_state = "readonly" if is_idle else "disabled"
        if hasattr(self.canvas_area_instance, 'preset_combobox'):
            self.canvas_area_instance.preset_combobox.config(state=preset_state)
        if hasattr(self.canvas_area_instance, 'delete_preset_button'):
            self.canvas_area_instance.delete_preset_button.config(state="normal" if is_idle else "disabled")
        if hasattr(self.canvas_area_instance, 'save_preset_button'):
            self.canvas_area_instance.save_preset_button.config(state="normal" if is_idle else "disabled")
        if hasattr(self.canvas_area_instance, 'manage_versions_button'):
            self.canvas_area_instance.manage_versions_button.config(state="normal" if is_idle else "disabled")
        if hasattr(self.canvas_area_instance, 'simulate_button'):
            self.canvas_area_instance.simulate_button.config(state="normal" if is_idle else "disabled")
        btn_map = {
            "IDLE": ("Run Workflow", "warning.TButton", self.action_handler.run_workflow, "normal", "Pause", "info.TButton", self.action_handler.pause_workflow, "disabled"),
            "RUNNING": ("Stop Workflow", "danger.TButton", self.action_handler.stop_workflow, "normal", "Pause", "info.TButton", self.action_handler.pause_workflow, "normal"),
            "PAUSED": ("Stop Workflow", "danger.TButton", self.action_handler.stop_workflow, "normal", "Resume", "success.TButton", self.action_handler.resume_workflow, "normal"),
            "STOPPING": ("Stopping...", "secondary.TButton", lambda: None, "disabled", "Pause", "info.TButton", lambda: None, "disabled"),
        }
        run_txt, run_sty, run_cmd, run_st, pause_txt, pause_sty, pause_cmd, pause_st = btn_map.get(self._execution_state, btn_map["IDLE"])
        if hasattr(self.canvas_area_instance, 'run_button'):
            self.canvas_area_instance.run_button.config(text=run_txt, style=run_sty, command=run_cmd, state=run_st)
        if hasattr(self.canvas_area_instance, 'pause_resume_button'):
            self.canvas_area_instance.pause_resume_button.config(text=pause_txt, style=pause_sty, command=pause_cmd, state=pause_st)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\canvas_components\connection_manager.py
# JUMLAH BARIS : 118
#######################################################################

```py
import uuid
from api_client.client import ApiClient
class ConnectionManager:
    """
    Manages all aspects of connection lines on the canvas, including creation, deletion, and position updates.
    (MODIFIED) Now supports different connection types and dynamically finds port widget locations.
    (FIXED) Added update_idletasks() to ensure correct coordinates for placed port widgets.
    """
    def __init__(self, canvas_manager, kernel, canvas_widget):
        self.api_client = ApiClient()
        self.canvas_manager = canvas_manager
        self.kernel = kernel
        self.canvas = canvas_widget
        self.loc = self.kernel.get_service("localization_manager")
    def _get_port_widget_center(self, node_id, port_name, port_type):
        """(ADDED) Helper function to find the absolute center coordinates of any port widget."""
        node_data = self.canvas_manager.canvas_nodes.get(node_id)
        if not node_data: return None, None
        port_list_key = f"{port_type}_ports"
        port_list = node_data.get(port_list_key, [])
        port_widget = next((p['widget'] for p in port_list if p['name'] == port_name), None)
        if port_widget and port_widget.winfo_exists():
            self.canvas.update_idletasks()
            x = port_widget.winfo_rootx() - self.canvas.winfo_rootx() + (port_widget.winfo_width() / 2)
            y = port_widget.winfo_rooty() - self.canvas.winfo_rooty() + (port_widget.winfo_height() / 2)
            return x, y
        return None, None
    def create_connection(self, start_node_id, end_node_id, existing_id=None, source_port_name=None, connection_type='data', target_port_name=None):
        canvas_nodes = self.canvas_manager.canvas_nodes
        canvas_connections = self.canvas_manager.canvas_connections
        colors = self.canvas_manager.colors
        start_port_type = 'tool' if connection_type == 'tool' else 'output'
        start_x, start_y = self._get_port_widget_center(start_node_id, source_port_name, start_port_type)
        if start_x is None:
            start_widget = canvas_nodes[start_node_id]["widget"]
            start_x = start_widget.winfo_x() + start_widget.winfo_width()
            start_y = start_widget.winfo_y() + start_widget.winfo_height() / 2
        end_port_type = 'tool' if connection_type == 'tool' else 'input'
        end_x, end_y = self._get_port_widget_center(end_node_id, target_port_name, end_port_type)
        if end_x is None:
            end_widget = canvas_nodes[end_node_id]["widget"]
            end_x = end_widget.winfo_x()
            end_y = end_widget.winfo_y() + end_widget.winfo_height() / 2
        offset = abs(end_x - start_x) / 2
        control_x1 = start_x + offset
        control_y1 = start_y
        control_x2 = end_x - offset
        control_y2 = end_y
        line_style = {
            'fill': colors.get('info', '#17a2b8'),
            'width': 2,
            'dash': (6, 4),
            'smooth': True
        } if connection_type == 'tool' else {
            'fill': colors.get('success', '#28a745'),
            'width': 2,
            'smooth': True
        }
        line_id = self.canvas.create_line(start_x, start_y, control_x1, control_y1, control_x2, control_y2, end_x, end_y, tags=("connection_line",), **line_style)
        conn_id = existing_id or str(uuid.uuid4())
        canvas_connections[conn_id] = {
            "line_id": line_id,
            "from": start_node_id,
            "to": end_node_id,
            "source_port_name": source_port_name,
            "target_port_name": target_port_name,
            "type": connection_type
        }
        return conn_id
    def delete_connection(self, conn_id_to_delete, feedback=True):
        canvas_connections = self.canvas_manager.canvas_connections
        if conn_id_to_delete in canvas_connections:
            line_id = canvas_connections[conn_id_to_delete]['line_id']
            if self.canvas.find_withtag(line_id):
                self.canvas.delete(line_id)
            del canvas_connections[conn_id_to_delete]
            if feedback:
                self.kernel.write_to_log(self.loc.get('connection_deleted_success', conn_id=conn_id_to_delete, fallback=f"Connection '{conn_id_to_delete}' deleted."), "INFO")
    def update_connections_for_node(self, node_id):
        canvas_nodes = self.canvas_manager.canvas_nodes
        canvas_connections = self.canvas_manager.canvas_connections
        connections_to_update = []
        for conn_id, conn_data in list(canvas_connections.items()):
            if conn_data["from"] == node_id or conn_data["to"] == node_id:
                connections_to_update.append((conn_id, conn_data))
        for conn_id, conn_data in connections_to_update:
            if conn_data["from"] in canvas_nodes and conn_data["to"] in canvas_nodes:
                self.delete_connection(conn_id, feedback=False)
                self.create_connection(
                    start_node_id=conn_data["from"],
                    end_node_id=conn_data["to"],
                    existing_id=conn_id,
                    source_port_name=conn_data.get("source_port_name"),
                    target_port_name=conn_data.get("target_port_name"),
                    connection_type=conn_data.get("type", 'data')
                )
            else:
                self.delete_connection(conn_id, feedback=False)
    def recreate_connections(self, connections_data):
        canvas_nodes = self.canvas_manager.canvas_nodes
        for conn_data in connections_data:
            if conn_data.get("from") in canvas_nodes and conn_data.get("to") in canvas_nodes:
                self.create_connection(
                    start_node_id=conn_data["from"],
                    end_node_id=conn_data["to"],
                    existing_id=conn_data.get("id"),
                    source_port_name=conn_data.get("source_port_name"),
                    target_port_name=conn_data.get("target_port_name"),
                    connection_type=conn_data.get("type", "data")
                )
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\canvas_components\interaction_manager.py
# JUMLAH BARIS : 87
#######################################################################

```py
from tkinter import Menu
from ..properties_popup import PropertiesPopup
from .interactions.node_interaction_handler import NodeInteractionHandler
from .interactions.connection_interaction_handler import ConnectionInteractionHandler
from .interactions.canvas_navigation_handler import CanvasNavigationHandler
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class InteractionManager:
    """
    Manages all user interactions with the canvas by coordinating specialized handlers.
    (FIXED) Now correctly resets the node handler's move data to the new format.
    """
    def __init__(self, canvas_manager, kernel, canvas_widget):
        self.api_client = ApiClient()
        self.canvas_manager = canvas_manager
        self.kernel = kernel
        self.canvas = canvas_widget
        self.loc = self.kernel.get_service("localization_manager")
        self.node_handler = NodeInteractionHandler(self.canvas_manager)
        self.connection_handler = ConnectionInteractionHandler(self.canvas_manager)
        self.navigation_handler = CanvasNavigationHandler(self.canvas_manager)
        self._drag_data = {}
        self._resize_data = {} # (COMMENT) Added missing initialization for resize data
    def bind_events(self):
        """Binds all canvas events to the appropriate specialized handlers."""
        self.canvas.bind("<Motion>", self.connection_handler.on_line_motion)
        self.canvas.tag_bind("connection_line", "<ButtonPress-3>", self.connection_handler.show_line_context_menu)
        self.canvas.bind("<ButtonPress-2>", self.navigation_handler.on_pan_start)
        self.canvas.bind("<B2-Motion>", self.navigation_handler.on_pan_move)
        self.canvas.bind("<ButtonRelease-2>", self.navigation_handler.on_pan_end)
        self.canvas.bind("<Delete>", self.node_handler.on_delete_key_press)
        self.canvas.bind("<ButtonPress-1>", self.canvas_manager.node_manager.deselect_all_nodes)
        self.canvas.bind("<ButtonPress-3>", self._handle_canvas_right_click)
    def _handle_canvas_right_click(self, event):
        """Decides whether to cancel line drawing or show the context menu."""
        if self.connection_handler._line_data.get("line_id"):
            self.connection_handler._cancel_line_drawing(event)
        else:
            self._show_canvas_context_menu(event)
    def _show_canvas_context_menu(self, event):
        """Displays the main canvas context menu for adding modules or text notes."""
        context_menu = Menu(self.canvas, tearoff=0)
        context_menu.add_command(
            label=self.loc.get('context_menu_add_note', fallback="Add Text Note"),
            command=lambda: self.canvas_manager.create_label(self.canvas.canvasx(event.x), self.canvas.canvasy(event.y))
        )
        context_menu.add_separator()
        try:
            context_menu.tk_popup(event.x_root, event.y_root)
        finally:
            context_menu.grab_release()
    def on_drag_release(self, event, item_id, tree_widget):
        if item_id:
            x_root, y_root = event.x_root, event.y_root
            canvas_x0, canvas_y0 = self.canvas.winfo_rootx(), self.canvas.winfo_rooty()
            canvas_x1, canvas_y1 = canvas_x0 + self.canvas.winfo_width(), canvas_y0 + self.canvas.winfo_height()
            if canvas_x0 <= x_root <= canvas_x1 and canvas_y0 <= y_root <= canvas_y1:
                zoom_level = self.navigation_handler.zoom_level
                canvas_x = self.canvas.canvasx(x_root - canvas_x0)
                canvas_y = self.canvas.canvasy(y_root - canvas_y0)
                world_x = canvas_x / zoom_level
                world_y = canvas_y / zoom_level
                module_id = item_id
                module_manager = self.kernel.get_service("module_manager_service")
                if not module_manager: return
                manifest = module_manager.get_manifest(module_id)
                if manifest:
                    self.canvas_manager.node_manager.create_node_on_canvas(name=manifest.get('name', 'Unknown'), x=world_x, y=world_y, module_id=module_id)
            self._reset_all_actions()
    def _reset_all_actions(self):
        """Resets any ongoing user interaction state, like line drawing."""
        if hasattr(self.canvas_manager.coordinator_tab, 'unbind_all'):
            self.canvas_manager.coordinator_tab.unbind_all("<B1-Motion>")
            self.canvas_manager.coordinator_tab.unbind_all("<ButtonRelease-1>")
        if hasattr(self.canvas_manager.coordinator_tab, '_drag_data_toplevel'):
             if self.canvas_manager.coordinator_tab._drag_data_toplevel.get("widget") and self.canvas_manager.coordinator_tab._drag_data_toplevel["widget"].winfo_exists():
                self.canvas_manager.coordinator_tab._drag_data_toplevel["widget"].destroy()
             self.canvas_manager.coordinator_tab._drag_data_toplevel = {}
        self.node_handler._move_data = {"id": None, "x": 0, "y": 0}
        self.connection_handler._cancel_line_drawing()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\canvas_components\node_manager.py
# JUMLAH BARIS : 583
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import TclError, messagebox, scrolledtext
import uuid
import json
from flowork_gui.views.custom_widgets.tooltip import ToolTip # PENAMBAHAN: Importing ToolTip from its new correct location within the GUI project.
import threading
import time
import os
from flowork_gui.api_client.client import ApiClient # PENAMBAHAN: Standard ApiClient import for GUI components.
try:
    from PIL import Image, ImageTk
    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False
class NodeManager:
    """
    Manages the lifecycle of nodes on the canvas.
    (MODIFIED V15) Now handles cases where a manifest is not found for a module ID in a preset, preventing crashes.
    """
    def __init__(self, canvas_manager, kernel, canvas_widget):
        self.api_client = ApiClient() # PENAMBAHAN: Initialize ApiClient
        self.canvas_manager = canvas_manager
        self.kernel = kernel
        self.canvas = canvas_widget
        self.loc = self.kernel.get_service("localization_manager")
        self.logger = self.kernel.write_to_log
        self.hovered_node_id = None
        self.icon_cache = {}
        self.animation_jobs = {}
    def move_node_by_delta(self, node_id, dx, dy):
        if self.canvas.find_withtag(node_id):
            self.canvas.move(node_id, dx, dy)
            self.canvas.update_idletasks()
            self.canvas_manager.connection_manager.update_connections_for_node(node_id)
    def _apply_style_to_node_widgets(self, node_id, frame_style_name):
        if node_id not in self.canvas_manager.canvas_nodes: return
        node_data = self.canvas_manager.canvas_nodes[node_id]
        if node_data.get("module_id") == 'agent_host_module':
             border_frame = node_data.get('border_frame')
             if not border_frame or not border_frame.winfo_exists(): return
             border_frame.config(style='AgentBorder.Selected.TFrame' if "Selected" in frame_style_name or "Hover" in frame_style_name else 'AgentBorder.Normal.TFrame')
             return
        if node_data.get('shape') in ['circle', 'icon_box', 'agent_brain']:
            shape_id = node_data.get('oval_id')
            if shape_id and self.canvas.find_withtag(shape_id):
                is_active = "Selected" in frame_style_name or "Hover" in frame_style_name
                outline_color = self.canvas_manager.colors.get('success', 'green') if is_active else self.canvas_manager.colors.get('border', 'grey')
                outline_width = 3 if is_active else 1
                if node_data.get('shape') == 'agent_brain':
                    outline_color = self.canvas_manager.colors.get('info', '#17a2b8') if is_active else "#4A00E0"
                self.canvas.itemconfig(shape_id, outline=outline_color, width=outline_width)
            return
        widget = node_data.get('widget')
        if not widget or not widget.winfo_exists(): return
        label_style_name = frame_style_name.replace('.Module.TFrame', '.TLabel')
        def _recursive_style(current_widget):
            if not current_widget.winfo_exists(): return
            if isinstance(current_widget, (ttk.Frame, ttk.LabelFrame)):
                current_widget.config(style=frame_style_name)
            elif isinstance(current_widget, ttk.Label):
                if "Port" not in current_widget.cget('style') and not hasattr(current_widget, '_is_icon_label'):
                    pass
            for child in current_widget.winfo_children():
                _recursive_style(child)
        _recursive_style(widget)
    def _load_and_display_icon(self, parent_widget, module_id, module_manager):
        if not PIL_AVAILABLE: return None
        module_data = module_manager.loaded_modules.get(module_id)
        if not module_data: return None
        manifest = module_data.get("manifest", {})
        icon_filename = manifest.get("icon_file")
        if not icon_filename: return None
        icon_path = os.path.join(module_data.get("path"), icon_filename)
        if not os.path.exists(icon_path): return None
        icon_label = ttk.Label(parent_widget, style="Glass.TLabel")
        icon_label._is_icon_label = True # (COMMENT) Custom flag to prevent style changes.
        if icon_filename.lower().endswith('.gif'):
            self._animate_gif(icon_label, icon_path, module_id)
        else: # (COMMENT) Assume PNG or other static image
            if icon_path in self.icon_cache:
                photo_image = self.icon_cache[icon_path]
            else:
                try:
                    image = Image.open(icon_path).resize((20, 20), Image.Resampling.LANCZOS)
                    photo_image = ImageTk.PhotoImage(image)
                    self.icon_cache[icon_path] = photo_image
                except Exception as e:
                    self.logger(f"Could not load icon for {module_id}: {e}", "WARN")
                    return None
            icon_label.config(image=photo_image)
            icon_label.image = photo_image # (COMMENT) Keep a reference!
        icon_label.pack(side="left", padx=(0, 5))
        return icon_label
    def _animate_gif(self, label_widget, path, node_id, size=(20,20)):
        if node_id in self.animation_jobs:
            self._stop_gif_animation(node_id)
        try:
            gif = Image.open(path)
            frames = []
            for i in range(gif.n_frames):
                gif.seek(i)
                frame_image = gif.copy().resize(size, Image.Resampling.LANCZOS)
                frames.append(ImageTk.PhotoImage(frame_image))
            if not frames: return
            delay = gif.info.get('duration', 100)
            job_data = {
                'label': label_widget,
                'frames': frames,
                'delay': delay,
                'idx': 0,
                'job_id': None
            }
            self.animation_jobs[node_id] = job_data
            def _update_frame():
                if node_id not in self.animation_jobs or not job_data['label'].winfo_exists():
                    return
                frame = job_data['frames'][job_data['idx']]
                job_data['label'].config(image=frame)
                job_data['idx'] = (job_data['idx'] + 1) % len(job_data['frames'])
                job_data['job_id'] = self.canvas.after(job_data['delay'], _update_frame)
            _update_frame()
        except Exception as e:
            self.logger(f"Could not animate GIF for {node_id}: {e}", "ERROR")
    def _stop_gif_animation(self, node_id):
        if node_id in self.animation_jobs:
            job_data = self.animation_jobs.pop(node_id)
            if job_data.get('job_id'):
                try:
                    self.canvas.after_cancel(job_data['job_id'])
                except TclError:
                    pass
            self.logger(f"Stopped GIF animation for node {node_id}.", "DEBUG")
    def create_node_on_canvas(self, name, x, y, existing_id=None, description="", module_id=None, config_values=None):
        if module_id:
            module_manager = self.kernel.get_service("module_manager_service")
            required_tier = module_manager.get_module_tier(module_id) if module_manager else 'free'
            if not self.kernel.is_tier_sufficient(required_tier):
                messagebox.showwarning(self.loc.get('license_popup_title'), self.loc.get('license_popup_message', module_name=name), parent=self.canvas.winfo_toplevel())
                return
        node_id = existing_id
        if module_id == 'prompt_receiver_module' and not existing_id:
            if "receiver-node-1" in self.canvas_manager.canvas_nodes:
                messagebox.showwarning("Node Already Exists", "You can only have one 'Prompt Receiver' node on the canvas. Its ID is always 'receiver-node-1'.")
                return
            node_id = "receiver-node-1"
        elif not node_id:
            node_id = str(uuid.uuid4())
        canvas_nodes = self.canvas_manager.canvas_nodes
        tooltips = self.canvas_manager.tooltips
        module_manager = self.kernel.get_service("module_manager_service")
        manifest = module_manager.get_manifest(module_id) if module_manager else {}
        if manifest is None:
            self.logger(f"Warning: Manifest for module ID '{module_id}' not found. It may have been uninstalled. Using a default empty manifest.", "WARN")
            manifest = {}
        display_props = manifest.get('display_properties', {})
        node_shape = display_props.get('shape', 'rectangle')
        zoom_level = self.canvas_manager.interaction_manager.navigation_handler.zoom_level
        scaled_x = x * zoom_level
        scaled_y = y * zoom_level
        main_label, widget_to_register = None, None
        output_ports_widgets, input_ports_widgets, tool_ports_widgets = [], [], []
        ports_frame, info_frame, border_frame, status_text, oval_id = None, None, None, None, None
        if node_shape == 'agent_brain':
            node_width = 80
            node_height = 80
            oval_id = self.canvas.create_rectangle(scaled_x, scaled_y, scaled_x + node_width, scaled_y + node_height, fill="#2E0854", outline="#4A00E0", width=1, tags=(node_id, "node_shape"))
            widget_to_register = ttk.Frame(self.canvas, width=node_width-8, height=node_height-8, style='TFrame', relief="solid", borderwidth=1)
            self.canvas.create_window(scaled_x + node_width/2, scaled_y + node_height/2, window=widget_to_register, tags=(node_id, "node_widget_container"))
            if PIL_AVAILABLE and display_props.get("icon_file"):
                icon_filename = display_props.get("icon_file")
                module_data = module_manager.loaded_modules.get(module_id)
                icon_path = os.path.join(module_data.get("path"), icon_filename) if module_data else None
                icon_label = ttk.Label(widget_to_register, style="TLabel")
                icon_label.place(relx=0.5, rely=0.5, anchor="center")
                if icon_path and os.path.exists(icon_path):
                    if icon_filename.lower().endswith('.gif'):
                        self._animate_gif(icon_label, icon_path, node_id, size=(48, 48))
                    else:
                        image = Image.open(icon_path).resize((48, 48), Image.Resampling.LANCZOS)
                        photo_image = ImageTk.PhotoImage(image)
                        self.icon_cache[icon_path] = photo_image
                        icon_label.config(image=photo_image)
                        icon_label.image = photo_image
            connection_handler = self.canvas_manager.interaction_manager.connection_handler
            for port_info in manifest.get('output_ports', []):
                port_name = port_info.get("name")
                port_type = port_info.get("type", "output")
                port_x, port_y = scaled_x + node_width/2, scaled_y
                connector = ttk.Frame(self.canvas, width=24, height=12, style="info.TFrame", relief="raised", borderwidth=1)
                self.canvas.create_window(port_x, port_y, window=connector, tags=(node_id, "node_port"), anchor="s")
                connector.node_id = node_id
                connector.port_name = port_name
                output_ports_widgets.append({"name": port_name, "widget": connector})
                connector.bind("<ButtonPress-1>", lambda e, n=node_id, p=port_name, pt=port_type: connection_handler.start_line_drawing(n, port_name=p, port_type=pt))
                connector.bind("<Enter>", lambda e, w=connector: w.config(style="success.TFrame"))
                connector.bind("<Leave>", lambda e, w=connector: w.config(style="info.TFrame"))
                ToolTip(connector).update_text(port_info.get("tooltip", port_name))
            self.canvas_manager.visual_manager.start_brain_pulse(node_id)
        elif node_shape == 'circle':
            node_width = 120
            node_height = 120
            oval_id = self.canvas.create_oval(scaled_x, scaled_y, scaled_x + node_width, scaled_y + node_height, fill=self.canvas_manager.colors.get('dark', '#343a40'), outline=self.canvas_manager.colors.get('border', 'grey'), width=1, tags=(node_id, "node_shape"))
            widget_to_register = ttk.Frame(self.canvas, width=node_width-10, height=node_height-10)
            widget_to_register.config(style='TFrame')
            self.canvas.create_window(scaled_x + node_width/2, scaled_y + node_height/2, window=widget_to_register, tags=(node_id, "node_widget_container"))
            if PIL_AVAILABLE and display_props.get("icon_file"):
                icon_filename = display_props.get("icon_file")
                all_components = {**module_manager.loaded_modules, **self.kernel.get_service("widget_manager_service").loaded_widgets}
                module_data = all_components.get(module_id)
                icon_path = os.path.join(module_data.get("path"), icon_filename) if module_data else None
                icon_label = ttk.Label(widget_to_register, style="TLabel")
                icon_label.place(relx=0.5, rely=0.4, anchor="center")
                if icon_path and os.path.exists(icon_path):
                    if icon_filename.lower().endswith('.gif'):
                        self._animate_gif(icon_label, icon_path, node_id, size=(48, 48))
                    else:
                        image = Image.open(icon_path).resize((48, 48), Image.Resampling.LANCZOS)
                        photo_image = ImageTk.PhotoImage(image)
                        self.icon_cache[icon_path] = photo_image
                        icon_label.config(image=photo_image)
                        icon_label.image = photo_image
            main_label = ttk.Label(widget_to_register, text=name, wraplength=node_width - 20, justify='center')
            main_label.place(relx=0.5, rely=0.8, anchor="center")
            connection_handler = self.canvas_manager.interaction_manager.connection_handler
            for port_info in manifest.get('output_ports', []):
                port_name = port_info.get("name")
                port_position = port_info.get("port_position", "top")
                port_type = port_info.get("type", "output")
                rely_val, anchor_val = (0.0, "n") if port_position == "top" else (1.0, "s")
                port_x, port_y = scaled_x + node_width/2, scaled_y if port_position == "top" else scaled_y + node_height
                connector = ttk.Frame(self.canvas, width=20, height=10, style="success.TFrame", relief="solid", borderwidth=1)
                self.canvas.create_window(port_x, port_y, window=connector, tags=(node_id, "node_port"), anchor=anchor_val)
                connector.node_id = node_id
                connector.port_name = port_name
                output_ports_widgets.append({"name": port_name, "widget": connector})
                connector.bind("<ButtonPress-1>", lambda e, n=node_id, p=port_name, pt=port_type: connection_handler.start_line_drawing(n, port_name=p, port_type=pt))
                connector.bind("<Enter>", lambda e, w=connector: w.config(style="info.TFrame"))
                connector.bind("<Leave>", lambda e, w=connector: w.config(style="success.TFrame"))
                ToolTip(connector).update_text(port_info.get("tooltip", port_name))
        elif node_shape == 'icon_box':
            node_width = 80
            node_height = 80
            oval_id = self.canvas.create_rectangle(scaled_x, scaled_y, scaled_x + node_width, scaled_y + node_height, fill=self.canvas_manager.colors.get('bg', '#222'), outline=self.canvas_manager.colors.get('border', 'grey'), width=1, tags=(node_id, "node_shape"))
            widget_to_register = ttk.Frame(self.canvas, width=node_width-10, height=node_height-10)
            widget_to_register.config(style='TFrame')
            self.canvas.create_window(scaled_x + node_width/2, scaled_y + node_height/2, window=widget_to_register, tags=(node_id, "node_widget_container"))
            if PIL_AVAILABLE and display_props.get("icon_file"):
                icon_filename = display_props.get("icon_file")
                module_data = module_manager.loaded_modules.get(module_id)
                icon_path = os.path.join(module_data.get("path"), icon_filename) if module_data else None
                icon_label = ttk.Label(widget_to_register, style="TLabel")
                icon_label.place(relx=0.5, rely=0.5, anchor="center")
                if icon_path and os.path.exists(icon_path):
                    if icon_filename.lower().endswith('.gif'):
                        self._animate_gif(icon_label, icon_path, node_id, size=(48, 48))
                    else:
                        image = Image.open(icon_path).resize((48, 48), Image.Resampling.LANCZOS)
                        photo_image = ImageTk.PhotoImage(image)
                        self.icon_cache[icon_path] = photo_image
                        icon_label.config(image=photo_image)
                        icon_label.image = photo_image
            connection_handler = self.canvas_manager.interaction_manager.connection_handler
            for port_info in manifest.get('output_ports', []):
                port_name = port_info.get("name")
                port_type = port_info.get("type", "output")
                port_x, port_y = scaled_x + node_width/2, scaled_y
                connector = ttk.Frame(self.canvas, width=20, height=10, style="success.TFrame", relief="solid", borderwidth=1)
                self.canvas.create_window(port_x, port_y, window=connector, tags=(node_id, "node_port"), anchor="s")
                connector.node_id = node_id
                connector.port_name = port_name
                output_ports_widgets.append({"name": port_name, "widget": connector})
                connector.bind("<ButtonPress-1>", lambda e, n=node_id, p=port_name, pt=port_type: connection_handler.start_line_drawing(n, port_name=p, port_type=pt))
                connector.bind("<Enter>", lambda e, w=connector: w.config(style="info.TFrame"))
                connector.bind("<Leave>", lambda e, w=connector: w.config(style="success.TFrame"))
                ToolTip(connector).update_text(port_info.get("tooltip", port_name))
        elif module_id == 'agent_host_module':
            style = ttk.Style()
            style.configure('AgentBorder.Normal.TFrame', background="#6A2E2E")
            style.configure('AgentBorder.Selected.TFrame', background="yellow")
            style.configure('AgentHeader.TFrame', background="#4A00E0")
            style.configure('AgentHeader.TLabel', background="#4A00E0", foreground="yellow")
            style.configure('AgentBody.TFrame', background="#6A2E2E")
            style.configure('AgentBody.TLabel', background="#6A2E2E")
            style.configure('AgentFooter.TFrame', background="#6A2E2E")
            widget_to_register = ttk.Frame(self.canvas, width=320, height=132)
            widget_to_register.pack_propagate(False)
            border_frame = ttk.Frame(widget_to_register, width=302, height=132, style='AgentBorder.Normal.TFrame')
            border_frame.place(relx=0.5, rely=0.5, anchor='center')
            node_frame = ttk.Frame(border_frame, width=300, height=130)
            node_frame.pack(padx=1, pady=1)
            node_frame.pack_propagate(False)
            header = ttk.Frame(node_frame, height=30, style='AgentHeader.TFrame')
            header.pack(side="top", fill="x")
            main_label = ttk.Label(header, text="Agent Host", font=("Arial", 12, "bold"), style='AgentHeader.TLabel') # English Hardcode
            main_label.pack(pady=5)
            status_text = scrolledtext.ScrolledText(node_frame, height=2, wrap="word", relief="sunken", borderwidth=1, background="#4d2424", foreground="#E0E0E0", font=("Consolas", 8), state="disabled", name=f"agent_status_text_{node_id}")
            status_text.pack(fill='x', expand=True, padx=30, pady=5)
            icon_size = (24, 24)
            tool_ports_config = {'prompt_port': 'icon_prompt.png', 'brain_port': 'icon_brain.png', 'tools_port': 'icon_tools.png'}
            icon_holder_frame = ttk.Frame(node_frame, style='AgentFooter.TFrame')
            icon_holder_frame.pack(side="bottom", fill="x", pady=5)
            for port_name, icon_file in tool_ports_config.items():
                port_container = ttk.Frame(icon_holder_frame, style='AgentFooter.TFrame')
                port_container.pack(side='left', expand=True, fill='x')
                full_path = os.path.join(self.kernel.project_root_path, 'modules', 'agent_host_module', icon_file)
                if os.path.exists(full_path):
                    img = Image.open(full_path).resize(icon_size, Image.Resampling.LANCZOS)
                    photo = ImageTk.PhotoImage(img)
                    icon_label = ttk.Label(port_container, image=photo, style='AgentBody.TLabel', cursor="tcross")
                    icon_label.image = photo
                    icon_label.pack()
                    ToolTip(icon_label).update_text(f"Connect {port_name.replace('_port','').capitalize()} here")
                    icon_label.node_id = node_id
                    icon_label.port_name = port_name
                    icon_label.port_type = 'tool'
                    tool_ports_widgets.append({"name": port_name, "widget": icon_label})
            input_ports_widgets, output_ports_widgets = [], []
            input_port_connector = ttk.Frame(widget_to_register, width=10, height=20, style="success.TFrame")
            input_port_connector.place(x=0, rely=0.5, anchor='w')
            input_port_connector.node_id = node_id; input_port_connector.port_name = "payload_input"; input_port_connector.port_type = 'input'
            input_ports_widgets.append({"name": "payload_input", "widget": input_port_connector})
            output_port_success_connector = ttk.Frame(widget_to_register, width=10, height=20, style="success.TFrame")
            output_port_success_connector.place(relx=1, rely=0.4, anchor='e')
            output_port_success_connector.node_id = node_id; output_port_success_connector.port_name = "success"; output_port_success_connector.port_type = 'output'
            output_ports_widgets.append({"name": "success", "widget": output_port_success_connector})
            output_port_error_connector = ttk.Frame(widget_to_register, width=10, height=20, style="danger.TFrame")
            output_port_error_connector.place(relx=1, rely=0.6, anchor='e')
            output_port_error_connector.node_id = node_id; output_port_error_connector.port_name = "error"; output_port_error_connector.port_type = 'output'
            output_ports_widgets.append({"name": "error", "widget": output_port_error_connector})
            ports_frame, info_frame, status_label = ttk.Frame(node_frame), ttk.Frame(node_frame), ttk.Label(node_frame)
        else:
            node_frame = ttk.Frame(self.canvas, style='Glass.Module.TFrame', padding=(0,0,0,5))
            widget_to_register = node_frame
            content_frame = ttk.Frame(node_frame, style='Glass.Module.TFrame')
            content_frame.pack(side="left", fill="both", expand=True, padx=5)
            header_frame = ttk.Frame(content_frame, style='Glass.Module.TFrame')
            header_frame.pack(fill='x', expand=True, padx=5, pady=(5,0))
            self._load_and_display_icon(header_frame, module_id, module_manager)
            main_label = ttk.Label(header_frame, text=name, style="Glass.TLabel", wraplength=180)
            main_label.pack(side="left", fill='x', expand=True)
            info_frame = ttk.Frame(content_frame, style='Glass.Module.TFrame')
            info_frame.pack(fill='x', padx=10, pady=(2,0))
            status_label = ttk.Label(content_frame, text="", name=f"status_{node_id}", font=("Helvetica", 7), anchor='center', style="Glass.TLabel", wraplength=180)
            status_label.pack(fill='x', padx=10, pady=(0,5))
            ports_frame = ttk.Frame(node_frame, style='Glass.Module.TFrame')
            ports_frame.pack(side="right", fill="y", padx=(0, 5))
        if node_shape not in ['circle', 'icon_box', 'agent_brain']:
            self.canvas.create_window(scaled_x, scaled_y, window=widget_to_register, anchor="nw", tags=(node_id, "node_widget_container"))
        widget_to_register.node_id = node_id
        canvas_nodes[node_id] = {
            "widget": widget_to_register, "main_label": main_label, "name": name, "x": x, "y": y,
            "description": description, "module_id": module_id, "config_values": config_values or {},
            "output_ports": output_ports_widgets, "input_ports": input_ports_widgets, "tool_ports": tool_ports_widgets,
            "ports_widget_frame": ports_frame, "info_widget_frame": info_frame, "border_frame": border_frame,
            "status_display_widget": status_text, "shape": node_shape, "oval_id": oval_id
        }
        if module_id != 'agent_host_module' and node_shape not in ['circle', 'icon_box', 'agent_brain']:
             self.update_node_ports(node_id)
        self.update_node_visual_info(node_id)
        tooltips[node_id] = ToolTip(widget_to_register)
        tooltips[node_id].update_text(description)
        interaction_manager = self.canvas_manager.interaction_manager
        node_interaction_handler = interaction_manager.node_handler
        if node_shape in ['circle', 'icon_box', 'agent_brain']:
            def _bind_recursive_special(widget, event, command):
                 if widget and widget.winfo_exists():
                    widget.bind(event, command)
                    for child in widget.winfo_children():
                        _bind_recursive_special(child, event, command)
            _bind_recursive_special(widget_to_register, "<ButtonPress-1>", node_interaction_handler.on_node_press)
            _bind_recursive_special(widget_to_register, "<B1-Motion>", node_interaction_handler.on_node_motion)
            _bind_recursive_special(widget_to_register, "<ButtonRelease-1>", node_interaction_handler.on_node_release)
            _bind_recursive_special(widget_to_register, "<ButtonPress-3>", node_interaction_handler.show_node_context_menu)
            self.canvas.tag_bind(oval_id, "<ButtonPress-1>", node_interaction_handler.on_node_press)
            self.canvas.tag_bind(oval_id, "<B1-Motion>", node_interaction_handler.on_node_motion)
            self.canvas.tag_bind(oval_id, "<ButtonRelease-1>", node_interaction_handler.on_node_release)
            self.canvas.tag_bind(oval_id, "<ButtonPress-3>", node_interaction_handler.show_node_context_menu)
        else:
            def _bind_recursive(widget, event, command):
                if widget.winfo_exists():
                    widget.bind(event, command)
                    for child in widget.winfo_children():
                        _bind_recursive(child, event, command)
            _bind_recursive(widget_to_register, "<ButtonPress-1>", node_interaction_handler.on_node_press)
            _bind_recursive(widget_to_register, "<B1-Motion>", node_interaction_handler.on_node_motion)
            _bind_recursive(widget_to_register, "<ButtonRelease-1>", node_interaction_handler.on_node_release)
            _bind_recursive(widget_to_register, "<ButtonPress-3>", node_interaction_handler.show_node_context_menu)
        if module_id == 'agent_host_module':
            connection_handler = self.canvas_manager.interaction_manager.connection_handler
            output_port_success_connector.bind("<ButtonPress-1>", lambda e, n=node_id, p="success", pt="output": connection_handler.start_line_drawing(n, port_name=p, port_type=pt))
            output_port_error_connector.bind("<ButtonPress-1>", lambda e, n=node_id, p="error", pt="output": connection_handler.start_line_drawing(n, port_name=p, port_type=pt))
            output_port_success_connector.bind("<Enter>", lambda e, w=output_port_success_connector: w.config(style="info.TFrame"))
            output_port_success_connector.bind("<Leave>", lambda e, w=output_port_success_connector: w.config(style="success.TFrame"))
            output_port_error_connector.bind("<Enter>", lambda e, w=output_port_error_connector: w.config(style="info.TFrame"))
            output_port_error_connector.bind("<Leave>", lambda e, w=output_port_error_connector: w.config(style="danger.TFrame"))
            for port_dict in tool_ports_widgets + input_ports_widgets:
                widget = port_dict['widget']
                widget.bind("<Enter>", lambda e, w=widget: w.config(relief="raised"))
                widget.bind("<Leave>", lambda e, w=widget: w.config(relief="flat"))
                widget.bind("<ButtonPress-1>", node_interaction_handler.on_node_press)
                widget.bind("<ButtonPress-3>", node_interaction_handler.show_node_context_menu)
        if module_id and module_manager:
            instance = module_manager.get_instance(module_id)
            if instance and hasattr(instance, 'on_canvas_load'):
                instance.on_canvas_load(node_id)
        self.kernel.write_to_log(f"NODE CREATED: Name='{name}', ID='{node_id}'", "INFO")
        self.canvas_manager.visual_manager.hide_watermark()
    def _on_node_enter(self, event):
        item_ids = self.canvas.find_withtag("current")
        if not item_ids: return
        tags = self.canvas.gettags(item_ids[0])
        node_id = next((tag for tag in tags if tag in self.canvas_manager.canvas_nodes), None)
        if not node_id:
            widget = event.widget
            while widget and not hasattr(widget, 'node_id'):
                widget = widget.master
            if not widget or not widget.winfo_exists(): return
            node_id = widget.node_id
        if self.hovered_node_id == node_id: return
        self.hovered_node_id = node_id
        if node_id == self.canvas_manager.selected_node_id: return
        self._apply_style_to_node_widgets(node_id, "Hover.Glass.Module.TFrame")
    def _on_node_leave(self, event):
        if not self.hovered_node_id: return
        node_id = self.hovered_node_id
        if node_id not in self.canvas_manager.canvas_nodes: return
        self.hovered_node_id = None
        style_to_apply = "Selected.Glass.Module.TFrame" if node_id == self.canvas_manager.selected_node_id else "Glass.Module.TFrame"
        self._apply_style_to_node_widgets(node_id, style_to_apply)
    def select_node(self, node_id_to_select):
        if self.canvas_manager.selected_node_id and self.canvas_manager.selected_node_id in self.canvas_manager.canvas_nodes:
            self._apply_style_to_node_widgets(self.canvas_manager.selected_node_id, "Glass.Module.TFrame")
        self.canvas_manager.selected_node_id = node_id_to_select
        if self.canvas_manager.selected_node_id in self.canvas_manager.canvas_nodes:
            self._apply_style_to_node_widgets(self.canvas_manager.selected_node_id, "Selected.Glass.Module.TFrame")
    def deselect_all_nodes(self, event=None, from_delete=False):
        if event and self.canvas.find_withtag("current"): return
        if self.canvas_manager.selected_node_id and self.canvas_manager.selected_node_id in self.canvas_manager.canvas_nodes:
            self._apply_style_to_node_widgets(self.canvas_manager.selected_node_id, "Glass.Module.TFrame")
        self.canvas_manager.selected_node_id = None
        if not from_delete and self.canvas_manager.interaction_manager:
            self.canvas_manager.interaction_manager.connection_handler._cancel_line_drawing()
    def update_node_ports(self, node_id):
        canvas_nodes = self.canvas_manager.canvas_nodes
        if node_id not in canvas_nodes: return
        node_data = canvas_nodes[node_id]
        if node_data.get("module_id") == 'agent_host_module' or node_data.get('shape') in ['circle', 'icon_box', 'agent_brain']:
            return
        ports_frame = node_data['ports_widget_frame']
        module_manager = self.kernel.get_service("module_manager_service")
        if not module_manager: return
        manifest = module_manager.get_manifest(node_data['module_id'])
        config_values = node_data.get("config_values", {})
        for widget in ports_frame.winfo_children():
            widget.destroy()
        node_data['output_ports'] = []
        ports_to_create = []
        if manifest and "output_ports" in manifest:
            ports_to_create.extend(manifest["output_ports"])
        module_instance = module_manager.get_instance(node_data['module_id'])
        if module_instance and hasattr(module_instance, 'get_dynamic_ports'):
            dynamic_ports = module_instance.get_dynamic_ports(config_values)
            if dynamic_ports:
                ports_to_create.extend(dynamic_ports)
        for port_info in ports_to_create:
            port_name = port_info.get("name")
            port_display_name = port_info.get("display_name", port_name)
            port_type = port_info.get("type", "output")
            port_label_frame = ttk.Frame(ports_frame, style='Glass.Module.TFrame')
            port_label_frame.pack(anchor='e', pady=1)
            label = ttk.Label(port_label_frame, text=port_display_name, style="Port.Glass.TLabel", anchor='e')
            label.pack(side="left")
            connector = ttk.Frame(port_label_frame, width=10, height=10, style="success.TFrame", relief="solid", borderwidth=1)
            connector.pack(side="left", padx=(5,0))
            connector.node_id = node_id
            connector.port_name = port_name
            node_data['output_ports'].append({"name": port_name, "widget": connector})
            connection_interaction_handler = self.canvas_manager.interaction_manager.connection_handler
            connector.bind("<ButtonPress-1>", lambda e, n=node_id, p=port_name, pt=port_type: connection_interaction_handler.start_line_drawing(n, port_name=p, port_type=pt))
            connector.bind("<Enter>", lambda e, w=connector: w.config(style="info.TFrame"))
            connector.bind("<Leave>", lambda e, w=connector: w.config(style="success.TFrame"))
            ToolTip(connector).update_text(port_info.get("tooltip", port_name))
        if self.canvas_manager.connection_manager:
            self.canvas_manager.connection_manager.update_connections_for_node(node_id)
    def update_node_visual_info(self, node_id):
        if node_id not in self.canvas_manager.canvas_nodes: return
        node_data = self.canvas_manager.canvas_nodes[node_id]
        if node_data.get("module_id") == 'agent_host_module' or node_data.get('shape') in ['circle', 'icon_box', 'agent_brain']:
            status_widget = node_data.get('status_display_widget')
            if status_widget and status_widget.winfo_exists():
                objective = "Menunggu Misi..."
                status_widget.config(state="normal")
                status_widget.delete("1.0", "end")
                status_widget.insert("1.0", objective)
                status_widget.config(state="disabled")
            return
        info_frame = node_data.get("info_widget_frame")
        if not info_frame or not info_frame.winfo_exists(): return
        for widget in info_frame.winfo_children():
            widget.destroy()
        config = node_data.get("config_values", {})
        module_id = node_data.get("module_id")
        badges_frame = ttk.Frame(info_frame, style='Glass.Module.TFrame')
        badges_frame.pack(fill='x', pady=(2,0))
        if config.get('enable_loop', False):
            loop_count = config.get('loop_iterations', 1)
            loop_badge = ttk.Label(badges_frame, text=f"🔁 {loop_count}x", style="Glass.TLabel", font=("Helvetica", 7, "italic"))
            loop_badge.pack(side='left', padx=(0, 5))
            ToolTip(loop_badge).update_text(self.loc.get('badge_tooltip_loop', count=loop_count))
        retry_count = config.get('retry_attempts', 0)
        if retry_count > 0:
            retry_badge = ttk.Label(badges_frame, text=f"🔄 {retry_count}x", style="Glass.TLabel", font=("Helvetica", 7, "italic"))
            retry_badge.pack(side='left', padx=(0, 5))
            ToolTip(retry_badge).update_text(self.loc.get('badge_tooltip_retry', count=retry_count))
        summary_text = ""
        if module_id == 'if_module':
            var = config.get('variable_to_check', '?')
            op = config.get('comparison_operator', '??')
            val = config.get('value_to_compare', '?')
            summary_text = f"IF ({var} {op} {val})"
        elif module_id == 'sleep_module':
            sleep_type = config.get('sleep_type', 'static')
            if sleep_type == 'random_range':
                min_val = config.get('random_min', 1)
                max_val = config.get('random_max', 10)
                summary_text = f"Delay: {min_val}-{max_val}s (Random)"
            else:
                duration = config.get('duration_seconds', 3)
                summary_text = f"Delay: {duration}s"
        elif module_id == 'sub_workflow_module':
             presets = config.get('execution_order', [])
             if presets:
                summary_text = f"Run: {presets[0]}"
                if len(presets) > 1:
                    summary_text += f" (+{len(presets)-1} more)"
        if summary_text:
            summary_label = ttk.Label(info_frame, text=summary_text, style="Glass.TLabel", font=("Helvetica", 7), foreground="#a9a9a9", wraplength=180)
            summary_label.pack(fill='x', pady=(2,0))
    def delete_node(self, node_id_to_delete, feedback=True):
        self._stop_gif_animation(node_id_to_delete)
        node_data = self.canvas_manager.canvas_nodes.get(node_id_to_delete)
        if node_data and node_data.get('shape') == 'agent_brain':
            self.canvas_manager.visual_manager.stop_brain_pulse(node_id_to_delete)
        canvas_nodes = self.canvas_manager.canvas_nodes
        canvas_connections = self.canvas_manager.canvas_connections
        tooltips = self.canvas_manager.tooltips
        if node_id_to_delete not in canvas_nodes: return
        self.canvas.delete(node_id_to_delete)
        connections_to_remove = [cid for cid, cdata in canvas_connections.items() if cdata["from"] == node_id_to_delete or cdata["to"] == node_id_to_delete]
        for conn_id in connections_to_remove:
            self.canvas_manager.connection_manager.delete_connection(conn_id, feedback=False)
        if node_id_to_delete in tooltips:
            del tooltips[node_id_to_delete]
        if canvas_nodes[node_id_to_delete]["widget"] and canvas_nodes[node_id_to_delete]["widget"].winfo_exists():
            canvas_nodes[node_id_to_delete]["widget"].destroy()
        del canvas_nodes[node_id_to_delete]
        self.deselect_all_nodes(from_delete=True)
        if feedback:
            self.kernel.write_to_log(f"Node '{node_id_to_delete}' deleted successfully.", "INFO")
        if not canvas_nodes:
            self.canvas_manager.visual_manager.draw_watermark()
    def duplicate_node(self, node_id_to_duplicate):
        canvas_nodes = self.canvas_manager.canvas_nodes
        if node_id_to_duplicate not in canvas_nodes: return
        original_node_data = canvas_nodes[node_id_to_duplicate]
        new_config_values = json.loads(json.dumps(original_node_data.get('config_values', {})))
        new_x, new_y = original_node_data['x'] + 30, original_node_data['y'] + 30
        self.create_node_on_canvas(
            name=f"{original_node_data['name']} (Copy)",
            x=new_x, y=new_y,
            description=original_node_data.get('description', ''),
            module_id=original_node_data.get('module_id'),
            config_values=new_config_values
        )
        self.kernel.write_to_log(f"Node '{original_node_data['name']}' duplicated successfully.", "INFO")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\canvas_components\properties_manager.py
# JUMLAH BARIS : 87
#######################################################################

```py
import json
from tkinter import messagebox, Text, TclError, Listbox
from tkinter import scrolledtext
from api_contract import EnumVarWrapper # PENAMBAHAN OTOMATIS
from ..properties_popup import PropertiesPopup
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class PropertiesManager:
    """
    Handles all logic related to the Node Properties window, including opening, validating, and saving data.
    (FIXED V2) Now safely handles nodes without a 'main_label' widget.
    """
    def __init__(self, canvas_manager, kernel):
        self.api_client = ApiClient()
        self.canvas_manager = canvas_manager
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
    def open_properties_popup(self, node_id):
        """Opens a Toplevel window for node properties."""
        if node_id in self.canvas_manager.canvas_nodes:
            PropertiesPopup(self.canvas_manager, node_id)
    def save_node_properties(self, node_id, property_vars, popup_window):
        """
        Saves data from the properties popup to the node's state after validation.
        """
        canvas_nodes = self.canvas_manager.canvas_nodes
        if node_id not in canvas_nodes:
            return
        node_data = canvas_nodes[node_id]
        old_name = node_data.get('name', node_id)
        new_name = property_vars.get('name').get() if 'name' in property_vars else old_name
        new_description = ""
        new_config_values = {}
        for key, var_obj in property_vars.items():
            try:
                value_to_save = None
                if isinstance(var_obj, (Text, scrolledtext.ScrolledText)):
                    value_to_save = var_obj.get('1.0', 'end-1c').strip()
                elif isinstance(var_obj, (Listbox, EnumVarWrapper)):
                    value_to_save = var_obj.get()
                elif hasattr(var_obj, 'get'):
                    value_to_save = var_obj.get()
                else:
                    continue
                if key == 'description':
                    new_description = value_to_save
                elif key == 'name':
                    pass
                else:
                    new_config_values[key] = value_to_save
            except (TclError, AttributeError) as e:
                pass # (COMMENT) It's better to ignore this minor error
        module_manager = self.kernel.get_service("module_manager_service")
        if not module_manager: return
        module_instance = module_manager.get_instance(node_data.get("module_id"))
        if module_instance and hasattr(module_instance, 'validate'):
            connected_inputs = [
                conn['source_port_name']
                for conn in self.canvas_manager.canvas_connections.values()
                if conn.get('to') == node_id
            ]
            is_valid, error_message = module_instance.validate(new_config_values, connected_inputs)
            if not is_valid:
                messagebox.showerror(
                    self.loc.get('error_title', fallback="Configuration Error"),
                    error_message,
                    parent=popup_window
                )
                return
        node_data['name'] = new_name
        node_data['description'] = new_description
        node_data["config_values"] = new_config_values
        main_label_widget = node_data.get('main_label')
        if main_label_widget and main_label_widget.winfo_exists():
            main_label_widget.config(text=new_name)
        if node_id in self.canvas_manager.tooltips:
            self.canvas_manager.tooltips[node_id].update_text(new_description)
        self.kernel.write_to_log(f"Properties for node '{new_name}' were updated.", "SUCCESS")
        self.canvas_manager.node_manager.update_node_ports(node_id)
        self.canvas_manager.node_manager.update_node_visual_info(node_id)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\canvas_components\visual_manager.py
# JUMLAH BARIS : 335
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import TclError
from ..custom_widgets.tooltip import ToolTip
from flowork_gui.api_client.client import ApiClient
class VisualManager:
    """
    Manages all visual aspects and effects on the canvas.
    (MODIFIED V3) Added a pulsing animation for 'agent_brain' nodes and redesigned default node style.
    """
    def __init__(self, canvas_manager, kernel, canvas_widget):
        self.api_client = ApiClient()
        self.canvas_manager = canvas_manager
        self.kernel = kernel
        self.canvas = canvas_widget
        self.loc = self.kernel.get_service("localization_manager")
        self._watermark_id = None
        self._sleeping_animation_jobs = {}
        self.suggestion_indicators = {}
        self.processing_animations = {}
        self.brain_pulse_jobs = {}
        self._animation_frames = ['|', '/', '-', '\\']
        self._last_timeline_highlight_id = None
        self._define_highlight_styles()
        self.canvas.bind("<Configure>", self._on_canvas_resize)
        self.draw_grid()
    def _get_original_style(self, node_id):
        """Determines the correct default style for a node (selected or normal)."""
        if node_id == self.canvas_manager.selected_node_id:
            return "Selected.Glass.Module.TFrame"
        else:
            return "Glass.Module.TFrame"
    def start_brain_pulse(self, node_id):
        if node_id in self.brain_pulse_jobs or not self.canvas.winfo_exists():
            return
        node_data = self.canvas_manager.canvas_nodes.get(node_id)
        if not node_data or node_data.get('shape') != 'agent_brain':
            return
        shape_id = node_data.get('oval_id')
        if not shape_id or not self.canvas.find_withtag(shape_id):
            return
        pulse_config = {
            'shape_id': shape_id,
            'min_width': 1.0,
            'max_width': 3.0,
            'step': 0.2,
            'direction': 1
        }
        self.brain_pulse_jobs[node_id] = pulse_config
        self._animate_brain_pulse(node_id)
    def _animate_brain_pulse(self, node_id):
        if node_id not in self.brain_pulse_jobs or not self.canvas.winfo_exists():
            return
        pulse_config = self.brain_pulse_jobs[node_id]
        shape_id = pulse_config['shape_id']
        if not self.canvas.find_withtag(shape_id):
            if node_id in self.brain_pulse_jobs:
                del self.brain_pulse_jobs[node_id]
            return
        current_width = self.canvas.itemcget(shape_id, "width")
        try:
            current_width_float = float(current_width)
        except ValueError:
            current_width_float = pulse_config['min_width']
        new_width = current_width_float + (pulse_config['step'] * pulse_config['direction'])
        if new_width >= pulse_config['max_width']:
            new_width = pulse_config['max_width']
            pulse_config['direction'] = -1
        elif new_width <= pulse_config['min_width']:
            new_width = pulse_config['min_width']
            pulse_config['direction'] = 1
        self.canvas.itemconfig(shape_id, width=new_width)
        job_id = self.canvas.after(50, self._animate_brain_pulse, node_id)
        self.brain_pulse_jobs[node_id]['job_id'] = job_id
    def stop_brain_pulse(self, node_id):
        if node_id in self.brain_pulse_jobs:
            job_id = self.brain_pulse_jobs[node_id].get('job_id')
            if job_id:
                try:
                    self.canvas.after_cancel(job_id)
                except TclError:
                    pass
            del self.brain_pulse_jobs[node_id]
    def _on_canvas_resize(self, event=None):
        self.canvas.delete("grid_dot")
        self.draw_grid()
        self.draw_watermark()
    def draw_grid(self):
        if not self.canvas.winfo_exists():
            return
        self.canvas.update_idletasks()
        canvas_width = self.canvas.winfo_width()
        canvas_height = self.canvas.winfo_height()
        if canvas_width <= 1 or canvas_height <= 1:
            self.canvas_manager.coordinator_tab.after(100, self.draw_grid)
            return
        grid_spacing = 30
        dot_size = 1
        dot_color = "#4a4a4a"
        for x in range(0, canvas_width, grid_spacing):
            for y in range(0, canvas_height, grid_spacing):
                x1, y1 = x - dot_size, y - dot_size
                x2, y2 = x + dot_size, y + dot_size
                self.canvas.create_oval(x1, y1, x2, y2, fill=dot_color, outline="", tags="grid_dot")
        self.canvas.tag_lower("grid_dot")
    def _define_highlight_styles(self):
        style = ttk.Style.get_instance()
        colors = self.canvas_manager.colors
        glass_bg = '#222831'
        glass_border = '#393E46'
    def draw_watermark(self):
        self.hide_watermark()
        if not self.canvas.winfo_exists():
            return
        if not self.canvas_manager.canvas_nodes:
            self.canvas.update_idletasks()
            canvas_width = self.canvas.winfo_width()
            canvas_height = self.canvas.winfo_height()
            if canvas_width <= 1 or canvas_height <= 1:
                self.canvas_manager.coordinator_tab.after(100, self.draw_watermark)
                return
            x = canvas_width / 2
            y = canvas_height / 2
            self._watermark_id = self.canvas.create_text(
                x, y,
                text="WWW.TEETAH.ART",
                font=("Helvetica", int(min(canvas_width, canvas_height) * 0.15), "bold"),
                fill="#3a3a3a",
                state="disabled",
                tags="watermark_tag",
                anchor="center"
            )
            self.canvas.tag_lower(self._watermark_id)
    def hide_watermark(self):
        if self._watermark_id:
            if self.canvas.winfo_exists() and self.canvas.find_withtag(self._watermark_id):
                self.canvas.delete(self._watermark_id)
            self._watermark_id = None
    def start_processing_animation(self, node_id):
        self.stop_processing_animation(node_id)
        if node_id not in self.canvas_manager.canvas_nodes: return
        node_widget = self.canvas_manager.canvas_nodes[node_id]['widget']
        if not node_widget.winfo_exists(): return
        light_length = 30
        light_thickness = 4
        color = self.canvas_manager.colors.get('warning', '#ffc107')
        x = node_widget.winfo_x()
        y = node_widget.winfo_y()
        light_id = self.canvas.create_rectangle(
            x, y - light_thickness / 2, x + light_length, y + light_thickness / 2,
            fill=color,
            outline=""
        )
        self.canvas.tag_raise(light_id)
        self.processing_animations[node_id] = {
            "light_id": light_id,
            "after_id": None,
            "position": 0,
            "speed": 5,
            "length": light_length,
            "thickness": light_thickness
        }
        self._animate_processing_border(node_id)
    def _animate_processing_border(self, node_id):
        if node_id not in self.processing_animations:
            return
        animation_data = self.processing_animations[node_id]
        light_id = animation_data['light_id']
        node_widget = self.canvas_manager.canvas_nodes.get(node_id, {}).get('widget')
        if not self.canvas.find_withtag(light_id) or not node_widget or not node_widget.winfo_exists():
            self.stop_processing_animation(node_id)
            return
        x, y = node_widget.winfo_x(), node_widget.winfo_y()
        w, h = node_widget.winfo_width(), node_widget.winfo_height()
        perimeter = (w * 2) + (h * 2)
        if perimeter == 0:
            after_id = self.canvas.after(50, self._animate_processing_border, node_id)
            animation_data['after_id'] = after_id
            return
        pos = (animation_data['position'] + animation_data['speed']) % perimeter
        animation_data['position'] = pos
        length = animation_data['length']
        thickness = animation_data['thickness']
        half_thick = thickness / 2
        if 0 <= pos < w:
            x1, y1 = x + pos, y - half_thick
            x2, y2 = x + pos - length, y + half_thick
            self.canvas.coords(light_id, x1, y1, x2, y2)
        elif w <= pos < w + h:
            x1, y1 = x + w - half_thick, y + (pos - w)
            x2, y2 = x + w + half_thick, y + (pos - w) - length
            self.canvas.coords(light_id, x1, y1, x2, y2)
        elif w + h <= pos < w + h + w:
            x1, y1 = x + w - (pos - (w + h)), y + h - half_thick
            x2, y2 = x + w - (pos - (w + h)) + length, y + h + half_thick
            self.canvas.coords(light_id, x1, y1, x2, y2)
        else:
            x1, y1 = x - half_thick, y + h - (pos - (w + h + w))
            x2, y2 = x + half_thick, y + h - (pos - (w + h + w)) + length
            self.canvas.coords(light_id, x1, y1, x2, y2)
        if node_id in self.processing_animations:
            after_id = self.canvas.after(20, self._animate_processing_border, node_id)
            self.processing_animations[node_id]['after_id'] = after_id
    def stop_processing_animation(self, node_id):
        if node_id in self.processing_animations:
            animation_data = self.processing_animations.pop(node_id)
            after_id = animation_data.get('after_id')
            if after_id:
                try:
                    self.canvas.after_cancel(after_id)
                except TclError:
                    pass
            if self.canvas.winfo_exists() and self.canvas.find_withtag(animation_data['light_id']):
                self.canvas.delete(animation_data['light_id'])
    def highlight_timeline_step(self, connection_id_to_highlight):
        self.clear_timeline_highlight()
        if connection_id_to_highlight in self.canvas_manager.canvas_connections:
            line_id = self.canvas_manager.canvas_connections[connection_id_to_highlight]['line_id']
            if self.canvas.find_withtag(line_id):
                colors = self.canvas_manager.colors
                highlight_color = colors.get('info', '#17a2b8')
                self.canvas.itemconfig(line_id, fill=highlight_color, width=4, dash=())
                self._last_timeline_highlight_id = line_id
    def clear_timeline_highlight(self):
        if self._last_timeline_highlight_id:
            if self.canvas.find_withtag(self._last_timeline_highlight_id):
                colors = self.canvas_manager.colors
                original_color = colors.get('success', '#76ff7b')
                self.canvas.itemconfig(self._last_timeline_highlight_id, fill=original_color, width=2, dash=(4, 4))
            self._last_timeline_highlight_id = None
    def show_suggestion_indicator(self, node_id, suggestion_text):
        self.hide_suggestion_indicator(node_id)
        canvas_nodes = self.canvas_manager.canvas_nodes
        if node_id not in canvas_nodes: return
        node_widget = canvas_nodes[node_id].get("widget")
        if not node_widget or not node_widget.winfo_exists(): return
        indicator_label = ttk.Label(node_widget, text="💡", font=("Segoe UI Emoji", 10), bootstyle="warning")
        indicator_label.place(relx=1.0, rely=0.0, x=-5, y=-5, anchor="ne")
        ToolTip(indicator_label).update_text(suggestion_text)
        self.suggestion_indicators[node_id] = indicator_label
    def hide_suggestion_indicator(self, node_id):
        if node_id in self.suggestion_indicators:
            indicator = self.suggestion_indicators.pop(node_id)
            if indicator and indicator.winfo_exists(): indicator.destroy()
    def clear_all_suggestion_indicators(self):
        for node_id in list(self.suggestion_indicators.keys()): self.hide_suggestion_indicator(node_id)
    def highlight_element(self, element_type, element_id):
        self.stop_sleeping_animation(element_id)
        if element_type == 'node':
            self.start_processing_animation(element_id)
        elif element_type == 'tool_node':
            if element_id not in self.canvas_manager.canvas_nodes: return
            node_data = self.canvas_manager.canvas_nodes[element_id]
            widget = node_data.get('widget')
            if not widget or not widget.winfo_exists(): return
            original_style = self._get_original_style(element_id)
            self.canvas_manager.node_manager._apply_style_to_node_widgets(element_id, "Executing.Module.TFrame")
            self.canvas.after(1500, lambda: self.canvas_manager.node_manager._apply_style_to_node_widgets(element_id, original_style))
        elif element_type == 'sleeping_node':
            if element_id not in self.canvas_manager.canvas_nodes: return
            widget = self.canvas_manager.canvas_nodes[element_id]['widget']
            if widget.cget('style') == 'Selected.Module.TFrame': return
            widget.config(style='Sleeping.Module.TFrame')
            self.start_sleeping_animation(element_id)
        elif element_type == 'connection':
            if element_id not in self.canvas_manager.canvas_connections: return
            line_id = self.canvas_manager.canvas_connections[element_id]['line_id']
            colors = self.canvas_manager.colors
            original_color = colors.get('success', '#76ff7b')
            highlight_color = colors.get('warning', '#ffc107')
            self.canvas.itemconfig(line_id, fill=highlight_color, width=3, dash=())
            self.canvas_manager.coordinator_tab.after(1500, lambda: self.canvas.itemconfig(line_id, fill=original_color, width=2) if self.canvas.find_withtag(line_id) else None)
    def update_node_status(self, node_id, message, level):
        if node_id not in self.canvas_manager.canvas_nodes: return
        if level.upper() in ["SUCCESS", "ERROR", "WARN"]:
            self.stop_processing_animation(node_id)
        node_frame = self.canvas_manager.canvas_nodes[node_id]['widget']
        if node_id in self._sleeping_animation_jobs and "jeda" not in message.lower() and "sleep" not in message.lower():
            self.stop_sleeping_animation(node_id)
        try:
            if not node_frame.winfo_exists():
                return
            content_frame = node_frame.winfo_children()[0]
            status_label = next((w for w in content_frame.winfo_children() if isinstance(w, ttk.Label) and 'status_' in w.winfo_name()), None)
            if status_label:
                if not hasattr(node_frame, '_original_status_message') or (status_label.cget("text").replace(" |", "").replace(" /", "").replace(" -", "").replace(" \\", "").strip() != message.strip()):
                    node_frame._original_status_message = message
                colors = self.canvas_manager.colors
                color_map = {"SUCCESS": colors.get('success'), "ERROR": colors.get('danger'), "WARN": colors.get('warning'), "INFO": colors.get('info'), "DEBUG": colors.get('secondary')}
                current_style = node_frame.cget('style')
                if current_style == 'Selected.Glass.Module.TFrame': bg_color, fg_color = colors.get('dark'), colors.get('success')
                elif current_style == 'Hover.Glass.Module.TFrame': bg_color, fg_color = colors.get('dark'), colors.get('info')
                elif current_style == 'Executing.Module.TFrame': bg_color, fg_color = colors.get('warning'), colors.get('dark')
                elif current_style == 'Sleeping.Module.TFrame': bg_color, fg_color = colors.get('info'), colors.get('light')
                else: bg_color, fg_color = colors.get('dark'), colors.get('fg')
                status_label.config(text=message, foreground=color_map.get(level, fg_color), background=bg_color)
        except (TclError, IndexError): pass
    def start_sleeping_animation(self, node_id):
        self.stop_sleeping_animation(node_id)
        node_data = self.canvas_manager.canvas_nodes.get(node_id)
        if not node_data or not node_data['widget'].winfo_exists(): return
        status_label = next((w for w in node_data['widget'].winfo_children()[0].winfo_children() if isinstance(w, ttk.Label) and 'status_' in w.winfo_name()), None)
        if not status_label: return
        if not hasattr(node_data['widget'], '_original_status_message'):
            node_data['widget']._original_status_message = status_label.cget("text")
        self._update_sleeping_animation_frame(node_id, 0)
    def _update_sleeping_animation_frame(self, node_id, frame_index):
        node_data = self.canvas_manager.canvas_nodes.get(node_id)
        if not node_data or not node_data['widget'].winfo_exists():
            self.stop_sleeping_animation(node_id)
            return
        status_label = next((w for w in node_data['widget'].winfo_children()[0].winfo_children() if isinstance(w, ttk.Label) and 'status_' in w.winfo_name()), None)
        if not status_label: return
        original_msg = getattr(node_data['widget'], '_original_status_message', "")
        animated_char = self._animation_frames[frame_index % len(self._animation_frames)]
        status_label.config(text=f"{original_msg} {animated_char}")
        next_frame_index = (frame_index + 1) % len(self._animation_frames)
        job_id = self.canvas_manager.coordinator_tab.after(150, self._update_sleeping_animation_frame, node_id, next_frame_index)
        self._sleeping_animation_jobs[node_id] = job_id
    def stop_sleeping_animation(self, node_id):
        if node_id in self._sleeping_animation_jobs:
            self.canvas_manager.coordinator_tab.after_cancel(self._sleeping_animation_jobs[node_id])
            del self._sleeping_animation_jobs[node_id]
            node_data = self.canvas_manager.canvas_nodes.get(node_id)
            if node_data and node_data['widget'].winfo_exists():
                status_label = next((w for w in node_data['widget'].winfo_children()[0].winfo_children() if isinstance(w, ttk.Label) and 'status_' in w.winfo_name()), None)
                if status_label:
                    status_label.config(text=getattr(node_data['widget'], '_original_status_message', status_label.cget("text").rstrip(' |/-\\')))
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\canvas_components\interactions\canvas_navigation_handler.py
# JUMLAH BARIS : 60
#######################################################################

```py
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class CanvasNavigationHandler:
    def __init__(self, canvas_manager):
        self.api_client = ApiClient()
        self.canvas_manager = canvas_manager
        self.canvas = self.canvas_manager.canvas
        self.zoom_level = 1.0
        self.zoom_step = 0.1
    def on_pan_start(self, event):
        """Marks the starting point for panning the canvas."""
        self.canvas.scan_mark(event.x, event.y)
        self.canvas.config(cursor="fleur")
    def on_pan_move(self, event):
        """Moves the canvas based on mouse movement."""
        self.canvas.scan_dragto(event.x, event.y, gain=1)
    def on_pan_end(self, event):
        """Resets the cursor when panning ends."""
        self.canvas.config(cursor="")
        self.canvas.delete("grid_dot")
        self.canvas_manager.visual_manager.draw_grid()
    def apply_zoom(self):
        """Applies the current zoom level to all canvas elements."""
        for node_id, node_data in self.canvas_manager.canvas_nodes.items():
            original_x, original_y = node_data['x'], node_data['y']
            scaled_x = original_x * self.zoom_level
            scaled_y = original_y * self.zoom_level
            if node_data['widget'].winfo_exists():
                node_data['widget'].place(x=scaled_x, y=scaled_y)
        for node_id in self.canvas_manager.canvas_nodes.keys():
            self.canvas_manager.connection_manager.update_connections_for_node(node_id)
    def zoom_in(self, event=None):
        """Increases the zoom level."""
        self.zoom_level += self.zoom_step
        self.apply_zoom()
        self.canvas_manager.parent_widget.update_zoom_label()
    def zoom_out(self, event=None):
        """Decreases the zoom level."""
        self.zoom_level = max(0.2, self.zoom_level - self.zoom_step)
        self.apply_zoom()
        self.canvas_manager.parent_widget.update_zoom_label()
    def reset_zoom(self, event=None):
        """Resets the zoom level to 100%."""
        self.zoom_level = 1.0
        self.apply_zoom()
        self.canvas_manager.parent_widget.update_zoom_label()
    def handle_zoom_event(self, event):
        """Handles zoom events from the mouse wheel."""
        if event.delta > 0:
            self.zoom_in()
        else:
            self.zoom_out()
        return "break"
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\canvas_components\interactions\connection_interaction_handler.py
# JUMLAH BARIS : 162
#######################################################################

```py
from tkinter import Menu, Toplevel, scrolledtext, messagebox
import json
import ttkbootstrap as ttk
from api_client.client import ApiClient # PENAMBAHAN: Ini adalah alamat impor yang benar.
class _ConnectionDataPopup(Toplevel):
    """(ADDED) A dedicated popup to display the payload from a connection."""
    def __init__(self, parent, kernel, title, data_to_display):
        super().__init__(parent)
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        self.title(title)
        self.geometry("600x450")
        self.transient(parent)
        self.grab_set()
        try:
            pretty_data = json.dumps(data_to_display, indent=4, ensure_ascii=False, default=str)
        except Exception:
            pretty_data = str(data_to_display)
        txt_area = scrolledtext.ScrolledText(self, wrap="word", width=70, height=20, font=("Consolas", 10))
        txt_area.pack(expand=True, fill="both", padx=10, pady=10)
        txt_area.insert("1.0", pretty_data)
        txt_area.config(state="disabled")
        self.wait_window(self)
class ConnectionInteractionHandler:
    def __init__(self, canvas_manager):
        self.canvas_manager = canvas_manager
        self.kernel = self.canvas_manager.kernel
        self.canvas = self.canvas_manager.canvas
        self.loc = self.kernel.get_service("localization_manager")
        self._line_data = {"start_node_id": None, "line_id": None, "source_port_name": None, "connection_type": "data"}
        self._highlighted_nodes = []
    def start_line_drawing(self, node_id, port_name=None, port_type='output'):
        if node_id not in self.canvas_manager.canvas_nodes: return
        self.canvas_manager.interaction_manager._reset_all_actions()
        self._line_data["start_node_id"] = node_id
        self._line_data["source_port_name"] = port_name
        self._line_data["connection_type"] = port_type
        port_list_key = f"{port_type}_ports"
        port_list = self.canvas_manager.canvas_nodes[node_id].get(port_list_key, [])
        port_widget = next((p['widget'] for p in port_list if p['name'] == port_name), None)
        if not port_widget:
            start_node_widget = self.canvas_manager.canvas_nodes[node_id]["widget"]
            start_x = start_node_widget.winfo_rootx() - self.canvas.winfo_rootx() + start_node_widget.winfo_width()/2
            start_y = start_node_widget.winfo_rooty() - self.canvas.winfo_rooty() + start_node_widget.winfo_height()/2
        else:
            start_x = port_widget.winfo_rootx() - self.canvas.winfo_rootx() + port_widget.winfo_width()/2
            start_y = port_widget.winfo_rooty() - self.canvas.winfo_rooty() + port_widget.winfo_height()/2
        self._line_data["line_id"] = self.canvas.create_line(start_x, start_y, start_x, start_y, fill=self.canvas_manager.colors['success'], width=2, dash=(4, 4))
        self._highlight_valid_target_nodes(node_id)
    def finish_line_drawing(self, end_node_id, target_port_name=None, target_port_type='input'):
        start_node_id = self._line_data["start_node_id"]
        source_port_name = self._line_data.get("source_port_name")
        connection_type = self._line_data.get("connection_type", "data")
        module_manager = self.kernel.get_service("module_manager_service")
        start_node_manifest = module_manager.get_manifest(self.canvas_manager.canvas_nodes[start_node_id]['module_id'])
        is_source_brain = start_node_manifest.get('subtype') == 'BRAIN_PROVIDER'
        if is_source_brain and target_port_name != 'brain_port':
            self.kernel.write_to_log("Invalid Connection: Brain can only connect to a Brain Port.", "WARN") # English Log
            messagebox.showwarning("Invalid Connection", "A 'Brain' node can only be connected to the 'Brain' port of an Agent Host.", parent=self.canvas) # English Hardcode
            self._cancel_line_drawing()
            return
        if target_port_type == 'tool':
            connection_type = 'tool'
        if start_node_id and start_node_id != end_node_id and start_node_id in self.canvas_manager.canvas_nodes and end_node_id in self.canvas_manager.canvas_nodes:
            self.canvas_manager.connection_manager.create_connection(
                start_node_id,
                end_node_id,
                source_port_name=source_port_name,
                target_port_name=target_port_name,
                connection_type=connection_type
            )
        self._cancel_line_drawing()
    def on_line_motion(self, event):
        if not self._line_data.get("line_id"): return
        start_node_id = self._line_data["start_node_id"]
        if start_node_id not in self.canvas_manager.canvas_nodes:
            self._cancel_line_drawing()
            return
        port_name = self._line_data.get("source_port_name")
        port_type = self._line_data.get("connection_type", "output")
        port_list_key = f"{port_type}_ports"
        port_list = self.canvas_manager.canvas_nodes[start_node_id].get(port_list_key, [])
        port_widget = next((p['widget'] for p in port_list if p['name'] == port_name), None)
        if not port_widget or not port_widget.winfo_exists():
             start_node_widget = self.canvas_manager.canvas_nodes[start_node_id]["widget"]
             start_x = start_node_widget.winfo_rootx() - self.canvas.winfo_rootx() + start_node_widget.winfo_width()/2
             start_y = start_node_widget.winfo_rooty() - self.canvas.winfo_rooty() + start_node_widget.winfo_height()/2
        else:
            start_x = port_widget.winfo_rootx() - self.canvas.winfo_rootx() + port_widget.winfo_width()/2
            start_y = port_widget.winfo_rooty() - self.canvas.winfo_rooty() + port_widget.winfo_height()/2
        end_x = self.canvas.canvasx(event.x)
        end_y = self.canvas.canvasy(event.y)
        module_manager = self.kernel.get_service("module_manager_service")
        start_node_manifest = module_manager.get_manifest(self.canvas_manager.canvas_nodes[start_node_id]['module_id'])
        is_source_brain = start_node_manifest.get('subtype') == 'BRAIN_PROVIDER'
        hovered_item = self.canvas.find_closest(end_x, end_y)[0]
        hovered_tags = self.canvas.gettags(hovered_item)
        if is_source_brain and hovered_tags:
            hovered_node_id = next((tag for tag in hovered_tags if tag in self.canvas_manager.canvas_nodes), None)
            if hovered_node_id and self.canvas_manager.canvas_nodes[hovered_node_id].get('module_id') == 'agent_host_module':
                snap_x, snap_y = self.canvas_manager.connection_manager._get_port_widget_center(hovered_node_id, 'brain_port', 'tool')
                if snap_x is not None:
                    end_x, end_y = snap_x, snap_y
        self.canvas.coords(self._line_data["line_id"], start_x, start_y, end_x, end_y)
    def _cancel_line_drawing(self, event=None):
        if self._line_data.get("line_id"):
            if self.canvas.find_withtag(self._line_data["line_id"]):
                self.canvas.delete(self._line_data["line_id"])
        self._line_data = {"start_node_id": None, "line_id": None, "source_port_name": None, "connection_type": "data"}
        self._clear_node_highlights()
        return "break"
    def _highlight_valid_target_nodes(self, start_node_id):
        self._clear_node_highlights()
        for node_id, node_data in self.canvas_manager.canvas_nodes.items():
            if node_id != start_node_id:
                widget = node_data['widget']
                if widget.winfo_exists():
                    widget.config(style="Droppable.Module.TFrame")
                    self._highlighted_nodes.append(widget)
    def _clear_node_highlights(self):
        for widget in self._highlighted_nodes:
            if widget.winfo_exists():
                is_selected = self.canvas_manager.selected_node_id == widget.node_id
                widget.config(style="Selected.Module.TFrame" if is_selected else "Module.TFrame")
        self._highlighted_nodes = []
    def show_line_context_menu(self, event):
        current_items = self.canvas.find_withtag("current")
        if not current_items: return
        conn_id = next((cid for cid, cdata in self.canvas_manager.canvas_connections.items() if cdata['line_id'] == current_items[0]), None)
        if conn_id:
            context_menu = Menu(self.canvas, tearoff=0)
            context_menu.add_command(label="View Last Data...", command=lambda: self._show_connection_data_popup(conn_id)) # English Hardcode
            context_menu.add_separator()
            context_menu.add_command(label=self.loc.get('context_menu_delete_connection'), command=lambda: self.canvas_manager.connection_manager.delete_connection(conn_id))
            try:
                context_menu.tk_popup(event.x_root, event.y_root)
            finally:
                context_menu.grab_release()
    def _show_connection_data_popup(self, conn_id):
        history_data = self.canvas_manager.coordinator_tab.canvas_area_instance.execution_history
        if not history_data or not history_data.get('steps'):
            messagebox.showinfo("Info", "No execution history is available for this run.", parent=self.canvas) # English Hardcode
            return
        data_for_this_conn = "No data recorded for this specific connection in the last run." # English Hardcode
        for step in reversed(history_data['steps']):
            if step.get('connection_id') == conn_id:
                data_for_this_conn = step.get('payload', {})
                break
        _ConnectionDataPopup(
            parent=self.canvas,
            kernel=self.kernel,
            title=f"Data Preview for Connection", # English Hardcode
            data_to_display=data_for_this_conn
        )
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\canvas_components\interactions\node_interaction_handler.py
# JUMLAH BARIS : 132
#######################################################################

```py
from tkinter import Menu
from api_client.client import ApiClient # PENAMBAHAN: Ini adalah alamat impor yang benar.
class NodeInteractionHandler:
    """
    (REFACTORED) Handles all node-specific interactions like pressing, dragging, releasing, and context menus.
    This version is robust for both widget-based (rectangular) and canvas-item-based (circular) nodes.
    """
    def __init__(self, canvas_manager):
        self.canvas_manager = canvas_manager
        self.kernel = self.canvas_manager.kernel
        self.canvas = self.canvas_manager.canvas
        self.loc = self.kernel.get_service("localization_manager")
        self.api_client = ApiClient(kernel=self.kernel)
        self._move_data = {"id": None, "x": 0, "y": 0}
    def on_node_press(self, event):
        item_ids = self.canvas.find_withtag("current")
        node_id = None
        if item_ids:
            tags = self.canvas.gettags(item_ids[0])
            node_id = next((tag for tag in tags if tag in self.canvas_manager.canvas_nodes), None)
        if not node_id:
            widget = event.widget
            while widget and not hasattr(widget, 'node_id'):
                widget = widget.master
            if not widget: return
            node_id = widget.node_id
        connection_handler = self.canvas_manager.interaction_manager.connection_handler
        is_drawing_line = connection_handler._line_data.get("start_node_id") is not None
        if is_drawing_line:
            self.kernel.write_to_log("Logic Builder: Left-click detected on target node, finishing connection.", "DEBUG") # English Log
            target_port_name = getattr(event.widget, 'port_name', None)
            target_port_type = getattr(event.widget, 'port_type', 'input')
            connection_handler.finish_line_drawing(node_id, target_port_name, target_port_type)
            self._move_data = {"id": None, "x": 0, "y": 0}
            return
        self.canvas_manager.node_manager.select_node(node_id)
        if hasattr(event.widget, 'port_name'): return
        self._move_data["id"] = node_id
        self._move_data["x"] = self.canvas.canvasx(event.x)
        self._move_data["y"] = self.canvas.canvasy(event.y)
        return "break"
    def on_node_motion(self, event):
        if self._move_data.get("id"):
            node_id = self._move_data["id"]
            if node_id not in self.canvas_manager.canvas_nodes: return
            new_x = self.canvas.canvasx(event.x)
            new_y = self.canvas.canvasy(event.y)
            delta_x = new_x - self._move_data["x"]
            delta_y = new_y - self._move_data["y"]
            self.canvas_manager.node_manager.move_node_by_delta(node_id, delta_x, delta_y)
            self._move_data["x"] = new_x
            self._move_data["y"] = new_y
    def on_node_release(self, event):
        if self._move_data.get("id"):
            node_id = self._move_data["id"]
            if node_id in self.canvas_manager.canvas_nodes:
                zoom_level = self.canvas_manager.interaction_manager.navigation_handler.zoom_level
                bbox = self.canvas.bbox(node_id)
                if bbox:
                    scaled_x = bbox[0]
                    scaled_y = bbox[1]
                    self.canvas_manager.canvas_nodes[node_id]["x"] = scaled_x / zoom_level
                    self.canvas_manager.canvas_nodes[node_id]["y"] = scaled_y / zoom_level
            self._move_data = {"id": None, "x": 0, "y": 0}
    def on_delete_key_press(self, event=None):
        if self.canvas_manager.selected_node_id:
            self.canvas_manager.node_manager.delete_node(self.canvas_manager.selected_node_id)
            return "break"
    def show_node_context_menu(self, event):
        closest_items = self.canvas.find_closest(self.canvas.canvasx(event.x), self.canvas.canvasy(event.y))
        if not closest_items: return
        item_id = closest_items[0]
        tags = self.canvas.gettags(item_id)
        node_id = next((tag for tag in tags if tag in self.canvas_manager.canvas_nodes), None)
        if not node_id:
            widget = event.widget
            while widget and not hasattr(widget, 'node_id'):
                widget = widget.master
            if not widget: return
            node_id = widget.node_id
        self.canvas_manager.node_manager.select_node(node_id)
        context_menu = Menu(self.canvas, tearoff=0)
        context_menu.add_command(label=self.loc.get('context_menu_properties', fallback="Properties"), command=lambda: self.canvas_manager.properties_manager.open_properties_popup(node_id))
        context_menu.add_separator()
        line_data = self.canvas_manager.interaction_manager.connection_handler._line_data
        node_data = self.canvas_manager.canvas_nodes[node_id]
        start_conn_state = "normal" if not line_data["start_node_id"] else "disabled"
        finish_conn_state = "disabled" if not line_data["start_node_id"] else "normal"
        module_manager = self.kernel.get_service("module_manager_service")
        manifest = (module_manager.get_manifest(node_data.get("module_id")) if module_manager else {}) or {}
        has_any_output = False
        if node_data.get("output_ports"):
            has_any_output = True
            for port_data in node_data["output_ports"]:
                port_name = port_data.get("name")
                port_info = next((p for p in manifest.get('output_ports', []) if p['name'] == port_name), {'display_name': port_name.replace("_", " ").title()})
        if node_data.get("tool_ports"):
            has_any_output = True
            for port_data in node_data["tool_ports"]:
                port_name = port_data.get("name")
                port_info = next((p for p in manifest.get('tool_ports', []) if p['name'] == port_name), {'display_name': port_name.replace("_", " ").title()})
        if has_any_output:
            start_connection_menu = Menu(context_menu, tearoff=0) # ADDED: Create the menu only if needed
            if node_data.get("output_ports"):
                for port_data in node_data["output_ports"]:
                    port_name = port_data.get("name")
                    port_info = next((p for p in manifest.get('output_ports', []) if p['name'] == port_name), {'display_name': port_name.replace("_", " ").title()})
                    start_connection_menu.add_command(label=port_info.get("display_name"), command=lambda n=node_id, p=port_name: self.canvas_manager.interaction_manager.connection_handler.start_line_drawing(n, port_name=p, port_type='output'))
            if node_data.get("tool_ports"):
                if node_data.get("output_ports"):
                    start_connection_menu.add_separator()
                for port_data in node_data["tool_ports"]:
                    port_name = port_data.get("name")
                    port_info = next((p for p in manifest.get('tool_ports', []) if p['name'] == port_name), {'display_name': port_name.replace("_", " ").title()})
                    start_connection_menu.add_command(label=f"Connect to {port_info.get('display_name')}", command=lambda n=node_id, p=port_name: self.canvas_manager.interaction_manager.connection_handler.start_line_drawing(n, port_name=p, port_type='tool'))
            context_menu.add_cascade(label=self.loc.get('context_menu_start_connection', fallback="Start Connection"), menu=start_connection_menu, state=start_conn_state)
        context_menu.add_command(label=self.loc.get('context_menu_finish_connection', fallback="Finish Connection Here"), command=lambda: self.canvas_manager.interaction_manager.connection_handler.finish_line_drawing(node_id), state=finish_conn_state)
        context_menu.add_separator()
        context_menu.add_command(label=self.loc.get('context_menu_duplicate_node', fallback="Duplicate Node"), command=lambda: self.canvas_manager.node_manager.duplicate_node(node_id))
        context_menu.add_command(label=self.loc.get('context_menu_delete_node'), command=lambda: self.canvas_manager.node_manager.delete_node(node_id))
        try:
            context_menu.tk_popup(event.x_root, event.y_root)
        finally:
            context_menu.grab_release()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\components\InfoLabel.py
# JUMLAH BARIS : 17
#######################################################################

```py
import ttkbootstrap as ttk
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class InfoLabel(ttk.Frame):
    def __init__(self, parent, text: str, **kwargs):
        self.api_client = ApiClient()
        super().__init__(parent, padding=10, **kwargs)
        label = ttk.Label(self, text=text, wraplength=350, justify='left', bootstyle="secondary")
        label.pack(fill='x')
        self.pack(fill='x', pady=5)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\components\LabelledCombobox.py
# JUMLAH BARIS : 22
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class LabelledCombobox(ttk.Frame):
    """A reusable widget that combines a Label and a Combobox."""
    def __init__(self, parent, label_text: str, variable: StringVar, values: list, **kwargs):
        self.api_client = ApiClient()
        super().__init__(parent, **kwargs)
        self.columnconfigure(1, weight=1)
        label = ttk.Label(self, text=label_text)
        label.grid(row=0, column=0, sticky="w", padx=(0, 10))
        combobox = ttk.Combobox(self, textvariable=variable, values=values, state="readonly")
        combobox.grid(row=0, column=1, sticky="ew")
        self.pack(fill='x', pady=5)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\components\PropertyField.py
# JUMLAH BARIS : 18
#######################################################################

```py
import ttkbootstrap as ttk
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class PropertyField(ttk.Frame):
    def __init__(self, parent, label_text: str, variable, **kwargs):
        self.api_client = ApiClient()
        super().__init__(parent, **kwargs)
        self.columnconfigure(1, weight=1)
        ttk.Label(self, text=label_text).grid(row=0, column=0, sticky="w", padx=(0, 10))
        ttk.Entry(self, textvariable=variable).grid(row=0, column=1, sticky="ew")
        self.pack(fill='x', pady=5)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\components\Separator.py
# JUMLAH BARIS : 15
#######################################################################

```py
import ttkbootstrap as ttk
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class Separator(ttk.Separator):
    def __init__(self, parent, **kwargs):
        self.api_client = ApiClient()
        super().__init__(parent, orient='horizontal', **kwargs)
        self.pack(fill='x', pady=15, padx=5)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\custom_widgets\draggable_notebook.py
# JUMLAH BARIS : 77
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import TclError, Menu, messagebox
from tkinter import ttk as tk_ttk
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class DraggableNotebook(tk_ttk.Notebook):
    def __init__(self, master=None, **kw):
        self.api_client = ApiClient()
        self.loc = kw.pop('loc', None)
        super().__init__(master, **kw)
        self.bind("<ButtonPress-1>", self.on_tab_press, True)
        self.bind("<B1-Motion>", self.on_mouse_drag)
        self.bind("<ButtonRelease-1>", self.on_mouse_release)
        self.drag_data = {"x": 0, "y": 0, "item": None, "tab_id": None}
        self.bind("<ButtonPress-3>", self.show_context_menu)
        self._close_tab_command = None
    def set_close_tab_command(self, command):
        self._close_tab_command = command
    def on_tab_press(self, event):
        try:
            index = self.index(f"@{event.x},{event.y}")
            if index == "":
                self.drag_data["item"] = None
                return
            tab_id = self.tabs()[index]
            self.drag_data["x"] = event.x
            self.drag_data["y"] = event.y
            self.drag_data["item"] = index
            self.drag_data["tab_id"] = tab_id
        except TclError:
            self.drag_data["item"] = None
    def on_mouse_drag(self, event):
        if self.drag_data["item"] is not None:
            tab_id_to_move = self.drag_data["tab_id"]
            try:
                target_index = self.index(f"@{event.x},{event.y}")
                if target_index != "" and self.drag_data["item"] != target_index:
                    self.insert(target_index, tab_id_to_move)
                    self.drag_data["item"] = target_index
            except TclError:
                pass
    def on_mouse_release(self, event):
        self.drag_data = {"x": 0, "y": 0, "item": None, "tab_id": None}
    def show_context_menu(self, event):
        try:
            index = self.index(f"@{event.x},{event.y}")
            if index == "": return
            tab_id = self.tabs()[index]
            context_menu = Menu(self, tearoff=0)
            context_menu.add_command(label=self.loc.get('context_menu_rename_tab', fallback="Rename Tab"), command=lambda: self.rename_tab(index))
            if self._close_tab_command:
                if len(self.tabs()) > 1:
                    context_menu.add_command(label=self.loc.get('menu_close_tab', fallback="Close Tab"), command=lambda: self._close_tab_command(tab_id))
                else:
                    context_menu.add_command(label=self.loc.get('menu_close_tab', fallback="Close Tab"), state='disabled')
            try:
                context_menu.tk_popup(event.x_root, event.y_root)
            finally:
                context_menu.grab_release()
        except TclError:
            pass
    def rename_tab(self, index):
        current_name = self.tab(index, "text").strip()
        new_name = ttk.dialogs.dialogs.Querybox.get_string(
            title=self.loc.get('rename_tab_popup_title', fallback="Rename Tab"),
            prompt=self.loc.get('rename_tab_popup_label', fallback="Enter new name:"),
            initialvalue=current_name
        )
        if new_name and new_name.strip() != "":
            self.tab(index, text=f" {new_name.strip()} ")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\custom_widgets\DualListbox.py
# JUMLAH BARIS : 68
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import Listbox, ANCHOR, END
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class DualListbox(ttk.Frame):
    """
    A reusable widget featuring two listboxes and buttons to move items between them.
    Encapsulates the logic for selecting items from an available pool.
    """
    def __init__(self, parent, kernel, available_items: list = None, selected_items: list = None, **kwargs):
        self.api_client = ApiClient()
        super().__init__(parent, **kwargs)
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        available_items = available_items or []
        selected_items = selected_items or []
        self.columnconfigure(0, weight=1)
        self.columnconfigure(1, weight=0) # Button column should not expand
        self.columnconfigure(2, weight=1)
        self.rowconfigure(1, weight=1)
        ttk.Label(self, text=self.loc.get('duallist_available', fallback="Tersedia")).grid(row=0, column=0, sticky='w', padx=5)
        ttk.Label(self, text=self.loc.get('duallist_selected', fallback="Terpilih")).grid(row=0, column=2, sticky='w', padx=5)
        self.available_listbox = Listbox(self, selectmode='extended', exportselection=False)
        self.available_listbox.grid(row=1, column=0, sticky='nsew', padx=(0, 5))
        self.selected_listbox = Listbox(self, selectmode='extended', exportselection=False)
        self.selected_listbox.grid(row=1, column=2, sticky='nsew', padx=(5, 0))
        for item in sorted(list(set(available_items) - set(selected_items))):
            self.available_listbox.insert(END, item)
        for item in selected_items:
            self.selected_listbox.insert(END, item)
        button_frame = ttk.Frame(self)
        button_frame.grid(row=1, column=1, padx=10, sticky='ns')
        ttk.Button(button_frame, text=">", command=self._move_to_selected).pack(pady=5)
        ttk.Button(button_frame, text=">>", command=self._move_all_to_selected).pack(pady=5)
        ttk.Button(button_frame, text="<", command=self._move_to_available).pack(pady=5)
        ttk.Button(button_frame, text="<<", command=self._move_all_to_available).pack(pady=5)
    def _move_to_selected(self):
        selected_indices = self.available_listbox.curselection()
        for i in reversed(selected_indices):
            item = self.available_listbox.get(i)
            self.selected_listbox.insert(END, item)
            self.available_listbox.delete(i)
    def _move_all_to_selected(self):
        items = self.available_listbox.get(0, END)
        for item in items:
            self.selected_listbox.insert(END, item)
        self.available_listbox.delete(0, END)
    def _move_to_available(self):
        selected_indices = self.selected_listbox.curselection()
        for i in reversed(selected_indices):
            item = self.selected_listbox.get(i)
            self.available_listbox.insert(END, item)
            self.selected_listbox.delete(i)
    def _move_all_to_available(self):
        items = self.selected_listbox.get(0, END)
        for item in items:
            self.available_listbox.insert(END, item)
        self.selected_listbox.delete(0, END)
    def get_selected_items(self) -> list:
        """Returns the final list of items in the 'selected' box."""
        return list(self.selected_listbox.get(0, END))
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\custom_widgets\scrolled_frame.py
# JUMLAH BARIS : 47
#######################################################################

```py
import ttkbootstrap as ttk
class ScrolledFrame(ttk.Frame):
    """
    A reusable frame that includes a vertical scrollbar.
    Widgets should be packed into the .scrollable_frame attribute.
    """
    def __init__(self, parent, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.vscrollbar = ttk.Scrollbar(self, orient="vertical")
        self.vscrollbar.pack(fill="y", side="right", expand=False)
        self.canvas = ttk.Canvas(self, bd=0, highlightthickness=0,
                           yscrollcommand=self.vscrollbar.set)
        self.canvas.pack(side="left", fill="both", expand=True)
        self.vscrollbar.config(command=self.canvas.yview)
        self.canvas.xview_moveto(0)
        self.canvas.yview_moveto(0)
        self.scrollable_frame = ttk.Frame(self.canvas)
        self.interior_id = self.canvas.create_window(0, 0, window=self.scrollable_frame,
                                       anchor="nw")
        self.scrollable_frame.bind("<Configure>", self._on_frame_configure)
        self.canvas.bind("<Configure>", self._on_canvas_configure)
    def destroy(self):
        """
        Custom destroy method to safely unlink canvas and scrollbar before destruction.
        This prevents race conditions and the 'invalid command name' TclError.
        """
        if self.canvas.winfo_exists():
            self.canvas.configure(yscrollcommand='')
        if self.vscrollbar.winfo_exists():
            self.vscrollbar.configure(command='')
        super().destroy()
    def _on_frame_configure(self, event):
        """Reset the scroll region to encompass the inner frame"""
        if self.canvas.winfo_exists():
            self.canvas.config(scrollregion=self.canvas.bbox("all"))
    def _on_canvas_configure(self, event):
        """Use the canvas width to configure the inner frame's width"""
        if self.canvas.winfo_exists():
            self.canvas.itemconfig(self.interior_id, width=event.width)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\custom_widgets\StandardButtons.py
# JUMLAH BARIS : 36
#######################################################################

```py
import ttkbootstrap as ttk
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class StandardButton(ttk.Button):
    def __init__(self, parent, kernel, **kwargs):
        self.api_client = ApiClient()
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        super().__init__(parent, **kwargs)
class SaveButton(StandardButton):
    """A standard Save button that automatically gets its text and success style."""
    def __init__(self, parent, kernel, **kwargs):
        text = kernel.get_service("localization_manager").get('button_save', fallback="Simpan")
        super().__init__(parent, kernel, text=text, bootstyle="success", **kwargs)
class CancelButton(StandardButton):
    """A standard Cancel button that automatically gets its text and secondary style."""
    def __init__(self, parent, kernel, **kwargs):
        text = kernel.get_service("localization_manager").get('button_cancel', fallback="Batal")
        super().__init__(parent, kernel, text=text, bootstyle="secondary", **kwargs)
class DeleteButton(StandardButton):
    """A standard Delete button that automatically gets its text and danger style."""
    def __init__(self, parent, kernel, **kwargs):
        text = kernel.get_service("localization_manager").get('trigger_btn_delete', fallback="Hapus")
        super().__init__(parent, kernel, text=text, bootstyle="danger", **kwargs)
class EditButton(StandardButton):
    """A standard Edit button that automatically gets its text and info style."""
    def __init__(self, parent, kernel, **kwargs):
        text = kernel.get_service("localization_manager").get('trigger_btn_edit', fallback="Edit...")
        super().__init__(parent, kernel, text=text, bootstyle="info", **kwargs)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\custom_widgets\tooltip.py
# JUMLAH BARIS : 52
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import TclError
class ToolTip:
    """Membuat tooltip (hover text) untuk sebuah widget."""
    def __init__(self, widget):
        self.widget = widget
        self.text = "" # Inisialisasi dengan string kosong
        self.tooltip_window = None
        self.widget.bind("<Enter>", self.show_tooltip)
        self.widget.bind("<Leave>", self.hide_tooltip)
    def show_tooltip(self, event=None):
        if self.tooltip_window or not self.text:
            return
        x, y, _, _ = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 25
        self.tooltip_window = tw = ttk.Toplevel(self.widget)
        tw.wm_overrideredirect(True)
        tw.wm_geometry(f"+{x}+{y}")
        try:
            colors = self.widget.winfo_toplevel().kernel.theme_manager.get_colors()
            bg_color = colors.get('bg', '#222222')
            fg_color = colors.get('fg', '#FFFFFF')
        except (AttributeError, TclError):
            bg_color="#222222"
            fg_color = "#FFFFFF"
        label = ttk.Label(
            tw,
            text=self.text,
            justify='left',
            background=bg_color,
            foreground=fg_color,
            relief='solid',
            borderwidth=1,
            font=("tahoma", "8", "normal"),
            padding=4
        )
        label.pack(ipadx =1)
    def hide_tooltip(self, event=None):
        if self.tooltip_window:
            self.tooltip_window.destroy()
        self.tooltip_window= None
    def update_text(self, new_text):
        self.text = new_text
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\lifecycle\AppLifecycleHandler.py
# JUMLAH BARIS : 124
#######################################################################

```py
from tkinter import messagebox
import logging
import threading
from PIL import Image
import pystray
import sys
import os
import shutil # (DITAMBAHKAN) Butuh ini untuk hapus folder
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class AppLifecycleHandler:
    def __init__(self, main_window, kernel):
        self.api_client = ApiClient()
        self.main_window = main_window
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        self.tray_icon = None
        self.tray_thread = None
        event_bus = self.kernel.get_service("event_bus")
        if event_bus:
            event_bus.subscribe("RESTART_APP", "lifecycle_handler_restart", self._on_restart_request)
            event_bus.subscribe("RESTART_APP_AFTER_UPDATE", "lifecycle_handler_update_restart", self._on_restart_request)
            event_bus.subscribe("REQUEST_CLEANUP_AND_EXIT", "lifecycle_handler_deactivation", self._on_cleanup_and_exit_request)
            self.kernel.write_to_log("LifecycleHandler is now listening for RESTART and EXIT events.", "INFO")
    def on_closing_app(self):
        self.main_window.withdraw()
        self._create_or_show_tray_icon()
    def _on_restart_request(self, event_data=None):
        """Handles the application restart logic triggered by an event."""
        self.kernel.write_to_log("Restart request received via EventBus. Initiating shutdown...", "WARN")
        self.kernel.stop_all_services()
        self.main_window.destroy()
        os.execl(sys.executable, sys.executable, *sys.argv)
        sys.exit(0)
    def _on_cleanup_and_exit_request(self, event_data=None):
        """Handles the full cleanup and exit process after a license deactivation."""
        self.kernel.write_to_log("Cleanup and Exit request received. Starting process...", "WARN")
        self.main_window.after(100, self._perform_safe_cleanup_and_exit)
    def _perform_safe_cleanup_and_exit(self):
        """Contains the actual logic for clearing cache and then exiting."""
        self.kernel.write_to_log("Performing cache cleanup...", "INFO")
        deleted_folders, deleted_files = 0, 0
        current_log_file = None
        if self.kernel.file_logger and self.kernel.file_logger.handlers:
            current_log_file = self.kernel.file_logger.handlers[0].baseFilename
        for root, dirs, files in os.walk(self.kernel.project_root_path, topdown=False):
            if '__pycache__' in dirs:
                pycache_path = os.path.join(root, '__pycache__')
                try:
                    shutil.rmtree(pycache_path)
                    deleted_folders += 1
                except (OSError, PermissionError):
                    self.kernel.write_to_log(f"Could not delete cache folder (in use): {os.path.basename(pycache_path)}", "WARN")
            for name in files:
                if name.endswith(".pyc") or name.endswith(".log"):
                    file_path = os.path.join(root, name)
                    if file_path == current_log_file:
                        continue
                    try:
                        os.remove(file_path)
                        deleted_files += 1
                    except (OSError, PermissionError):
                        pass # Ignore if file is locked
        self.kernel.write_to_log(f"Cache cleanup finished. Deleted {deleted_folders} folders and {deleted_files} files.", "SUCCESS")
        self._perform_safe_exit(ask_confirmation=False) # Langsung keluar tanpa tanya lagi
    def _create_or_show_tray_icon(self):
        """Creates and runs the system tray icon in a separate thread if it's not already running."""
        if self.tray_thread and self.tray_thread.is_alive():
            return
        try:
            image = Image.open("flowork-icon.ico")
        except FileNotFoundError:
            self.kernel.write_to_log("System tray icon.png not found, using placeholder.", "ERROR")
            image = Image.new('RGB', (64, 64), color = 'blue')
        menu = (
            pystray.MenuItem(
                self.loc.get('tray_menu_show', fallback='Show Flowork'),
                self._show_window,
                default=True
            ),
            pystray.Menu.SEPARATOR,
            pystray.MenuItem(
                self.loc.get('tray_menu_exit', fallback='Exit Flowork'),
                lambda: self._exit_app(ask_confirmation=True) # (MODIFIKASI) Panggil dengan konfirmasi
            )
        )
        self.tray_icon = pystray.Icon("flowork", image, "Flowork", menu)
        self.tray_thread = threading.Thread(target=self.tray_icon.run, daemon=True)
        self.tray_thread.start()
        self.kernel.write_to_log("Application minimized to system tray.", "INFO")
    def _show_window(self):
        """Shows the main window when the tray icon option is clicked."""
        if self.tray_icon:
            self.tray_icon.stop()
        self.main_window.after(0, self.main_window.deiconify)
    def _perform_safe_exit(self, ask_confirmation=True):
        """This method contains the actual shutdown logic and is designed to be called on the main UI thread."""
        should_save = True
        if ask_confirmation:
            should_save = messagebox.askyesnocancel(
                self.loc.get('confirm_exit_title', fallback="Exit Application"),
                self.loc.get('confirm_exit_save_workflow_message', fallback="Do you want to save your work before exiting?")
            )
        if should_save is None:
            self.kernel.write_to_log("Exit process cancelled by user.", "INFO")
            return
        if should_save:
            self.main_window.save_layout_and_session()
        self.kernel.write_to_log("Application exit initiated.", "INFO")
        self.kernel.stop_all_services()
        self.main_window.destroy()
        sys.exit(0)
    def _exit_app(self, ask_confirmation=True):
        """The real exit logic for the application."""
        if self.tray_icon:
            self.tray_icon.stop()
        self.main_window.after(0, self._perform_safe_exit, ask_confirmation)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\popups\approval_popup.py
# JUMLAH BARIS : 80
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import Toplevel, Label, Button
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class ApprovalPopup(Toplevel):
    """
    Kelas mandiri yang bertanggung jawab untuk membuat dan menampilkan
    jendela popup persetujuan manual.
    """
    def __init__(self, popup_manager, kernel, module_id, workflow_name, message):
        self.api_client = ApiClient()
        super().__init__(popup_manager.main_window)
        self.popup_manager = popup_manager
        self.kernel = kernel
        self.loc = kernel.get_service("localization_manager")
        self.title(self.loc.get('manual_approval_title', fallback="Persetujuan Manual Dibutuhkan"))
        self.transient(popup_manager.main_window)
        self.grab_set()
        self.resizable(False, False)
        theme_manager = self.kernel.get_service("theme_manager")
        colors = theme_manager.get_colors() if theme_manager else {'bg': '#222'}
        self.configure(background=colors.get('bg', '#222'))
        self._create_widgets(workflow_name, message, colors)
        self._center_window()
    def _create_widgets(self, workflow_name, message, colors):
        """Membangun semua elemen UI di dalam popup."""
        main_frame = ttk.Frame(self, padding=20)
        main_frame.pack(expand=True, fill="both")
        message_text = self.loc.get('manual_approval_message', workflow_name=workflow_name, node_message=message)
        Label(
            main_frame,
            text=message_text,
            wraplength=400,
            justify="center",
            background=colors.get('bg', '#222'),
            foreground=colors.get('fg', '#fff'),
            font=("Helvetica", 10)
        ).pack(pady=(0, 20))
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill="x")
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        Button(
            button_frame,
            text=self.loc.get('button_reject', fallback="Tolak"),
            command=lambda: self.popup_manager.handle_approval_response('REJECTED'),
            bg=colors.get('danger', '#dc3545'),
            fg=colors.get('light', '#fff'),
            relief="flat",
            width=15
        ).grid(row=0, column=0, padx=(0, 5), sticky="e")
        Button(
            button_frame,
            text=self.loc.get('button_approve', fallback="Setuju"),
            command=lambda: self.popup_manager.handle_approval_response('APPROVED'),
            bg=colors.get('success', '#28a745'),
            fg=colors.get('light', '#fff'),
            relief="flat",
            width=15
        ).grid(row=0, column=1, padx=(5, 0), sticky="w")
    def _center_window(self):
        """Menghitung dan mengatur posisi popup agar berada di tengah parent."""
        self.update_idletasks()
        parent_window = self.popup_manager.main_window
        parent_x = parent_window.winfo_x()
        parent_y = parent_window.winfo_y()
        parent_width = parent_window.winfo_width()
        parent_height = parent_window.winfo_height()
        popup_width = self.winfo_width()
        popup_height = self.winfo_height()
        win_x = parent_x + (parent_width // 2) - (popup_width // 2)
        win_y = parent_y + (parent_height // 2) - (popup_height // 2)
        self.geometry(f"+{win_x}+{win_y}")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\popups\forced_update_popup.py
# JUMLAH BARIS : 70
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import Toplevel, scrolledtext
import webbrowser
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class ForcedUpdatePopup(Toplevel):
    """
    A custom, non-closable popup that forces the user to update.
    This version is fully localized.
    """
    def __init__(self, parent, kernel, update_info):
        self.api_client = ApiClient()
        super().__init__(parent)
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        self.update_info = update_info
        self.title(self.loc.get('update_popup_title', fallback="Mandatory Update Available"))
        self.transient(parent)
        self.grab_set()
        self.resizable(False, False)
        self.protocol("WM_DELETE_WINDOW", lambda: None)
        theme_manager = self.kernel.get_service("theme_manager")
        colors = theme_manager.get_colors() if theme_manager else {'bg': '#222'}
        self.configure(background=colors.get('bg', '#222'))
        self._create_widgets(colors)
        self._center_window()
    def _create_widgets(self, colors):
        main_frame = ttk.Frame(self, padding=20)
        main_frame.pack(expand=True, fill="both")
        version = self.update_info.get('version', 'N/A')
        header_text = self.loc.get('update_popup_header', fallback="Update to Version {version} Required", version=version)
        ttk.Label(main_frame, text=header_text, font=("Helvetica", 14, "bold")).pack(pady=(0, 10))
        ttk.Label(main_frame, text=self.loc.get('update_popup_changelog_label', fallback="Changes in this version:"), justify="left").pack(anchor='w', pady=(10, 2))
        changelog_text = scrolledtext.ScrolledText(main_frame, height=8, wrap="word", font=("Helvetica", 9))
        changelog_text.pack(fill="both", expand=True, pady=(0, 15))
        changelog_content = self.update_info.get('changelog', ["No details available."])
        changelog_text.insert("1.0", "\n".join(f"- {item}" for item in changelog_content))
        changelog_text.config(state="disabled")
        self.update_button = ttk.Button(
            main_frame,
            text=self.loc.get('update_popup_button', fallback="Download Update & Exit"),
            command=self._do_update,
            bootstyle="success"
        )
        self.update_button.pack(fill='x', ipady=5)
    def _do_update(self):
        self.update_button.config(state="disabled", text=self.loc.get('update_popup_button_loading', fallback="Opening browser..."))
        download_url = self.update_info.get('download_url')
        if download_url:
            webbrowser.open(download_url)
        self.after(2000, self.kernel.root.destroy)
    def _center_window(self):
        self.update_idletasks()
        parent_window = self.master
        parent_x = parent_window.winfo_x()
        parent_y = parent_window.winfo_y()
        parent_width = parent_window.winfo_width()
        parent_height = parent_window.winfo_height()
        popup_width = self.winfo_width()
        popup_height = self.winfo_height()
        win_x = parent_x + (parent_width // 2) - (popup_width // 2)
        win_y = parent_y + (parent_height // 2) - (popup_height // 2)
        self.geometry(f"+{win_x}+{win_y}")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\popups\license_popup.py
# JUMLAH BARIS : 91
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import Toplevel, Label, Button, StringVar
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class LicensePopup(Toplevel):
    """
    Kelas mandiri yang bertanggung jawab untuk membuat dan menampilkan
    jendela popup yang meminta pengguna memasukkan kunci lisensi.
    """
    def __init__(self, parent_window, kernel, module_name, license_event, callback):
        self.api_client = ApiClient()
        super().__init__(parent_window)
        self.parent_window = parent_window
        self.kernel = kernel
        self.loc = kernel.get_service("localization_manager")
        self.license_event = license_event
        self.callback = callback
        self.license_key_var = StringVar()
        self.title(self.loc.get('license_popup_title', fallback="Aktivasi Fitur Premium"))
        self.transient(parent_window)
        self.grab_set()
        self.resizable(False, False)
        theme_manager = self.kernel.get_service("theme_manager")
        colors = theme_manager.get_colors() if theme_manager else {'bg': '#222'}
        self.configure(background=colors.get('bg', '#222'))
        self._create_widgets(module_name, colors)
        self._center_window()
    def _create_widgets(self, module_name, colors):
        """Membangun semua elemen UI di dalam popup."""
        main_frame = ttk.Frame(self, padding=20)
        main_frame.pack(expand=True, fill="both")
        info_text = self.loc.get('license_popup_message', module_name=module_name, fallback=f"Modul '{module_name}' adalah fitur premium.\n\nSilakan masukkan kunci lisensi Anda untuk mengaktifkan.")
        Label(
            main_frame,
            text=info_text,
            wraplength=400,
            justify="center",
            background=colors.get('bg', '#222'),
            foreground=colors.get('fg', '#fff'),
            font=("Helvetica", 10)
        ).pack(pady=(0, 20))
        ttk.Label(main_frame, text=self.loc.get('license_popup_entry_label', fallback="Kunci Lisensi:")).pack(anchor='w')
        entry = ttk.Entry(main_frame, textvariable=self.license_key_var, font=("Consolas", 11))
        entry.pack(fill='x', expand=True, pady=(2, 20))
        entry.focus_set()
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill="x")
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        cancel_button = ttk.Button(
            button_frame,
            text=self.loc.get('button_cancel', fallback="Batal"),
            command=self._on_cancel,
            style="secondary.TButton"
        )
        cancel_button.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        activate_button = ttk.Button(
            button_frame,
            text=self.loc.get('license_popup_activate_button', fallback="Aktifkan"),
            command=self._on_activate,
            style="success.TButton"
        )
        activate_button.grid(row=0, column=1, sticky="ew", padx=(5, 0))
    def _on_activate(self):
        """Dipanggil saat tombol 'Aktifkan' ditekan."""
        entered_key = self.license_key_var.get()
        self.callback(entered_key, self.license_event)
        self.destroy()
    def _on_cancel(self):
        """Dipanggil saat tombol 'Batal' ditekan."""
        self.callback("", self.license_event)
        self.destroy()
    def _center_window(self):
        """Menghitung dan mengatur posisi popup agar berada di tengah parent."""
        self.update_idletasks()
        parent_x = self.parent_window.winfo_x()
        parent_y = self.parent_window.winfo_y()
        parent_width = self.parent_window.winfo_width()
        parent_height = self.parent_window.winfo_height()
        popup_width = self.winfo_width()
        popup_height = self.winfo_height()
        win_x = parent_x + (parent_width // 2) - (popup_width // 2)
        win_y = parent_y + (parent_height // 2) - (popup_height // 2)
        self.geometry(f"+{win_x}+{win_y}")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\popups\NotificationManager.py
# JUMLAH BARIS : 52
#######################################################################

```py
from .NotificationToast import NotificationToast
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class NotificationManager:
    """
    Manages the queue, positioning, and appearance of multiple NotificationToasts.
    """
    def __init__(self, main_window, kernel):
        self.api_client = ApiClient()
        self.main_window = main_window
        self.kernel = kernel
        self.active_toasts = []
        self.padding = 10  # Jarak antar popup dan dari tepi layar
        self.toast_width = 300
        self.toast_height = 80
    def show_toast(self, title, message, level="INFO"):
        """Fungsi utama untuk menampilkan notifikasi baru."""
        loc = self.kernel.get_service("localization_manager")
        if not loc:
            return
        if not loc.get_setting("notifications_enabled", True):
            return # Jangan tampilkan jika dinonaktifkan di pengaturan
        duration_seconds = loc.get_setting("notifications_duration_seconds", 5)
        duration_ms = int(duration_seconds * 1000)
        toast = NotificationToast(self.main_window, title, message, level, duration=duration_ms)
        self.active_toasts.append(toast)
        self._reposition_toasts()
        self.main_window.after(duration_ms + 1000, lambda: self._remove_toast_from_list(toast))
    def _reposition_toasts(self):
        """Menghitung ulang dan mengatur posisi semua toast yang aktif."""
        if not self.main_window.winfo_exists():
            return
        screen_width = self.main_window.winfo_screenwidth()
        screen_height = self.main_window.winfo_screenheight()
        start_x = screen_width - self.toast_width - self.padding
        current_y = screen_height - self.toast_height - self.padding
        for toast in self.active_toasts:
            if toast.winfo_exists():
                toast.set_position(start_x, current_y)
                current_y -= (self.toast_height + self.padding)
    def _remove_toast_from_list(self, toast_to_remove):
        """Menghapus referensi toast dari daftar setelah animasinya selesai."""
        if toast_to_remove in self.active_toasts:
            self.active_toasts.remove(toast_to_remove)
        self._reposition_toasts()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\popups\NotificationToast.py
# JUMLAH BARIS : 61
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import Toplevel
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class NotificationToast(Toplevel):
    """
    Kelas untuk membuat jendela popup notifikasi (toast) yang bisa hilang otomatis.
    """
    def __init__(self, parent, title, message, level="INFO", duration=5000):
        self.api_client = ApiClient()
        super().__init__(parent)
        self.parent = parent
        self.duration = duration
        self.alpha = 0.0
        self.target_alpha = 0.9
        self.fade_step = 0.05
        self.overrideredirect(True)
        self.wm_attributes("-topmost", True)
        self.attributes('-alpha', self.alpha)
        style_map = {
            "SUCCESS": "success",
            "INFO": "info",
            "WARN": "warning",
            "ERROR": "danger"
        }
        bootstyle = style_map.get(level.upper(), "primary")
        main_frame = ttk.Frame(self, bootstyle=f"{bootstyle}.TFrame", padding=1, relief="solid")
        main_frame.pack(expand=True, fill="both")
        content_frame = ttk.Frame(main_frame, bootstyle="dark.TFrame", padding=(10, 5))
        content_frame.pack(expand=True, fill="both")
        title_label = ttk.Label(content_frame, text=title, font=("Helvetica", 10, "bold"), bootstyle=f"{bootstyle}.inverse")
        title_label.pack(fill="x")
        message_label = ttk.Label(content_frame, text=message, wraplength=280, font=("Helvetica", 9), bootstyle="secondary.inverse")
        message_label.pack(fill="x", pady=(2, 5))
        self.fade_in()
    def fade_in(self):
        """Animasi untuk memunculkan popup secara perlahan."""
        if self.alpha < self.target_alpha:
            self.alpha += self.fade_step
            self.attributes('-alpha', self.alpha)
            self.after(20, self.fade_in)
        else:
            self.after(self.duration, self.fade_out)
    def fade_out(self):
        """Animasi untuk menghilangkan popup secara perlahan."""
        if self.alpha > 0.0:
            self.alpha -= self.fade_step
            self.attributes('-alpha', self.alpha)
            self.after(30, self.fade_out)
        else:
            self.destroy()
    def set_position(self, x, y):
        """Menempatkan jendela popup di posisi yang ditentukan."""
        self.geometry(f"+{x}+{y}")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\popups\PopupManager.py
# JUMLAH BARIS : 49
#######################################################################

```py
from .approval_popup import ApprovalPopup
from .license_popup import LicensePopup
from .NotificationManager import NotificationManager
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class PopupManager:
    """
    Acts as a centralized command center for all popups in the application.
    This includes manual approvals, license prompts, and notification toasts.
    """
    def __init__(self, main_window, kernel):
        self.api_client = ApiClient()
        self.main_window = main_window
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        self.notification_manager = NotificationManager(self.main_window, self.kernel)
        self._current_approval_popup = None
        self._current_approval_module_id = None
        self.current_license_popup = None
    def show_notification(self, title: str, message: str, level: str = "INFO"):
        """Displays a notification toast."""
        self.notification_manager.show_toast(title, message, level)
        self.kernel.write_to_log(f"POPUP NOTIFICATION: {title} - {message}", level)
    def show_approval(self, module_id, workflow_name, message):
        """Displays a manual approval dialog."""
        if self._current_approval_popup and self._current_approval_popup.winfo_exists():
            self.kernel.write_to_log(f"Popup request for '{module_id}' ignored, another popup is active.", "WARN")
            return
        self._current_approval_module_id = module_id
        self._current_approval_popup = ApprovalPopup(self, self.kernel, module_id, workflow_name, message)
    def handle_approval_response(self, result: str):
        """Handles the user's response from the approval dialog."""
        if self._current_approval_module_id:
            module_manager = self.kernel.get_service("module_manager_service")
            if module_manager:
                module_manager.notify_approval_response(self._current_approval_module_id, result)
        if self._current_approval_popup and self._current_approval_popup.winfo_exists():
            self._current_approval_popup.destroy()
        self._current_approval_popup, self._current_approval_module_id = None, None
    def show_license_prompt(self):
        """Displays the license activation dialog."""
        self.main_window.prompt_for_license_file()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\ui_components\menubar_manager.py
# JUMLAH BARIS : 67
#######################################################################

```py
from tkinter import Menu
import webbrowser
from utils.performance_logger import log_performance
class MenubarManager:
    """
    (MODIFIED) The menubar is now DYNAMIC and 100% API-DRIVEN.
    It fetches its entire structure from the server and builds the UI accordingly.
    It includes a simple command dispatcher to handle actions sent from the server.
    """
    def __init__(self, main_window, api_client, loc_service):
        self.main_window = main_window
        self.api_client = api_client
        self.loc = loc_service # The localization helper is passed in.
        self.menubar = Menu(self.main_window)
        self.main_window.config(menu=self.menubar)
        self.main_window.main_menus = {}
    def _command_dispatcher(self, command_obj):
        """
        ADDED: This is the core of the new API-driven command system.
        It interprets the command object from the server and calls the appropriate LOCAL UI function.
        """
        command_type = command_obj.get("type")
        command_value = command_obj.get("value")
        if command_type == "open_tab":
            print(f"ACTION: Open managed tab '{command_value}'") # English Log
        elif command_type == "open_url":
            webbrowser.open(command_value)
        elif command_type == "show_about_dialog":
            pass
        elif command_type == "exit_app":
            pass
        else:
            print(f"Warning: Unknown menu command type received from server: {command_type}") # English Log
    @log_performance("Building main menubar from API")
    def build_menu(self):
        self.menubar.delete(0, 'end' )
        self.main_window.main_menus.clear()
        success, menu_data = self.api_client.get_menubar()
        if not success:
            error_menu = Menu(self.menubar, tearoff=0)
            self.menubar.add_cascade(label="Error", menu=error_menu) # English Hardcode
            error_menu.add_command(label="Could not load menu from server") # English Hardcode
            return
        for menu_dict in menu_data:
            parent_label = menu_dict.get("label")
            menu_items = menu_dict.get("items", [])
            new_menu = Menu(self.menubar, tearoff=0)
            self.menubar.add_cascade(label=parent_label, menu=new_menu)
            self.main_window.main_menus[parent_label] = new_menu
            for item in menu_items:
                if item.get("type") == "separator":
                    new_menu.add_separator()
                else:
                    item_label = item.get("label")
                    command_obj = item.get("command")
                    new_menu.add_command(
                        label=item_label,
                        command=lambda cmd=command_obj: self._command_dispatcher(cmd)
                    )
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\ui_components\tab_manager.py
# JUMLAH BARIS : 127
#######################################################################

```py
import uuid
from flowork_gui.views.workflow_editor_tab import WorkflowEditorTab
from flowork_gui.plugins.flowork_core_ui.settings_tab import SettingsTab
from flowork_gui.plugins.flowork_core_ui.template_manager_page import TemplateManagerPage
from flowork_gui.plugins.flowork_core_ui.generator_page import GeneratorPage
from flowork_gui.plugins.flowork_core_ui.trigger_manager_page import TriggerManagerPage
from flowork_gui.plugins.flowork_core_ui.marketplace_page import MarketplacePage
from flowork_gui.plugins.flowork_core_ui.ai_architect_page import AiArchitectPage
from flowork_gui.plugins.flowork_core_ui.core_editor_page import CoreEditorPage
from flowork_gui.plugins.flowork_core_ui.pricing_page import PricingPage
from flowork_gui.plugins.flowork_core_ui.ai_trainer_page import AITrainerPage
from flowork_gui.plugins.flowork_core_ui.model_converter_page import ModelConverterPage
from flowork_gui.plugins.flowork_core_ui.prompt_manager_page import PromptManagerPage
import threading
from flowork_gui.utils.performance_logger import log_performance
class UITabManager:
    """
    Manages all tab-related operations on the GUI side.
    It fetches tab state from the API and renders the corresponding UI widgets.
    This is the client-side counterpart to the TabManagerService in the kernel.
    """
    def __init__(self, main_window, notebook_widget, api_client, loc_service):
        self.main_window = main_window
        self.notebook = notebook_widget
        self.api_client = api_client
        self.loc = loc_service
        self.opened_tabs = {} # Maps tab_key to widget instance
        self.custom_tab_count = 0
        self.initialized_tabs = set()
        self.SESSION_TAB_CLASSES = {
            "WorkflowEditorTab": WorkflowEditorTab,
            "SettingsTab": SettingsTab,
            "TemplateManagerPage": TemplateManagerPage,
            "GeneratorPage": GeneratorPage,
            "TriggerManagerPage": TriggerManagerPage,
            "MarketplacePage": MarketplacePage,
            "AiArchitectPage": AiArchitectPage,
            "CoreEditorPage": CoreEditorPage,
            "PricingPage": PricingPage,
            "AITrainerPage": AITrainerPage,
            "ModelConverterPage": ModelConverterPage,
            "PromptManagerPage": PromptManagerPage,
        }
        self.notebook.bind("<<NotebookTabChanged>>", self._on_tab_selected)
        print("[INFO] UI Tab Manager initialized.") # English Log
    def _on_tab_selected(self, event):
        """Callback to lazily load the content of a selected tab."""
        try:
            if not self.notebook or not self.notebook.winfo_exists() or not self.notebook.tabs():
                return
            selected_tab_widget = self.notebook.nametowidget(self.notebook.select())
            tab_key = str(selected_tab_widget)
            if tab_key not in self.initialized_tabs:
                if hasattr(selected_tab_widget, '_initialize_content'):
                    print(f"Lazy loading content for tab: {selected_tab_widget.__class__.__name__}") # English Log
                    selected_tab_widget._initialize_content()
                self.initialized_tabs.add(tab_key)
        except Exception as e:
            print(f"Could not lazy-load tab content: {e}") # English Log
    @log_performance("Loading entire tab session via API")
    def load_session_state(self):
        success, saved_tabs = self.api_client.get_tab_session()
        if not success:
            print(f"API Error loading tab session: {saved_tabs}. Starting with a default tab.") # English Log
            self.add_new_workflow_tab(is_default=True)
            return
        if not saved_tabs:
            self.add_new_workflow_tab(is_default=True)
            return
        for tab_id_str in list(self.notebook.tabs()):
            self.notebook.forget(tab_id_str)
        for tab_data in saved_tabs:
            class_name = tab_data.get("class_name")
            title = tab_data.get("title")
            tab_id = tab_data.get("tab_id")
            tab_key = tab_data.get("key")
            print(f"Loading tab '{title}' (Type: {class_name}, Key: {tab_key})") # English Log
            TargetTabClass = self.SESSION_TAB_CLASSES.get(class_name)
            if not TargetTabClass:
                print(f"Skipping tab '{title}' because its class ('{class_name}') is not registered in the UI Tab Manager.", "WARN") # English Log
                continue
            self._create_and_add_tab(TargetTabClass, title, tab_id=tab_id, is_new_tab=False, tab_key=tab_key)
        if len(self.notebook.tabs()) == 0:
            self.add_new_workflow_tab(is_default=True)
        else:
            self.notebook.select(0)
            self._on_tab_selected(None)
    @log_performance("Adding a new workflow tab")
    def add_new_workflow_tab(self, is_default=False):
        if is_default:
            title = f" {self.loc.get('workflow_editor_tab_title', fallback='Dashboard')} "
            return self._create_and_add_tab(WorkflowEditorTab, title, set_as_main=True, is_new_tab=True)
        else:
            self.custom_tab_count += 1
            title = f" {self.loc.get('untitled_tab_title', fallback='Untitled {count}', count=self.custom_tab_count)} "
            return self._create_and_add_tab(WorkflowEditorTab, title, is_new_tab=True)
    @log_performance("Creating and adding a generic tab")
    def _create_and_add_tab(self, frame_class, title, tab_id=None, set_as_main=False, is_new_tab=False, tab_key=None):
        new_tab_frame = frame_class(self.notebook, self.api_client, self.loc, tab_id=tab_id, is_new_tab=is_new_tab)
        self.notebook.add(new_tab_frame, text=title)
        self.notebook.select(new_tab_frame)
        if tab_key:
            self.opened_tabs[tab_key] = new_tab_frame
        return new_tab_frame
    def close_tab(self, tab_id_str):
        widget = self.notebook.nametowidget(tab_id_str)
        tab_key = str(widget)
        if tab_key in self.initialized_tabs:
            self.initialized_tabs.remove(tab_key)
        key_to_del = None
        for key, instance in self.opened_tabs.items():
            if instance == widget:
                key_to_del = key
                break
        if key_to_del:
            del self.opened_tabs[key_to_del]
        self.notebook.forget(tab_id_str)
        if len(self.notebook.tabs()) == 0:
            self.add_new_workflow_tab(is_default=True)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\views\ui_components\controllers\TabActionHandler.py
# JUMLAH BARIS : 143
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import filedialog, messagebox, simpledialog
import threading
import os
import shutil
import json
import uuid
import time
import random
class TabActionHandler:
    """
    Acts as the 'Controller' for the WorkflowEditorTab.
    It handles all user actions like running, saving, loading workflows,
    and managing the execution state for a specific tab.
    This class was created by refactoring the massive main_window.py.
    (REFACTORED V2) Now fully API-driven and receives its dependencies via constructor.
    """
    def __init__(self, tab_instance, api_client, loc_service): # MODIFIED: Signature updated to accept api_client and loc_service
        self.tab = tab_instance
        self.api_client = api_client
        self.loc = loc_service
    def run_workflow_from_preset(self, nodes, connections, initial_payload):
        """Used by widgets to trigger a run on this tab's canvas."""
        pass
    def _on_execution_finished(self, history_data):
        """Callback after a workflow run is complete."""
        pass
    def _start_workflow_thread(self, mode: str):
        """Prepares and starts the main workflow loop in a background thread."""
        pass
    def _workflow_loop_worker(self, mode: str, loop_count: int, delay_settings: dict):
        pass
    def run_workflow(self):
        self._start_workflow_thread(mode='EXECUTE')
    def simulate_workflow(self):
        self._start_workflow_thread(mode='SIMULATE')
    def _check_workflow_completion(self, exec_thread):
        pass
    def stop_workflow(self):
        pass
    def pause_workflow(self):
        pass
    def resume_workflow(self):
        pass
    def save_workflow(self):
        if not self.tab.canvas_area_instance or not self.tab.canvas_area_instance.canvas_manager:
            return
        workflow_data = self.tab.canvas_area_instance.canvas_manager.get_workflow_data()
        if not workflow_data.get("nodes"):
            messagebox.showwarning(self.loc.get('save_workflow_empty_title', fallback="Cannot Save Empty Workflow"), self.loc.get('save_workflow_empty_message', fallback="There are no nodes on the canvas to save."))
            return
        filepath = filedialog.asksaveasfilename(
            title=self.loc.get('save_workflow_title', fallback="Save Workflow File"),
            filetypes=[(self.loc.get('flowork_workflow_filetype', fallback="Flowork Workflow (*.json)"), "*.json"), ("All files", "*.*")],
            defaultextension=".json"
        )
        if not filepath: return
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(workflow_data, f, indent=4)
            print(f"Workflow saved to: {filepath}") # English Log
        except Exception as e:
            print(f"Failed to save workflow to {filepath}: {e}") # English Log
    def load_workflow(self):
        if not self.tab.canvas_area_instance or not self.tab.canvas_area_instance.canvas_manager:
            return
        if messagebox.askyesno(self.loc.get('confirm_load_workflow_title', fallback="Load Workflow?"), self.loc.get('confirm_load_workflow_message', fallback="Loading a workflow will discard any unsaved changes on the current canvas. Continue?")):
            filepath = filedialog.askopenfilename(
                title=self.loc.get('load_workflow_title', fallback="Load Workflow File"),
                filetypes=[(self.loc.get('flowork_workflow_filetype', fallback="Flowork Workflow (*.json)"), "*.json"), ("All files", "*.*")]
            )
            if not filepath: return
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    workflow_data = json.load(f)
                self.tab.canvas_area_instance.canvas_manager.load_workflow_data(workflow_data)
                self.tab.canvas_area_instance.preset_combobox.set('')
                print(f"Workflow loaded from: {filepath}") # English Log
            except Exception as e:
                print(f"Failed to load workflow from {filepath}: {e}") # English Log
    def clear_canvas(self, feedback=True):
        if hasattr(self.tab, '_clear_all_suggestions'):
            self.tab._clear_all_suggestions()
        if self.tab.canvas_area_instance:
            self.tab.canvas_area_instance.canvas_manager.clear_canvas(feedback)
            if hasattr(self.tab.canvas_area_instance, '_update_webhook_info'):
                self.tab.canvas_area_instance._update_webhook_info()
    def on_preset_selected(self, event=None):
        if not self.tab.canvas_area_instance: return
        selected_preset = self.tab.canvas_area_instance.preset_combobox.get()
        if not selected_preset: return
        threading.Thread(target=self._load_preset_worker, args=(selected_preset,), daemon=True).start()
    def _load_preset_worker(self, preset_name):
        self.tab.after(0, self.tab._clear_all_suggestions)
        success, data = self.api_client.get_preset_data(preset_name)
        self.tab.after(0, self._on_load_preset_complete, success, data, preset_name)
    def _on_load_preset_complete(self, success, data, preset_name):
        if not self.tab.canvas_area_instance: return
        if success:
            self.tab.canvas_area_instance.canvas_manager.load_workflow_data(data)
        else:
            messagebox.showerror(self.loc.get('error_title', fallback="Error"), f"API Error: {data}")
    def save_as_preset(self):
        if not self.tab.canvas_area_instance: return
        preset_name = simpledialog.askstring(self.loc.get('save_preset_popup_title', fallback="Save As Preset"), self.loc.get('save_preset_popup_prompt', fallback="Enter a name for this preset:"), parent=self.tab)
        if not preset_name or not preset_name.strip(): return
        preset_name = preset_name.strip()
        workflow_data = self.tab.canvas_area_instance.canvas_manager.get_workflow_data()
        threading.Thread(target=self._save_preset_worker, args=(preset_name, workflow_data), daemon=True).start()
    def _save_preset_worker(self, preset_name, workflow_data):
        success, response = self.api_client.save_preset(preset_name, workflow_data)
        self.tab.after(0, self._on_save_preset_complete, success, response, preset_name)
    def _on_save_preset_complete(self, success, response, preset_name):
        if not self.tab.canvas_area_instance: return
        if success:
            self.tab.populate_preset_dropdown()
            self.tab.canvas_area_instance.preset_combobox.set(preset_name)
        else:
            messagebox.showerror(self.loc.get('error_title', fallback="Error"), f"API Error: {response}")
    def _delete_selected_preset(self):
        if not self.tab.canvas_area_instance: return
        selected_preset = self.tab.canvas_area_instance.preset_combobox.get()
        if not selected_preset: return
        if messagebox.askyesno(self.loc.get('confirm_delete_title', fallback="Confirm Deletion"), self.loc.get('confirm_delete_preset_message', fallback="Are you sure you want to delete the preset '{name}'?", name=selected_preset)):
            threading.Thread(target=self._delete_preset_worker, args=(selected_preset,), daemon=True).start()
    def _delete_preset_worker(self, preset_name):
        success, response = self.api_client.delete_preset(preset_name)
        self.tab.after(0, self._on_delete_preset_complete, success, response, preset_name)
    def _on_delete_preset_complete(self, success, response, preset_name):
        if success:
            self.tab.populate_preset_dropdown()
        else:
            messagebox.showerror(self.loc.get('error_title', fallback="Error"), f"API Error: {response}")
    def clear_cache(self):
        pass
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\canvas_area\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "cae1d0acc4b43aacd47bb2ac10a6428f56a651e137f87f0378d2f0c48e2d7118",
    "manifest_hash": "5c97fd8a5797a7f1735fb2c60f26da715b2131e3c3acebb0f90adf7f3769cf89",
    "timestamp": 1757229857.0494883
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\canvas_area\canvas_area_widget.py
# JUMLAH BARIS : 248
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import messagebox, simpledialog, scrolledtext, Menu
import urllib.parse
import json
import threading
from ...views.version_manager_popup import VersionManagerPopup # PENAMBAHAN: Import relatif yang benar
from ...views.custom_widgets.tooltip import ToolTip # PENAMBAHAN: Import relatif yang benar
from ...api_contract import BaseDashboardWidget # PENAMBAHAN: Import relatif yang benar
from ...views.canvas_manager import CanvasManager # PENAMBAHAN: Import relatif yang benar
from ..data_canvas_widget.data_canvas_widget import DataCanvasWidget # PENAMBAHAN: Import relatif yang benar
class CanvasAreaWidget(BaseDashboardWidget):
    TIER = "free"
    """
    Widget that contains the main canvas and ALL its action buttons, including preset management.
    (REFACTORED) Now fully independent from the kernel, uses ApiClient for data.
    """
    def __init__(self, parent, coordinator_tab, kernel, widget_id: str):
        super().__init__(parent, coordinator_tab, kernel, widget_id)
        self.parent_tab = coordinator_tab
        self.canvas_manager = None
        self.execution_history = {}
        self.debugger_mode_var = ttk.BooleanVar(value=False)
        self.view_mode_var = ttk.StringVar(value="logic")
        self.loop_count_var = ttk.StringVar(value="1")
        self.loop_status_var = ttk.StringVar(value="")
        self.enable_delay_var = ttk.BooleanVar(value=True)
        self.delay_type_var = ttk.StringVar(value="static")
        self.static_delay_var = ttk.StringVar(value="1")
        self.random_min_var = ttk.StringVar(value="1")
        self.random_max_var = ttk.StringVar(value="10")
        self.hide_controls_job = None
        self._create_widgets()
        self.populate_preset_dropdown()
    def _recenter_floating_controls(self, event=None):
        """This function is called whenever the main widget resizes."""
        self.update_idletasks()
        if hasattr(self, 'floating_controls_panel') and self.floating_controls_panel and self.floating_controls_panel.winfo_exists() and self.floating_controls_panel.winfo_viewable():
            self.floating_controls_panel.place(in_=self, relx=0.5, rely=1.0, y=-10, anchor="s")
    def _create_widgets(self):
        colors = {'bg': '#222', 'dark': '#343a40'}
        self.bind("<Configure>", self._recenter_floating_controls)
        preset_bar_frame = ttk.Frame(self)
        preset_bar_frame.pack(side="top", fill='x', padx=5, pady=(0,5))
        preset_action_frame = ttk.Frame(preset_bar_frame)
        preset_action_frame.pack(fill='x', pady=(5,0))
        self.manage_versions_button = ttk.Button(preset_action_frame, text=self.loc.get('manage_versions_button', fallback="Manage Versions"), command=self._open_version_manager, style='info.TButton')
        self.manage_versions_button.pack(side='left', padx=(0, 10))
        ttk.Label(preset_action_frame, text=self.loc.get('load_preset_label', fallback="Load Preset:")).pack(side='left')
        self.preset_combobox = ttk.Combobox(preset_action_frame, state="readonly", width=30)
        self.preset_combobox.pack(side='left', fill='x', expand=True, padx=10)
        self.preset_combobox.bind("<<ComboboxSelected>>", self._on_preset_selected)
        self.delete_preset_button = ttk.Button(preset_action_frame, text=self.loc.get('delete_preset_button', fallback="Delete Preset"), command=self._delete_selected_preset, style='danger.TButton')
        self.delete_preset_button.pack(side='left', padx=(0, 5))
        self.save_preset_button = ttk.Button(preset_action_frame, text=self.loc.get('save_preset_button', fallback="Save as Preset"), command=self._save_as_preset, style='primary.TButton')
        self.save_preset_button.pack(side='left')
        self.webhook_info_frame = ttk.Frame(preset_bar_frame)
        self.webhook_info_frame.pack(fill='x', expand=True, pady=(5,0))
        ttk.Label(self.webhook_info_frame, text="Trigger URL:", style='Webhook.TLabel').pack(side='left', padx=(0, 5)) # English Hardcode
        self.webhook_url_var = ttk.StringVar()
        webhook_url_entry = ttk.Entry(self.webhook_info_frame, textvariable=self.webhook_url_var, state="readonly", width=60, style='Webhook.TEntry')
        webhook_url_entry.pack(side='left', fill='x', expand=True)
        copy_url_button = ttk.Button(self.webhook_info_frame, text="Copy", command=self._copy_webhook_url, style='secondary.TButton') # English Hardcode
        copy_url_button.pack(side='left', padx=5)
        self.canvas_container = ttk.Frame(self)
        self.canvas_container.pack(expand=True, fill='both')
        self.canvas_container.bind("<Button-3>", self._show_canvas_context_menu)
        self.logic_canvas_frame = ttk.Frame(self.canvas_container)
        self.data_canvas_frame = ttk.Frame(self.canvas_container)
        self.canvas = ttk.Canvas(self.logic_canvas_frame, background=colors.get('dark', '#343a40'))
        self.canvas.pack(expand=True, fill='both')
        self.canvas_manager = CanvasManager(self, self.parent_tab, self.canvas, self.kernel)
        self.data_canvas_widget = DataCanvasWidget(self.data_canvas_frame, self.parent_tab, self.kernel, "data_canvas_main")
        self.data_canvas_widget.pack(expand=True, fill='both')
        self.floating_controls_panel = ttk.Frame(self, style='dark.TFrame', padding=5)
        ttk.Separator(self.floating_controls_panel, bootstyle="danger").pack(side="top", fill="x", pady=(0, 5))
        management_group = ttk.LabelFrame(self.floating_controls_panel, text=self.loc.get('workflow_management_title', fallback="Workflow Management"), bootstyle="dark")
        management_group.pack(side='left', padx=(0, 10), fill='y')
        save_button = ttk.Button(management_group, text=self.loc.get('save_workflow_button', fallback="💾 Save"), command=self.parent_tab.action_handler.save_workflow, style='success.TButton')
        save_button.pack(side='left', padx=5, pady=5)
        load_button = ttk.Button(management_group, text=self.loc.get('load_workflow_button', fallback="📂 Load"), command=self.parent_tab.action_handler.load_workflow, style='info.TButton')
        load_button.pack(side='left', padx=5, pady=5)
        clear_button = ttk.Button(management_group, text=self.loc.get('clear_canvas_button', fallback="🧹 Clear"), command=self.parent_tab.action_handler.clear_canvas, style='danger.TButton')
        clear_button.pack(side='left', padx=5, pady=5)
        execution_control_group = ttk.LabelFrame(self.floating_controls_panel, text=self.loc.get('execution_control_title', fallback="Execution Control"), bootstyle="dark")
        execution_control_group.pack(side='left', padx=5, fill='y')
        loop_control_frame = ttk.Frame(execution_control_group, style='dark.TFrame')
        loop_control_frame.pack(fill='x', padx=5, pady=5)
        loop_count_frame = ttk.Frame(loop_control_frame, style='dark.TFrame')
        loop_count_frame.pack(side='left', fill='y')
        ttk.Label(loop_count_frame, text=self.loc.get('loop_run_label', fallback="Repeat:"), style='inverse-dark.TLabel').pack(side='left', padx=(0, 5))
        loop_entry = ttk.Entry(loop_count_frame, textvariable=self.loop_count_var, width=5)
        loop_entry.pack(side='left')
        ttk.Label(loop_count_frame, text=self.loc.get('loop_times_label', fallback="times"), style='inverse-dark.TLabel').pack(side='left', padx=(5, 10))
        ToolTip(loop_entry).update_text("Set how many times the entire workflow should run.")
        delay_options_frame = ttk.Frame(loop_control_frame, style='dark.TFrame')
        delay_options_frame.pack(side='left', fill='y', padx=(10,0))
        ttk.Checkbutton(delay_options_frame, text=self.loc.get('enable_delay_checkbox', fallback="Delay Between Loops"), variable=self.enable_delay_var, style='dark.TCheckbutton').pack(side='left')
        self.static_delay_frame = ttk.Frame(delay_options_frame, style='dark.TFrame')
        self.random_delay_frame = ttk.Frame(delay_options_frame, style='dark.TFrame')
        delay_type_radio_static = ttk.Radiobutton(delay_options_frame, text=self.loc.get('delay_type_static', fallback="Static"), variable=self.delay_type_var, value='static', style='dark.TRadiobutton')
        delay_type_radio_static.pack(side='left', padx=(10, 5))
        ttk.Entry(self.static_delay_frame, textvariable=self.static_delay_var, width=4).pack(side='left')
        ttk.Label(self.static_delay_frame, text="sec", style='inverse-dark.TLabel').pack(side='left', padx=(2,0)) # English Hardcode
        delay_type_radio_random = ttk.Radiobutton(delay_options_frame, text=self.loc.get('delay_type_random', fallback="Random"), variable=self.delay_type_var, value='random', style='dark.TRadiobutton')
        delay_type_radio_random.pack(side='left', padx=(10, 5))
        ttk.Entry(self.random_delay_frame, textvariable=self.random_min_var, width=4).pack(side='left')
        ttk.Label(self.random_delay_frame, text="-", style='inverse-dark.TLabel').pack(side='left', padx=2)
        ttk.Entry(self.random_delay_frame, textvariable=self.random_max_var, width=4).pack(side='left')
        ttk.Label(self.random_delay_frame, text="sec", style='inverse-dark.TLabel').pack(side='left', padx=(2,0)) # English Hardcode
        execution_buttons_frame = ttk.Frame(execution_control_group, style='dark.TFrame')
        execution_buttons_frame.pack(fill='x', pady=(5, 2), padx=5)
        self.simulate_button = ttk.Button(execution_buttons_frame, text=self.loc.get('simulate_workflow_button', fallback="Run Simulation"), command=self.parent_tab.action_handler.simulate_workflow, style='primary.TButton')
        self.simulate_button.pack(side='left', expand=True, fill='x', padx=(0,5))
        self.run_button = ttk.Button(execution_buttons_frame, text=self.loc.get('btn_run_workflow', fallback="Run Workflow"), command=self.parent_tab.action_handler.run_workflow, style='success.TButton')
        self.run_button.pack(side='left', expand=True, fill='x', padx=(0,5))
        self.pause_resume_button = ttk.Button(execution_buttons_frame, text=self.loc.get('btn_pause', fallback="Pause"), command=self.parent_tab.action_handler.pause_workflow, style='info.TButton', state='disabled')
        self.pause_resume_button.pack(side='left', expand=True, fill='x', padx=(0,5))
        self.loop_status_label = ttk.Label(execution_control_group, textvariable=self.loop_status_var, bootstyle="inverse-dark")
        self.loop_status_label.pack(fill='x', pady=(2,5), padx=5)
        view_toggle_frame = ttk.Frame(self.floating_controls_panel, style='dark.TFrame')
        view_toggle_frame.pack(side='left', padx=15, fill='y')
        logic_rb = ttk.Radiobutton(view_toggle_frame, text="Logic", variable=self.view_mode_var, value="logic", command=self._on_view_mode_change, style="light-outline-toolbutton") # English Hardcode
        logic_rb.pack(side='left', pady=10)
        data_rb = ttk.Radiobutton(view_toggle_frame, text="Data", variable=self.view_mode_var, value="data", command=self._on_view_mode_change, style="light-outline-toolbutton") # English Hardcode
        data_rb.pack(side='left', pady=10)
        debugger_toggle_frame = ttk.Frame(self.floating_controls_panel, style='dark.TFrame')
        debugger_toggle_frame.pack(side='left', padx=10, fill='y')
        debugger_switch = ttk.Checkbutton(debugger_toggle_frame, text="Debugger", variable=self.debugger_mode_var, bootstyle="info-round-toggle", command=self._toggle_debugger_mode) # English Hardcode
        debugger_switch.pack(side='left', pady=10)
        self._create_debugger_widgets()
        self._on_view_mode_change()
        self.canvas_container.bind("<Enter>", self._show_floating_controls)
        self.canvas_container.bind("<Leave>", self._schedule_hide_controls)
        self.floating_controls_panel.bind("<Enter>", self._cancel_hide_controls)
        self.floating_controls_panel.bind("<Leave>", self._schedule_hide_controls)
        def _toggle_delay_options(*args):
            if self.delay_type_var.get() == 'static':
                self.random_delay_frame.pack_forget()
                self.static_delay_frame.pack(side='left')
            else:
                self.static_delay_frame.pack_forget()
                self.random_delay_frame.pack(side='left')
        delay_type_radio_static.config(command=_toggle_delay_options)
        delay_type_radio_random.config(command=_toggle_delay_options)
        _toggle_delay_options()
    def _show_canvas_context_menu(self, event):
        if not self.canvas_manager: return
        self.canvas_manager.interaction_manager._show_canvas_context_menu(event)
    def _show_floating_controls(self, event=None):
        self._cancel_hide_controls()
        if hasattr(self, 'floating_controls_panel') and not self.floating_controls_panel.winfo_viewable():
            self.floating_controls_panel.place(in_=self, relx=0.5, rely=1.0, y=-10, anchor="s")
    def _schedule_hide_controls(self, event=None):
        self.hide_controls_job = self.after(500, self._check_and_hide_controls)
    def _cancel_hide_controls(self, event=None):
        if self.hide_controls_job:
            self.after_cancel(self.hide_controls_job)
            self.hide_controls_job = None
    def _check_and_hide_controls(self):
        if not self.winfo_exists(): return
        cursor_x = self.winfo_pointerx()
        cursor_y = self.winfo_pointery()
        canvas_x1 = self.canvas_container.winfo_rootx()
        canvas_y1 = self.canvas_container.winfo_rooty()
        canvas_x2 = canvas_x1 + self.canvas_container.winfo_width()
        canvas_y2 = canvas_y1 + self.canvas_container.winfo_height()
        panel_x1 = self.floating_controls_panel.winfo_rootx()
        panel_y1 = self.floating_controls_panel.winfo_rooty()
        panel_x2 = panel_x1 + self.floating_controls_panel.winfo_width()
        panel_y2 = panel_y1 + self.floating_controls_panel.winfo_height()
        is_over_canvas = (canvas_x1 <= cursor_x <= canvas_x2) and (canvas_y1 <= cursor_y <= canvas_y2)
        is_over_panel = self.floating_controls_panel.winfo_viewable() and (panel_x1 <= cursor_x <= panel_x2) and (panel_y1 <= cursor_y <= panel_y2)
        if not is_over_canvas and not is_over_panel:
            self.floating_controls_panel.place_forget()
        self.hide_controls_job = None
    def _on_view_mode_change(self):
        if self.view_mode_var.get() == "data":
            if self.canvas_manager:
                self.data_canvas_widget.sync_with_logic_canvas(self.canvas_manager.canvas_nodes)
            self.logic_canvas_frame.pack_forget()
            self.data_canvas_frame.pack(expand=True, fill='both')
        else:
            self.data_canvas_frame.pack_forget()
            self.logic_canvas_frame.pack(expand=True, fill='both')
    def _create_debugger_widgets(self):
        self.debugger_frame = ttk.LabelFrame(self, text=self.loc.get('debugger_title', fallback="Time-Travel Debugger"), padding=5)
    def _toggle_debugger_mode(self):
        if self.debugger_mode_var.get():
            self.show_debugger(self.execution_history or {})
        else:
            self.hide_debugger()
    def show_debugger(self, history_data):
        pass
    def hide_debugger(self):
        pass
    def _on_timeline_scrub(self, value):
        pass
    def populate_preset_dropdown(self):
        def _populate_worker():
            success, presets_data = self.api_client.get_presets()
            if success:
                presets = [p['name'] for p in presets_data]
                self.after(0, _update_combobox, presets)
            else:
                print(f"Failed to load preset list via API: {presets_data}") # English Log
        def _update_combobox(presets):
            self.preset_combobox['values'] = sorted(presets)
            current_selection = self.preset_combobox.get()
            if current_selection not in presets:
                self.preset_combobox.set('')
            self._update_webhook_info()
        threading.Thread(target=_populate_worker, daemon=True).start()
    def _update_webhook_info(self):
        self.webhook_info_frame.pack_forget()
    def _copy_webhook_url(self):
        url_to_copy = self.webhook_url_var.get()
        if url_to_copy:
            self.clipboard_clear()
            self.clipboard_append(url_to_copy)
            print(f"Webhook URL copied to clipboard: {url_to_copy}") # English Log
    def _on_preset_selected(self, event=None):
        if hasattr(self.parent_tab, 'action_handler'):
            self.parent_tab.action_handler.on_preset_selected(event)
    def _save_as_preset(self):
        if hasattr(self.parent_tab, 'action_handler'):
            self.parent_tab.action_handler.save_as_preset()
    def _delete_selected_preset(self):
        if hasattr(self.parent_tab, 'action_handler'):
            self.parent_tab.action_handler._delete_selected_preset()
    def _open_version_manager(self):
        selected_preset = self.preset_combobox.get()
        if not selected_preset:
            messagebox.showwarning(self.loc.get('warning_title', fallback="Warning"), self.loc.get('select_preset_to_delete_warning', fallback="Please select a preset first to manage its versions."))
            return
        VersionManagerPopup(self.parent_tab, self.kernel, selected_preset)
    def update_zoom_label(self):
        if hasattr(self, 'zoom_label') and self.canvas_manager and self.canvas_manager.interaction_manager and self.canvas_manager.interaction_manager.navigation_handler:
            self.zoom_label.config(text=f"{int(self.canvas_manager.interaction_manager.navigation_handler.zoom_level * 100)}%")
    def apply_styles(self, colors):
        pass
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\canvas_area\manifest.json
# JUMLAH BARIS : 13
#######################################################################

```json
{
    "id": "canvas_area",
    "name": "Kanvas Alur Kerja",
    "version": "1.0",
    "icon_file": "icon.png",
    "author": "Flowork Core",
    "email": "Contributor@teetah.art",
    "website": "www.teetah.art",
    "description": "Widget inti untuk menampilkan kanvas utama tempat node dan koneksi alur kerja berada.",
    "type": "DASHBOARD_WIDGET",
    "entry_point": "canvas_area_widget.CanvasAreaWidget",
    "is_system": true
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\canvas_area\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "cae1d0acc4b43aacd47bb2ac10a6428f56a651e137f87f0378d2f0c48e2d7118",
    "manifest_hash": "5c97fd8a5797a7f1735fb2c60f26da715b2131e3c3acebb0f90adf7f3769cf89",
    "timestamp": 1757204712.6009858
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\dataset_manager_widget\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "aa5295f57a4605f51b71bc022f3747d773716073e85d69096620290e8841c359",
    "manifest_hash": "539e42d0799f947d5d16ceb5e513d15f7a2bd645f27b9318e5932ad25e67eed7",
    "timestamp": 1757229863.0694551
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\dataset_manager_widget\dataset_manager_widget.py
# JUMLAH BARIS : 164
#######################################################################

```py
from flowork_gui.core import build_security # PENAMBAHAN: Importing from the new local GUI path.
import ttkbootstrap as ttk
from tkinter import simpledialog, messagebox
from tkinter.scrolledtext import ScrolledText
from flowork_gui.api_contract import BaseDashboardWidget # PENAMBAHAN: Use local api contract.
import threading
from flowork_gui.api_client.client import ApiClient
class DatasetManagerWidget(BaseDashboardWidget):
    """
    Provides a UI for managing fine-tuning datasets by communicating with the backend API.
    [UPGRADED] Now loads and displays existing data when a dataset is selected.
    """
    TIER = "pro"
    def __init__(self, parent, coordinator_tab, kernel, widget_id: str, refresh_callback=None):
        build_security.perform_runtime_check(__file__)
        build_security.perform_runtime_check(__file__)
        build_security.perform_runtime_check(__file__)
        super().__init__(parent, coordinator_tab, kernel, widget_id)
        self.api_client = ApiClient(kernel=self.kernel)
        self.dataset_var = ttk.StringVar()
        self.refresh_callback = refresh_callback
        self._build_ui()
    def on_widget_load(self):
        """Load datasets when the widget appears."""
        self._load_datasets()
    def _build_ui(self):
        self.columnconfigure(0, weight=1)
        selection_frame = ttk.Frame(self)
        selection_frame.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        selection_frame.columnconfigure(0, weight=1)
        self.dataset_combo = ttk.Combobox(selection_frame, textvariable=self.dataset_var, state="readonly")
        self.dataset_combo.grid(row=0, column=0, sticky="ew")
        self.dataset_combo.bind("<<ComboboxSelected>>", self._on_dataset_selected)
        button_toolbar = ttk.Frame(selection_frame)
        button_toolbar.grid(row=0, column=1, padx=(5,0))
        create_button = ttk.Button(button_toolbar, text="Create", command=self._create_new_dataset, bootstyle="outline-success", width=7) # English Hardcode
        create_button.pack(side="left")
        self.delete_button = ttk.Button(button_toolbar, text="Delete", command=self._delete_selected_dataset, bootstyle="outline-danger", width=7) # English Hardcode
        self.delete_button.pack(side="left", padx=(5,0))
        self.input_frame = ttk.LabelFrame(self, text="Add or Edit Data (prompt;response per line)") # English Hardcode
        self.input_frame.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)
        self.input_frame.rowconfigure(0, weight=1)
        self.input_frame.columnconfigure(0, weight=1)
        self.data_input_text = ScrolledText(self.input_frame, wrap="word", height=8)
        self.data_input_text.grid(row=0, column=0, sticky="nsew")
        self.save_button = ttk.Button(self, text="Save Data to Selected Dataset", command=self._save_data_to_dataset, bootstyle="primary") # English Hardcode
        self.save_button.grid(row=2, column=0, sticky="ew", padx=5, pady=5)
        self.rowconfigure(1, weight=1)
    def _load_datasets(self):
        self.dataset_combo['values'] = ["Loading..."] # English Hardcode
        self.dataset_var.set("Loading...") # English Hardcode
        threading.Thread(target=self._load_datasets_worker, daemon=True).start()
    def _load_datasets_worker(self):
        success, response = self.api_client.list_datasets()
        self.after(0, self._populate_dataset_combo, success, response)
    def _populate_dataset_combo(self, success, response):
        if success:
            dataset_names = [ds['name'] for ds in response]
            self.dataset_combo['values'] = sorted(dataset_names)
            if dataset_names:
                self.dataset_var.set(sorted(dataset_names)[0])
                self._on_dataset_selected()
            else:
                self.dataset_var.set("No datasets found. Please create one.") # English Hardcode
                self.data_input_text.config(state="normal")
                self.data_input_text.delete("1.0", "end")
                self.data_input_text.config(state="disabled")
        else:
            self.dataset_combo['values'] = ["Error loading datasets"] # English Hardcode
            self.dataset_var.set("Error loading datasets") # English Hardcode
    def _on_dataset_selected(self, event=None):
        selected_dataset = self.dataset_var.get()
        if not selected_dataset or "Loading" in selected_dataset or "Error" in selected_dataset or "No datasets" in selected_dataset:
            return
        self.data_input_text.config(state="normal")
        self.data_input_text.delete("1.0", "end")
        self.data_input_text.insert("1.0", f"Loading data for '{selected_dataset}'...") # English Hardcode
        self.data_input_text.config(state="disabled")
        threading.Thread(target=self._load_dataset_content_worker, args=(selected_dataset,), daemon=True).start()
    def _load_dataset_content_worker(self, dataset_name):
        success, data = self.api_client.get_dataset_data(dataset_name)
        self.after(0, self._populate_data_text_area, success, data, dataset_name)
    def _populate_data_text_area(self, success, data, dataset_name):
        self.data_input_text.config(state="normal")
        self.data_input_text.delete("1.0", "end")
        if success:
            formatted_text = ""
            for item in data:
                formatted_text += f"{item.get('prompt', '')};{item.get('response', '')}\n"
            self.data_input_text.insert("1.0", formatted_text)
            self.input_frame.config(text=f"Data for '{dataset_name}' ({len(data)} records)") # English Hardcode
        else:
            self.data_input_text.insert("1.0", f"Error loading data for '{dataset_name}'.") # English Hardcode
    def _create_new_dataset(self):
        new_name = simpledialog.askstring("Create Dataset", "Enter a name for the new dataset:", parent=self) # English Hardcode
        if new_name and new_name.strip():
            success, response = self.api_client.create_dataset(new_name.strip())
            if success:
                if self.refresh_callback:
                    self.refresh_callback()
            else:
                messagebox.showerror("Error", f"Failed to create dataset: {response}", parent=self) # English Hardcode
        else:
            pass
    def _delete_selected_dataset(self):
        selected_dataset = self.dataset_var.get()
        if not selected_dataset or "Loading" in selected_dataset or "Error" in selected_dataset or "No datasets" in selected_dataset:
            messagebox.showerror("Error", "Please select a valid dataset to delete.", parent=self) # English Hardcode
            return
        if messagebox.askyesno("Confirm Deletion", f"Are you sure you want to permanently delete the dataset '{selected_dataset}'?", parent=self): # English Hardcode
            self.delete_button.config(state="disabled", text="Deleting...") # English Hardcode
            threading.Thread(target=self._delete_dataset_worker, args=(selected_dataset,), daemon=True).start()
    def _delete_dataset_worker(self, dataset_name):
        success, response = self.api_client.delete_dataset(dataset_name)
        self.after(0, self._on_delete_complete, success, response, dataset_name)
    def _on_delete_complete(self, success, response, dataset_name):
        self.delete_button.config(state="normal", text="Delete") # English Hardcode
        if success:
            messagebox.showinfo("Success", f"Dataset '{dataset_name}' has been deleted.", parent=self) # English Hardcode
            if self.refresh_callback:
                self.refresh_callback()
        else:
            messagebox.showerror("Error", f"Failed to delete dataset: {response}", parent=self) # English Hardcode
    def _save_data_to_dataset(self):
        selected_dataset = self.dataset_var.get()
        data_to_add = self.data_input_text.get("1.0", "end-1c").strip()
        if not selected_dataset or "Loading" in selected_dataset or "Error" in selected_dataset or "No datasets" in selected_dataset:
            messagebox.showerror("Error", "Please select or create a valid dataset first.", parent=self) # English Hardcode
            return
        if not data_to_add:
            messagebox.showerror("Error", "The data input area is empty.", parent=self) # English Hardcode
            return
        parsed_data = []
        for i, line in enumerate(data_to_add.split('\n')):
            if not line.strip(): continue
            if ';' not in line:
                messagebox.showerror("Error", f"Invalid format on line {i+1}: '{line}'. Each line must be 'prompt;response'.", parent=self) # English Hardcode
                return
            prompt, response = line.split(';', 1)
            parsed_data.append({"prompt": prompt.strip(), "response": response.strip()})
        self.save_button.config(state="disabled", text="Saving...") # English Hardcode
        threading.Thread(target=self._save_data_worker, args=(selected_dataset, parsed_data), daemon=True).start()
    def _save_data_worker(self, dataset_name, data):
        success, response = self.api_client.add_data_to_dataset(dataset_name, data)
        self.after(0, self._on_save_data_complete, success, response, len(data), dataset_name)
    def _on_save_data_complete(self, success, response, count, dataset_name):
        self.save_button.config(state="normal", text="Save Data to Selected Dataset") # English Hardcode
        if success:
            messagebox.showinfo("Success", f"{count} records have been successfully saved to dataset '{dataset_name}'.", parent=self) # English Hardcode
            if self.refresh_callback:
                self.refresh_callback()
        else:
            messagebox.showerror("Error", f"Failed to save data: {response}", parent=self) # English Hardcode
_UNUSED_SIGNATURE = 'B3Ba%m#rDeKa' # Embedded Signature
_UNUSED_SIGNATURE = 'B3Ba%m#rDeKa' # Embedded Signature
_UNUSED_SIGNATURE = 'B3Ba%m#rDeKa' # Embedded Signature
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\dataset_manager_widget\manifest.json
# JUMLAH BARIS : 14
#######################################################################

```json
{
    "id": "dataset_manager_widget",
    "name": "Dataset Manager",
    "version": "1.0",
    "icon_file": "icon.png",
    "author": "AWENK AUDICO & Gemini",
    "email": "contributor@teetah.art",
    "website": "www.teetah.art",
    "description": "A widget to create, manage, and add data to fine-tuning datasets stored in the local database.",
    "type": "DASHBOARD_WIDGET",
    "entry_point": "dataset_manager_widget.DatasetManagerWidget",
    "tier": "pro",
    "is_system": true
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\dataset_manager_widget\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "aa5295f57a4605f51b71bc022f3747d773716073e85d69096620290e8841c359",
    "manifest_hash": "539e42d0799f947d5d16ceb5e513d15f7a2bd645f27b9318e5932ad25e67eed7",
    "timestamp": 1757204718.0049922
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\dataset_manager_widget\locales\en.json
# JUMLAH BARIS : 3
#######################################################################

```json
{
    "widget_name": "Dataset Manager"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\dataset_manager_widget\locales\id.json
# JUMLAH BARIS : 3
#######################################################################

```json
{
    "widget_name": "Manajer Dataset"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\data_canvas_widget\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "669b58d4354f4c985f6da9d60c983d789ceae69ca1bdece32b97c50fb969249e",
    "manifest_hash": "1d29523b9e89cb47651d276d6afcb6aedef4ac14fd34d45e8f0416483097b4ef",
    "timestamp": 1757229868.2862852
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\data_canvas_widget\data_canvas_widget.py
# JUMLAH BARIS : 83
#######################################################################

```py
from flowork_gui.core import build_security # PENAMBAHAN: Importing from the new local GUI path.
import ttkbootstrap as ttk
from tkinter import ttk as tk_ttk
import json
from flowork_gui.api_contract import BaseDashboardWidget # PENAMBAHAN: Use local api contract.
from flowork_gui.api_client.client import ApiClient
class DataCanvasWidget(BaseDashboardWidget):
    TIER = "basic"
    """
    The UI for the Data Canvas. It displays a version of the workflow focused
    on previewing the data output of each configured node in real-time.
    """
    def __init__(self, parent, coordinator_tab, kernel, widget_id: str):
        self.api_client = ApiClient(kernel=self.kernel)
        build_security.perform_runtime_check(__file__)
        build_security.perform_runtime_check(__file__)
        super().__init__(parent, coordinator_tab, kernel, widget_id)
        self.parent_tab = coordinator_tab
        self.data_node_widgets = {} # Stores the UI elements for each node on this canvas
        canvas_container = ttk.Frame(self)
        canvas_container.pack(fill='both', expand=True)
        self.canvas = ttk.Canvas(canvas_container)
        scrollbar = ttk.Scrollbar(canvas_container, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = ttk.Frame(self.canvas)
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(
                scrollregion=self.canvas.bbox("all")
            )
        )
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=scrollbar.set)
        self.canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
    def sync_with_logic_canvas(self, logic_canvas_nodes):
        """
        Receives the node data from the main logic canvas and rebuilds the
        Data Canvas UI based on it.
        """
        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()
        self.data_node_widgets.clear()
        if not logic_canvas_nodes:
            ttk.Label(self.scrollable_frame, text="Tambahkan node di Tampilan Logika untuk melihat preview data di sini.").pack(pady=50)
            return
        module_manager = self.kernel.get_service("module_manager_service")
        for node_id, node_data in logic_canvas_nodes.items():
            module_id = node_data.get('module_id')
            node_name = node_data.get('name', 'Unknown')
            node_frame = ttk.LabelFrame(self.scrollable_frame, text=f"{node_name} ({module_id})", padding=10)
            node_frame.pack(fill='x', expand=True, padx=10, pady=5)
            if True: # Placeholder
                try:
                    preview_data = [{"status": "preview_not_implemented_on_client"}]
                    if isinstance(preview_data, list) and preview_data and isinstance(preview_data[0], dict):
                        columns = list(preview_data[0].keys())
                        tree = tk_ttk.Treeview(node_frame, columns=columns, show="headings", height=min(len(preview_data), 5))
                        for col in columns:
                            tree.heading(col, text=col.replace("_", " ").title())
                            tree.column(col, width=120)
                        for item in preview_data:
                            tree.insert("", "end", values=[str(item.get(col, '')) for col in columns])
                        tree.pack(fill='both', expand=True)
                    else:
                        pretty_data = json.dumps(preview_data, indent=2, ensure_ascii=False)
                        text_area = ttk.Text(node_frame, height=5, wrap="word", font=("Consolas", 9))
                        text_area.insert("1.0", pretty_data)
                        text_area.config(state="disabled")
                        text_area.pack(fill='both', expand=True)
                except Exception as e:
                    ttk.Label(node_frame, text=f"Error generating preview: {e}", bootstyle="danger").pack()
            else:
                ttk.Label(node_frame, text=" (Modul ini tidak mendukung data preview) ", bootstyle="secondary").pack()
_UNUSED_SIGNATURE = 'B3Ba%m#rDeKa' # Embedded Signature
_UNUSED_SIGNATURE = 'B3Ba%m#rDeKa' # Embedded Signature
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\data_canvas_widget\manifest.json
# JUMLAH BARIS : 13
#######################################################################

```json
{
    "id": "data_canvas_widget",
    "name": "Kanvas Data (Data Canvas)",
    "version": "1.0",
    "icon_file": "icon.png",
    "author": "Flowork Vision Team",
    "email": "Contributor@teetah.art",
    "website": "www.teetah.art",
    "description": "Widget revolusioner untuk menampilkan preview data dari node secara live, memungkinkan debugging dan desain alur data yang interaktif.",
    "type": "DASHBOARD_WIDGET",
    "entry_point": "data_canvas_widget.DataCanvasWidget",
    "is_system": true
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\data_canvas_widget\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "669b58d4354f4c985f6da9d60c983d789ceae69ca1bdece32b97c50fb969249e",
    "manifest_hash": "1d29523b9e89cb47651d276d6afcb6aedef4ac14fd34d45e8f0416483097b4ef",
    "timestamp": 1757204723.1576657
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\logic_toolbox_widget\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "9ed979ad1495a0b4b9acc46b99c8a582e54803a578296a242e171dbe613d94c4",
    "manifest_hash": "07537caaae1466ef6259b06a7de134a042196161b8d620e00fc4ddb9c59a85c1",
    "timestamp": 1757229874.186353
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\logic_toolbox_widget\logic_toolbox_widget.py
# JUMLAH BARIS : 122
#######################################################################

```py
from flowork_gui.core import build_security
import ttkbootstrap as ttk
from tkinter import ttk as tk_ttk, StringVar, messagebox
from flowork_gui.api_contract import BaseDashboardWidget
from flowork_gui.views.custom_widgets.tooltip import ToolTip
from flowork_gui.utils.performance_logger import log_performance # PENAMBAHAN: Importing utility from its new local GUI path.
import threading
import time
from flowork_gui.api_client.client import ApiClient
class LogicToolboxWidget(BaseDashboardWidget):
    TIER = "free"
    """
    Widget to display the Logic and Control Flow Modules toolbox.
    """
    def __init__(self, parent, coordinator_tab, kernel, widget_id: str):
        build_security.perform_runtime_check(__file__)
        super().__init__(parent, coordinator_tab, kernel, widget_id)
        self.parent_tab = coordinator_tab
        self.api_client = ApiClient(kernel=self.kernel)
        self.search_var = StringVar()
        self.search_var.trace_add("write", self._on_search)
        self._debounce_job = None
        self._create_widgets()
        self.refresh_content()
    def on_widget_load(self):
        super().on_widget_load()
    def _create_widgets(self):
        search_frame = ttk.Frame(self)
        search_frame.pack(fill='x', padx=5, pady=5)
        search_frame.columnconfigure(1, weight=1)
        search_frame.columnconfigure(2, weight=0)
        search_icon_label = ttk.Label(search_frame, text="", font=("Font Awesome 6 Free Solid", 9))
        search_icon_label.grid(row=0, column=0, padx=(0, 5))
        search_entry = ttk.Entry(search_frame, textvariable=self.search_var)
        search_entry.grid(row=0, column=1, sticky="ew")
        ToolTip(search_entry).update_text("Type your goal (e.g., 'read a csv file') to search...") # English Hardcode
        reload_button = ttk.Button(search_frame, text="⟳", width=3, command=self._force_reload_and_refresh, style="secondary.TButton")
        reload_button.grid(row=0, column=2, padx=(5,0))
        ToolTip(reload_button).update_text("Reload component list") # English Hardcode
        ttk.Label(self, text=self.loc.get('logic_modules_title', fallback="Logic Modules")).pack(pady=5, anchor='w', padx=5)
        self.module_tree = tk_ttk.Treeview(self, columns=(), style="Custom.Treeview", selectmode="browse")
        self.module_tree.heading('#0', text=self.loc.get('module_name_column', fallback="Module Name"))
        self.module_tree.pack(expand=True, fill='both', side='top', padx=5, pady=(0,5))
        self.module_tree.bind("<ButtonPress-1>", self.on_drag_start)
        self.module_tree.bind("<B1-Motion>", self.parent_tab.on_drag_motion)
        self.module_tree.bind("<ButtonRelease-1>", self.parent_tab.on_drag_release)
    def _on_search(self, *args):
        if self._debounce_job:
            self.after_cancel(self._debounce_job)
        self._debounce_job = self.after(300, self.populate_module_toolbox)
    def _force_reload_and_refresh(self):
        for i in self.module_tree.get_children():
            self.module_tree.delete(i)
        self.module_tree.insert("", "end", text="  Reloading and Refreshing...", tags=("loading",)) # English Hardcode
        threading.Thread(target=self._load_data_worker, args=(True,), daemon=True).start()
    @log_performance("Fetching module list for LogicToolbox")
    def _load_data_worker(self, force_reload: bool = False):
        if force_reload:
            pass
            time.sleep(1)
        success, all_modules_data = self.api_client.get_components('modules')
        self.after(0, self.populate_module_toolbox, success, all_modules_data)
    def populate_module_toolbox(self, success=True, all_modules_data=None):
        if all_modules_data:
            for comp in all_modules_data:
                pass
        search_query = self.search_var.get().strip().lower()
        for i in self.module_tree.get_children():
            self.module_tree.delete(i)
        if all_modules_data is None:
            success, all_modules_data = self.api_client.get_components('modules')
        if not success:
            self.module_tree.insert('', 'end', text="  Error: Could not fetch modules...") # English Hardcode
            return
        logic_modules_data = [
            mod for mod in all_modules_data
            if mod.get('manifest', {}).get('type') in ['LOGIC', 'CONTROL_FLOW']
        ]
        modules_to_display = []
        if not search_query:
            for module_data in logic_modules_data:
                 modules_to_display.append((module_data['id'], module_data))
            sorted_modules = sorted(modules_to_display, key=lambda item: item[1].get('name', item[0]).lower())
        else:
            for module_data in logic_modules_data:
                search_haystack = f"{module_data.get('name','')} {module_data.get('description','')}".lower()
                if search_query in search_haystack:
                    modules_to_display.append((module_data['id'], module_data))
            sorted_modules = modules_to_display
        for module_id, module_data in sorted_modules:
            tier = module_data.get('tier', 'free').capitalize()
            display_name = module_data.get('name', 'Unknown')
            label = f" {display_name}"
            if tier.lower() != 'free':
                label += f" [{tier}]"
            is_sufficient = True # Placeholder
            tag = 'sufficient' if is_sufficient else 'insufficient'
            self.module_tree.insert('', 'end', iid=module_id, text=label, tags=(tag, tier.lower()))
        self.module_tree.tag_configure('insufficient', foreground='grey')
        self.update_idletasks()
    def on_drag_start(self, event):
        item_id = self.module_tree.identify_row(event.y)
        if not item_id or 'category' in self.module_tree.item(item_id, "tags"): return
        tags = self.module_tree.item(item_id, "tags")
        if 'insufficient' in tags:
            messagebox.showwarning(
                self.loc.get('license_popup_title'),
                self.loc.get('license_popup_message', module_name=self.module_tree.item(item_id, "text").strip()),
                parent=self.winfo_toplevel()
            )
            return
        self.parent_tab.on_drag_start(event)
    def refresh_content(self, event_data=None):
        threading.Thread(target=self._load_data_worker, args=(False,), daemon=True).start()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\logic_toolbox_widget\manifest.json
# JUMLAH BARIS : 13
#######################################################################

```json
{
    "id": "logic_toolbox",
    "name": "Toolbox Logika",
    "version": "1.0",
    "icon_file": "icon.png",
    "author": "Flowork Core",
    "email": "Contributor@teetah.art",
    "website": "www.teetah.art",
    "description": "Widget inti untuk menampilkan daftar Modul Logika yang dapat digunakan di kanvas.",
    "type": "DASHBOARD_WIDGET",
    "entry_point": "logic_toolbox_widget.LogicToolboxWidget",
    "is_system": true
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\logic_toolbox_widget\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "1f061ab38abe532edc75dba61c939eef96a2026c7574165c3baead1256f7e8e7",
    "manifest_hash": "07537caaae1466ef6259b06a7de134a042196161b8d620e00fc4ddb9c59a85c1",
    "timestamp": 1757204728.390862
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\log_viewer_widget\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "28816a4cc02d0216d1f03264e5317b7269a3aced804817ab0129faabc1fa904a",
    "manifest_hash": "70b82c366277f2925eccfcc2f47b086225201bdc97dc447b019922c94946113c",
    "timestamp": 1757229880.002439
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\log_viewer_widget\log_viewer_widget.py
# JUMLAH BARIS : 108
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import Text, ttk as tk_ttk
import datetime
from api_contract import BaseDashboardWidget # PENAMBAHAN OTOMATIS
from api_client.client import ApiClient # PENAMBAHAN OTOMATIS
class LogViewerWidget(BaseDashboardWidget):
    TIER = "free"  # ADDED BY SCANNER: Default tier
    """Widget mandiri untuk menampilkan, memfilter, dan mengelola log eksekusi."""
    def __init__(self, parent, coordinator_tab, kernel, widget_id: str):
        self.api_client = ApiClient(kernel=self.kernel)
        super().__init__(parent, coordinator_tab, kernel, widget_id)
        self._all_log_entries = []
        self._create_widgets()
        self.on_widget_load()
    def on_widget_load(self):
        """Dipanggil oleh DashboardManager saat widget berhasil dibuat dan ditampilkan."""
        super().on_widget_load()
        if hasattr(self.kernel, 'register_log_viewer'):
            self.kernel.register_log_viewer(self.coordinator_tab.tab_id, self)
    def on_widget_destroy(self):
        """Dipanggil oleh DashboardManager saat widget akan dihancurkan."""
        super().on_widget_destroy()
        if hasattr(self.kernel, 'unregister_log_viewer'):
            self.kernel.unregister_log_viewer(self.coordinator_tab.tab_id)
    def _create_widgets(self):
        ttk.Label(self, text=self.loc.get('execution_log_title'), style='TLabel').pack(pady=5, anchor='w', padx=5)
        log_filter_frame = ttk.Frame(self, style='TFrame')
        log_filter_frame.pack(fill='x', pady=(0, 5), padx=5)
        self.search_entry = ttk.Entry(log_filter_frame, style='Prop.TEntry')
        self.search_entry.pack(side='left', expand=True, fill='x', padx=(0, 5))
        self.search_entry.insert(0, self.loc.get('search_log_placeholder'))
        self.search_entry.bind("<KeyRelease>", self._filter_logs)
        self.filter_combobox = ttk.Combobox(log_filter_frame, values=[self.loc.get(k) for k in ['log_level_all', 'log_level_info', 'log_level_warn', 'log_level_error', 'log_level_success', 'log_level_debug', 'log_level_cmd', 'log_level_detail']], state="readonly")
        self.filter_combobox.set(self.loc.get('log_level_all'))
        self.filter_combobox.pack(side='left')
        self.filter_combobox.bind("<<ComboboxSelected>>", self._filter_logs)
        log_button_frame = ttk.Frame(self, style='TFrame')
        log_button_frame.pack(fill='x', side='bottom', pady=(5,5), padx=5)
        ttk.Button(log_button_frame, text=self.loc.get('copy_log_button'), command=self.copy_log_to_clipboard, style="info.TButton").pack(side='left', expand=True, fill='x', padx=(0, 2))
        ttk.Button(log_button_frame, text=self.loc.get('clear_log_button'), command=self.clear_log, style="success.TButton").pack(side='left', expand=True, fill='x')
        log_text_container = ttk.Frame(self, style='TFrame')
        log_text_container.pack(expand=True, fill='both', side='top', padx=5)
        self.log_text = Text(log_text_container, wrap='word', height=10, state='disabled')
        log_text_scroll = ttk.Scrollbar(log_text_container, command=self.log_text.yview)
        log_text_scroll.pack(side='right', fill='y')
        self.log_text.pack(side='left', expand=True, fill='both')
        self.log_text.config(yscrollcommand=log_text_scroll.set)
        theme_manager = self.kernel.get_service("theme_manager")
        colors = theme_manager.get_colors() if theme_manager else {}
        self.log_text.tag_config("INFO", foreground=colors.get('fg', 'white'))
        self.log_text.tag_config("SUCCESS", foreground=colors.get('success', '#76ff7b'))
        self.log_text.tag_config("WARN", foreground=colors.get('warning', '#ffb627'))
        self.log_text.tag_config("ERROR", foreground=colors.get('danger', '#ff686b'))
        self.log_text.tag_config("DEBUG", foreground=colors.get('info', '#8be9fd'))
        self.log_text.tag_config("CMD", foreground=colors.get('primary', '#007bff'))
        self.log_text.tag_config("DETAIL", foreground=colors.get('secondary', 'grey'))
    def copy_log_to_clipboard(self):
        self.clipboard_clear()
        self.clipboard_append(self.log_text.get('1.0', 'end'))
        self.kernel.write_to_log(self.loc.get('log_copied_to_clipboard'), "SUCCESS")
    def clear_log(self, feedback=True):
        self._all_log_entries = []
        self.log_text.config(state='normal')
        self.log_text.delete('1.0', 'end')
        self.log_text.config(state='disabled')
        if feedback:
            self.kernel.write_to_log(self.loc.get('log_cleared'), "WARN")
    def write_to_log(self, message, level="INFO"):
        try:
            timestamp = datetime.datetime.now().strftime("%H:%M:%S")
            tag = level.upper()
            entry = {"timestamp": timestamp, "message": message, "level": tag}
            self._all_log_entries.append(entry)
            self._filter_logs()
        except Exception as e:
            print(f"CRITICAL LOGGING ERROR: {e} - Message: {message}")
    def _filter_logs(self, event=None):
        search_term = self.search_entry.get().strip().lower()
        if search_term == self.loc.get('search_log_placeholder').lower():
            search_term = ""
        level_map = {
            self.loc.get('log_level_all').upper(): 'ALL',
            self.loc.get('log_level_info').upper(): 'INFO',
            self.loc.get('log_level_warn').upper(): 'WARN',
            self.loc.get('log_level_error').upper(): 'ERROR',
            self.loc.get('log_level_success').upper(): 'SUCCESS',
            self.loc.get('log_level_debug').upper(): 'DEBUG',
            self.loc.get('log_level_cmd').upper(): 'CMD',
            self.loc.get('log_level_detail').upper(): 'DETAIL'
        }
        selected_display_level = self.filter_combobox.get().strip().upper()
        internal_level = level_map.get(selected_display_level, 'ALL')
        self.log_text.config(state='normal')
        self.log_text.delete('1.0', 'end')
        for entry in self._all_log_entries:
            if (not search_term or search_term in entry["message"].lower()) and (internal_level == 'ALL' or entry["level"] == internal_level):
                self.log_text.insert('end', f"[{entry['timestamp']}] ", ("DETAIL",))
                self.log_text.insert('end', f"{entry['message']}\n", (entry['level'],))
        self.log_text.see('end')
        self.log_text.config(state='disabled')
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\log_viewer_widget\manifest.json
# JUMLAH BARIS : 13
#######################################################################

```json
{
    "id": "log_viewer",
    "name": "Log Eksekusi",
    "version": "1.0",
    "icon_file": "icon.png",
    "author": "Flowork Core",
    "email": "Contributor@teetah.art",
    "website": "www.teetah.art",
    "description": "Widget inti untuk menampilkan, memfilter, dan mengelola log eksekusi.",
    "type": "DASHBOARD_WIDGET",
    "entry_point": "log_viewer_widget.LogViewerWidget",
    "is_system": true
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\log_viewer_widget\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "28816a4cc02d0216d1f03264e5317b7269a3aced804817ab0129faabc1fa904a",
    "manifest_hash": "70b82c366277f2925eccfcc2f47b086225201bdc97dc447b019922c94946113c",
    "timestamp": 1757204733.3438733
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\plugin_toolbox_widget\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "fd8a869a8497276a0987545a620c32e432cd98daca13895f8fcc9f8525563e4e",
    "manifest_hash": "54e2868052a1523764c70e45ed2598d22d511a958389982c0a51872a896364cf",
    "timestamp": 1757229885.469301
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\plugin_toolbox_widget\manifest.json
# JUMLAH BARIS : 13
#######################################################################

```json
{
    "id": "plugin_toolbox",
    "name": "Toolbox Plugin",
    "version": "1.0",
    "icon_file": "icon.png",
    "author": "Flowork Core",
    "email": "Contributor@teetah.art",
    "website": "www.teetah.art",
    "description": "Widget inti untuk menampilkan daftar Plugin Aksi yang dapat digunakan di kanvas.",
    "type": "DASHBOARD_WIDGET",
    "entry_point": "plugin_toolbox_widget.PluginToolboxWidget",
    "is_system": true
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\plugin_toolbox_widget\plugin_toolbox_widget.py
# JUMLAH BARIS : 131
#######################################################################

```py
from flowork_gui.core import build_security
import ttkbootstrap as ttk
from tkinter import ttk as tk_ttk, StringVar, messagebox
from flowork_gui.api_contract import BaseDashboardWidget
from flowork_gui.views.custom_widgets.tooltip import ToolTip
from flowork_gui.utils.performance_logger import log_performance # PENAMBAHAN: Importing utility from its new local GUI path.
import threading
import time
from flowork_gui.api_client.client import ApiClient
class PluginToolboxWidget(BaseDashboardWidget):
    TIER = "free"
    """
    Widget to display the Action and Plugin toolbox.
    (FIXED V2) Correctly fetches and filters both ACTION modules and PLUGIN components.
    """
    def __init__(self, parent, coordinator_tab, kernel, widget_id: str):
        build_security.perform_runtime_check(__file__)
        super().__init__(parent, coordinator_tab, kernel, widget_id)
        self.parent_tab = coordinator_tab
        self.api_client = ApiClient(kernel=self.kernel)
        self.search_var = StringVar()
        self.search_var.trace_add("write", self._on_search)
        self._debounce_job = None
        self._create_widgets()
        self.refresh_content()
    def on_widget_load(self):
        super().on_widget_load()
    def _create_widgets(self):
        search_frame = ttk.Frame(self)
        search_frame.pack(fill='x', padx=5, pady=5)
        search_frame.columnconfigure(1, weight=1)
        search_frame.columnconfigure(2, weight=0)
        search_icon_label = ttk.Label(search_frame, text="", font=("Font Awesome 6 Free Solid", 9))
        search_icon_label.grid(row=0, column=0, padx=(0, 5))
        search_entry = ttk.Entry(search_frame, textvariable=self.search_var)
        search_entry.grid(row=0, column=1, sticky="ew")
        ToolTip(search_entry).update_text("Type to search plugins...") # English Hardcode
        reload_button = ttk.Button(search_frame, text="⟳", width=3, command=self._force_reload_and_refresh, style="secondary.TButton")
        reload_button.grid(row=0, column=2, padx=(5,0))
        ToolTip(reload_button).update_text("Reload component list") # English Hardcode
        ttk.Label(self, text=self.loc.get('action_plugins_title', fallback="Action & Plugin Toolbox"), style='TLabel').pack(pady=5, anchor='w', padx=5)
        self.plugin_tree = tk_ttk.Treeview(self, columns=(), style="Custom.Treeview", selectmode="browse")
        self.plugin_tree.heading('#0', text=self.loc.get('plugin_name_column', fallback="Plugin Name"))
        self.plugin_tree.pack(expand=True, fill='both', side='top', padx=5, pady=(0,5))
        self.plugin_tree.bind("<ButtonPress-1>", self.on_drag_start)
        self.plugin_tree.bind("<B1-Motion>", self.parent_tab.on_drag_motion)
        self.plugin_tree.bind("<ButtonRelease-1>", self.parent_tab.on_drag_release)
    def _on_search(self, *args):
        if self._debounce_job:
            self.after_cancel(self._debounce_job)
        self._debounce_job = self.after(300, self.populate_plugin_panel)
    def _force_reload_and_refresh(self):
        for i in self.plugin_tree.get_children():
            self.plugin_tree.delete(i)
        self.plugin_tree.insert("", "end", text="  Reloading and Refreshing...", tags=("loading",)) # English Hardcode
        threading.Thread(target=self._load_data_worker, args=(True,), daemon=True).start()
    @log_performance("Fetching data for PluginToolbox")
    def _load_data_worker(self, force_reload: bool = False):
        if force_reload:
            pass
            time.sleep(1)
        success_modules, modules_data = self.api_client.get_components('modules')
        success_plugins, plugins_data = self.api_client.get_components('plugins')
        combined_data = []
        if success_modules:
            combined_data.extend(modules_data)
        if success_plugins:
            combined_data.extend(plugins_data)
        self.after(0, self.populate_plugin_panel, True, combined_data)
    def populate_plugin_panel(self, success=True, all_components_data=None):
        if all_components_data:
            for comp in all_components_data:
                pass
        search_query = self.search_var.get().strip().lower()
        for i in self.plugin_tree.get_children():
            self.plugin_tree.delete(i)
        if all_components_data is None:
            threading.Thread(target=self._load_data_worker, daemon=True).start()
            return
        if not success:
            self.plugin_tree.insert('', 'end', text="  Error: Could not fetch components...") # English Hardcode
            return
        filtered_components = [
            comp for comp in all_components_data
            if comp.get('manifest', {}).get('type') in ['ACTION', 'PLUGIN']
        ]
        components_to_display = []
        if not search_query:
            for data in filtered_components:
                 components_to_display.append((data['id'], data))
            sorted_components = sorted(components_to_display, key=lambda item: item[1].get('name', item[0]).lower())
        else:
            for data in filtered_components:
                search_haystack = f"{data.get('name','')} {data.get('description','')}".lower()
                if search_query in search_haystack:
                    components_to_display.append((data['id'], data))
            sorted_components = components_to_display
        for comp_id, comp_data in sorted_components:
            tier = comp_data.get('tier', 'free').capitalize()
            display_name = comp_data.get('name', 'Unknown')
            label = f" {display_name}"
            if tier.lower() != 'free':
                label += f" [{tier}]"
            is_sufficient = True # Placeholder
            tag = 'sufficient' if is_sufficient else 'insufficient'
            self.plugin_tree.insert('', 'end', iid=comp_id, text=label, tags=(tag, tier.lower()))
        self.plugin_tree.tag_configure('insufficient', foreground='grey')
        self.update_idletasks()
    def on_drag_start(self, event):
        item_id = self.plugin_tree.identify_row(event.y)
        if not item_id or 'category' in self.plugin_tree.item(item_id, "tags"): return
        tags = self.plugin_tree.item(item_id, "tags")
        if 'insufficient' in tags:
            messagebox.showwarning(
                self.loc.get('license_popup_title'),
                self.loc.get('license_popup_message', module_name=self.plugin_tree.item(item_id, "text").strip()),
                parent=self.winfo_toplevel()
            )
            return
        self.parent_tab.on_drag_start(event)
    def refresh_content(self, event_data=None):
        """Called to refresh the widget list if there are changes."""
        threading.Thread(target=self._load_data_worker, args=(False,), daemon=True).start()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\plugin_toolbox_widget\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "0893ce75e56ccf4a05cd53dd5d6706daab56dfc1a42637a3ebdac79b03672d5c",
    "manifest_hash": "54e2868052a1523764c70e45ed2598d22d511a958389982c0a51872a896364cf",
    "timestamp": 1757204738.3627892
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\prompt_sender_widget\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "fd61097f6a5021058836515662f4a8bd38737b175435a81d61582916cf77acdd",
    "manifest_hash": "777b01b8093629eb525adfa589f88cea40a70f94bcd59382d46e3ae508d907c9",
    "timestamp": 1757229891.1520545
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\prompt_sender_widget\manifest.json
# JUMLAH BARIS : 14
#######################################################################

```json
{
    "id": "prompt_sender_widget",
    "name": "Prompt Sender",
    "version": "1.0",
    "icon_file": "icon.png",
    "author": "AWENK AUDICO",
    "email": "sahidinaola@gmail.com",
    "website": "www.teetah.art",
    "description": "A dashboard widget to send a text prompt to a specific receiver module in a workflow.",
    "type": "DASHBOARD_WIDGET",
    "entry_point": "prompt_sender_widget.PromptSenderWidget",
    "tier": "free",
    "is_system": false
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\prompt_sender_widget\prompt_sender_widget.py
# JUMLAH BARIS : 57
#######################################################################

```py
from flowork_gui.core import build_security # PENAMBAHAN: Importing from the new local GUI path.
import ttkbootstrap as ttk
from tkinter import StringVar, scrolledtext, messagebox
from flowork_gui.api_contract import BaseDashboardWidget # PENAMBAHAN: Use local api contract.
from flowork_gui.api_client.client import ApiClient
class PromptSenderWidget(BaseDashboardWidget):
    """
    A UI widget to send a text prompt to a specific 'Prompt Receiver' node on the canvas.
    """
    def __init__(self, parent, coordinator_tab, kernel, widget_id: str, **kwargs):
        self.api_client = ApiClient(kernel=self.kernel)
        build_security.perform_runtime_check(__file__)
        super().__init__(parent, coordinator_tab, kernel, widget_id, **kwargs)
        main_frame = ttk.Frame(self, padding=10)
        main_frame.pack(fill="both", expand=True)
        self.target_node_id_var = StringVar(value="receiver-node-1")
        id_frame = ttk.Frame(main_frame)
        id_frame.pack(fill="x", pady=(0, 5))
        ttk.Label(id_frame, text=self.loc.get('prompt_sender_target_id_label', fallback="Target Node ID:")).pack(side="left")
        id_entry = ttk.Entry(id_frame, textvariable=self.target_node_id_var)
        id_entry.pack(side="left", fill="x", expand=True, padx=(5, 0))
        self.prompt_text = scrolledtext.ScrolledText(main_frame, height=4, wrap="word", font=("Segoe UI", 10))
        self.prompt_text.pack(fill="both", expand=True, pady=(0, 5))
        send_button = ttk.Button(
            main_frame,
            text=self.loc.get('prompt_sender_send_button', fallback="Send Prompt"),
            command=self._send_prompt,
            bootstyle="primary"
        )
        send_button.pack(fill="x")
    def _send_prompt(self):
        target_node_id = self.target_node_id_var.get().strip()
        prompt_content = self.prompt_text.get("1.0", "end-1c").strip()
        if not target_node_id or not prompt_content:
            messagebox.showwarning(
                self.loc.get('prompt_sender_warning_title', fallback="Input Required"),
                self.loc.get('prompt_sender_warning_message', fallback="Please provide both a target node ID and a prompt.")
            )
            return
        event_bus = self.kernel.get_service("event_bus")
        if event_bus:
            event_name = f"PROMPT_FROM_WIDGET_{target_node_id}"
            event_data = {
                "prompt": prompt_content,
                "sender_widget_id": self.widget_id
            }
            event_bus.publish(event_name, event_data, publisher_id=self.widget_id)
            self.prompt_text.delete("1.0", "end")
_UNUSED_SIGNATURE = 'B3Ba%m#rDeKa' # Embedded Signature
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\prompt_sender_widget\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "fd61097f6a5021058836515662f4a8bd38737b175435a81d61582916cf77acdd",
    "manifest_hash": "777b01b8093629eb525adfa589f88cea40a70f94bcd59382d46e3ae508d907c9",
    "timestamp": 1757204743.4341307
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\prompt_sender_widget\locales\en.json
# JUMLAH BARIS : 1
#######################################################################

```json
{}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\prompt_sender_widget\locales\id.json
# JUMLAH BARIS : 1
#######################################################################

```json
{}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\widget_toolbox\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "593d67d62fb0b109e46154cdd9ff873f70c5c4580314e4ece062391e8584ca17",
    "manifest_hash": "97009c7841ddad5a9db5176fe1eeb8964942a83fe006ecb291704064e0cd75dc",
    "timestamp": 1757229896.1188555
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\widget_toolbox\manifest.json
# JUMLAH BARIS : 13
#######################################################################

```json
{
    "id": "widget_toolbox",
    "name": "Toolbox Widget",
    "version": "1.0",
    "icon_file": "icon.png",
    "author": "Flowork Core",
    "email": "Contributor@teetah.art",
    "website": "www.teetah.art",
    "description": "Widget inti yang menampilkan semua widget lain yang tersedia untuk ditambahkan ke dashboard.",
    "type": "DASHBOARD_WIDGET",
    "entry_point": "widget_toolbox_widget.WidgetToolboxWidget",
    "is_system": true
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\widget_toolbox\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "593d67d62fb0b109e46154cdd9ff873f70c5c4580314e4ece062391e8584ca17",
    "manifest_hash": "97009c7841ddad5a9db5176fe1eeb8964942a83fe006ecb291704064e0cd75dc",
    "timestamp": 1757204747.8596358
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_gui\widgets\widget_toolbox\widget_toolbox_widget.py
# JUMLAH BARIS : 112
#######################################################################

```py
from flowork_gui.core import build_security # PENAMBAHAN: Importing from the new local GUI path.
import ttkbootstrap as ttk
from tkinter import ttk as tk_ttk
from flowork_gui.api_contract import BaseDashboardWidget # PENAMBAHAN: Use local api contract.
from flowork_gui.views.custom_widgets.tooltip import ToolTip
from tkinter import StringVar
import threading
import time # (ADDED) Import time for delay after reload
from flowork_gui.api_client.client import ApiClient
def log_performance(log_message: str):
    def decorator(func):
        def wrapper(*args, **kwargs):
            start_time = time.perf_counter()
            result = func(*args, **kwargs)
            end_time = time.perf_counter()
            duration_ms = (end_time - start_time) * 1000
            print(f"PERF-GUI: {log_message} - Execution Time: {duration_ms:.2f} ms") # English Log
            return result
        return wrapper
    return decorator
class WidgetToolboxWidget(BaseDashboardWidget):
    TIER = "free"
    """
    Widget to display the toolbox of available widgets.
    (MODIFIED) Refresh button now triggers a full system hot-reload.
    """
    def __init__(self, parent, coordinator_tab, kernel, widget_id: str):
        build_security.perform_runtime_check(__file__)
        super().__init__(parent, coordinator_tab, kernel, widget_id)
        self.coordinator_tab = coordinator_tab
        self.api_client = ApiClient(kernel=self.kernel)
        self.search_var = StringVar()
        self.search_var.trace_add("write", self._on_search)
        self._create_widgets()
        self.refresh_content()
    def on_widget_load(self):
        """Called by DashboardManager when the widget is fully loaded."""
        super().on_widget_load()
    def _create_widgets(self):
        self.columnconfigure(0, weight=1)
        self.rowconfigure(2, weight=1)
        search_frame = ttk.Frame(self)
        search_frame.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        search_frame.columnconfigure(1, weight=1)
        search_frame.columnconfigure(2, weight=0)
        search_icon_label = ttk.Label(search_frame, text="", font=("Font Awesome 6 Free Solid", 9))
        search_icon_label.grid(row=0, column=0, padx=(0, 5))
        search_entry = ttk.Entry(search_frame, textvariable=self.search_var)
        search_entry.grid(row=0, column=1, sticky="ew")
        ToolTip(search_entry).update_text("Type to search widgets...") # English Hardcode
        reload_button = ttk.Button(search_frame, text="⟳", width=3, command=self._force_reload_and_refresh, style="secondary.TButton")
        reload_button.grid(row=0, column=2, padx=(5,0))
        ToolTip(reload_button).update_text("Reload component list") # English Hardcode
        ttk.Label(self, text=self.loc.get('available_widgets_header', fallback="Available Widgets")).grid(row=1, column=0, sticky='w', padx=5, pady=(5,0))
        self.widget_tree = tk_ttk.Treeview(self, show="tree", selectmode="browse")
        self.widget_tree.grid(row=2, column=0, sticky='nsew', padx=5, pady=5)
        self.widget_tree.bind("<Double-1>", self._on_widget_select)
    def _on_search(self, *args):
        self.populate_widget_toolbox()
    def _force_reload_and_refresh(self):
        for i in self.widget_tree.get_children():
            self.widget_tree.delete(i)
        self.widget_tree.insert("", "end", text="  Reloading and Refreshing...", tags=("loading",)) # English Hardcode
        threading.Thread(target=self._load_data_worker, args=(True,), daemon=True).start()
    @log_performance("Fetching widget list for WidgetToolbox")
    def _load_data_worker(self, force_reload: bool = False):
        if force_reload:
            self.api_client.trigger_hot_reload()
            time.sleep(1)
        success, all_widgets_data = self.api_client.get_components('widgets')
        self.after(0, self.populate_widget_toolbox, success, all_widgets_data)
    def populate_widget_toolbox(self, success=True, all_widgets_data=None):
        filter_text = self.search_var.get().lower()
        for item in self.widget_tree.get_children():
            self.widget_tree.delete(item)
        if all_widgets_data is None:
             success, all_widgets_data = self.api_client.get_components('widgets')
        if not success:
            self.widget_tree.insert("", "end", text="  Error: Could not fetch widgets...") # English Hardcode
            return
        widgets_to_display = []
        if not filter_text:
            for widget_data in all_widgets_data:
                 widgets_to_display.append((widget_data['id'], widget_data.get('name', widget_data['id'])))
            sorted_widgets = sorted(widgets_to_display, key=lambda item: item[1].lower())
        else:
            for widget_data in all_widgets_data:
                search_haystack = f"{widget_data.get('name','')} {widget_data.get('description','')}".lower()
                if filter_text in search_haystack:
                    widgets_to_display.append((widget_data['id'], widget_data.get('name', widget_data['id'])))
            sorted_widgets = widgets_to_display
        for key, title in sorted_widgets:
            self.widget_tree.insert("", "end", iid=key, text=title)
        self.update_idletasks()
    def _on_widget_select(self, event):
        item_id = self.widget_tree.focus()
        if item_id:
            dashboard_manager = self.coordinator_tab.dashboard_manager
            if dashboard_manager:
                dashboard_manager.add_widget_and_save(item_id, event.x, event.y)
    def refresh_content(self, event_data=None):
        """Called to refresh the widget list if there are changes."""
        threading.Thread(target=self._load_data_worker, args=(False,), daemon=True).start()
_UNUSED_SIGNATURE = 'B3Ba%m#rDeKa' # Embedded Signature
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\api_client.py
# JUMLAH BARIS : 597
#######################################################################

```py
import requests
import json
import os
import threading
import time
import random
from flowork_kernel.kernel import Kernel
class ApiClient:
    """
    (REFACTORED V3) A client to interact with local and remote APIs.
    This version corrects the endpoint mapping to ensure each method calls the correct API route.
    """
    def __init__(self, base_url="http://localhost:8989/api/v1", kernel=None):
        self.local_base_url = base_url
        self.kernel = kernel or Kernel.instance
        self.cache = {}
        self.cache_lock = threading.Lock()
        self.marketplace_repo_owner = "FLOWORK-gif"
        self.marketplace_repo_name = "addon"
        self.marketplace_branch = "main"
    def _get_variable(self, var_name):
        if self.kernel:
            variable_manager = self.kernel.get_service("variable_manager_service")
            if variable_manager:
                return variable_manager.get_variable(var_name)
        return None
    def _get_supabase_url(self):
        url = self._get_variable("SUPABASE_URL")
        if not url:
            raise ValueError("Supabase URL is not configured in Variable Manager.")
        return url
    def _get_supabase_key(self):
        key = self._get_variable("SUPABASE_KEY")
        if not key:
            raise ValueError("Supabase Anon Key is not configured in Variable Manager.")
        return key
    def _get_local_auth_headers(self):
        headers = {}
        api_key = self._get_variable("FLOWORK_API_KEY")
        if api_key:
            headers['X-API-Key'] = api_key
        return headers
    def _get_supabase_headers(self, auth_token=None):
        """Gets auth headers for Supabase. Includes Bearer token if provided."""
        headers = {
            'apikey': self._get_supabase_key(),
            'Content-Type': 'application/json'
        }
        if auth_token:
            headers['Authorization'] = f'Bearer {auth_token}'
        return headers
    def _handle_response(self, response):
        if 200 <= response.status_code < 300:
            if response.status_code == 204 or not response.content:
                return True, {}
            return True, response.json()
        else:
            try:
                error_data = response.json()
                message = error_data.get("detail") or error_data.get("message") or error_data.get("msg") or error_data.get("error_description") or error_data.get("error", "Unknown API error")
            except json.JSONDecodeError:
                message = response.text
            return False, message
    def register_user(self, username, email, password):
        try:
            headers = self._get_supabase_headers()
            url = f"{self._get_supabase_url()}/auth/v1/signup"
            payload = {
                "email": email,
                "password": password,
                "data": { "username": username }
            }
            response = requests.post(url, headers=headers, json=payload, timeout=15)
            return self._handle_response(response)
        except (requests.exceptions.RequestException, ValueError) as e:
            return False, f"Connection/Configuration error: {e}" # English Hardcode
    def forgot_password(self, email: str):
        try:
            headers = self._get_supabase_headers()
            url = f"{self._get_supabase_url()}/functions/v1/forgot-password"
            payload = {"email": email}
            response = requests.post(url, headers=headers, json=payload, timeout=15)
            return self._handle_response(response)
        except (requests.exceptions.RequestException, ValueError) as e:
            return False, f"Connection/Configuration error: {e}" # English Hardcode
    def login_user(self, email, password):
        try:
            auth_headers = self._get_supabase_headers()
            supabase_url = self._get_supabase_url()
            auth_url = f"{supabase_url}/auth/v1/token?grant_type=password"
            auth_payload = {"email": email, "password": password}
            auth_response = requests.post(auth_url, headers=auth_headers, json=auth_payload, timeout=15)
            auth_success, auth_data = self._handle_response(auth_response)
            if not auth_success:
                return False, auth_data
            access_token = auth_data.get('access_token')
            user_id = auth_data.get('user', {}).get('id')
            if not access_token or not user_id:
                return False, "Login succeeded but received invalid data from server." # English Hardcode
            profile_headers = self._get_supabase_headers(auth_token=access_token)
            profile_url = f"{supabase_url}/rest/v1/users?id=eq.{user_id}&select=tier,username"
            profile_response = requests.get(profile_url, headers=profile_headers, timeout=10)
            profile_success, profile_data = self._handle_response(profile_response)
            if not profile_success:
                return False, f"Could not fetch user profile. Server said: {profile_data}" # English Hardcode
            if not isinstance(profile_data, list) or not profile_data:
                 return False, "Could not fetch user profile after login." # English Hardcode
            user_profile = profile_data[0]
            final_response = {
                "message": "Login successful.", # English Hardcode
                "session_token": access_token,
                "user_id": user_id,
                "email": email,
                "username": user_profile.get('username', ''),
                "tier": user_profile.get('tier', 'free')
            }
            return True, final_response
        except (requests.exceptions.RequestException, ValueError) as e:
            return False, f"Connection/Configuration error: {e}" # English Hardcode
    def get_user_profile_by_token(self, session_token: str):
        try:
            auth_headers = self._get_supabase_headers(auth_token=session_token)
            supabase_url = self._get_supabase_url()
            user_url = f"{supabase_url}/auth/v1/user"
            user_response = requests.get(user_url, headers=auth_headers, timeout=10)
            user_success, user_data = self._handle_response(user_response)
            if not user_success:
                return False, user_data
            user_id = user_data.get('id')
            email = user_data.get('email')
            if not user_id:
                return False, "Token is valid but did not return a user ID." # English Hardcode
            profile_headers = self._get_supabase_headers(auth_token=session_token)
            profile_url = f"{supabase_url}/rest/v1/users?id=eq.{user_id}&select=tier,username,license_expires_at"
            profile_response = requests.get(profile_url, headers=profile_headers, timeout=10)
            profile_success, profile_data = self._handle_response(profile_response)
            if not profile_success:
                return False, f"Could not fetch user profile. Server said: {profile_data}" # English Hardcode
            if not isinstance(profile_data, list) or not profile_data:
                 return False, "Could not fetch user profile after validating token." # English Hardcode
            user_profile = profile_data[0]
            final_response = {
                "message": "Auto-login successful.", # English Hardcode
                "session_token": session_token,
                "user_id": user_id,
                "email": email,
                "username": user_profile.get('username', ''),
                "tier": user_profile.get('tier', 'free'),
                "license_expires_at": user_profile.get('license_expires_at')
            }
            return True, final_response
        except (requests.exceptions.RequestException, ValueError) as e:
            return False, f"Connection/Configuration error: {e}" # English Hardcode
    def validate_license_activation(self, license_key: str, machine_id: str):
        try:
            payload = {"license_key": license_key, "machine_id": machine_id}
            response = requests.post(f"{self.local_base_url}/license/validate", json=payload, headers=self._get_local_auth_headers(), timeout=20)
            return self._handle_response(response)
        except requests.exceptions.RequestException as e:
            return False, f"Connection to local API server failed during validation: {e}" # English Hardcode
    def activate_license(self, license_content: dict):
        try:
            payload = {"license_content": license_content}
            response = requests.post(f"{self.local_base_url}/license/activate", json=payload, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.RequestException as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def deactivate_license(self):
        try:
            response = requests.post(f"{self.local_base_url}/license/deactivate", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.RequestException as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def restart_application(self):
        try:
            response = requests.post(f"{self.local_base_url}/system/actions/restart", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.RequestException as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_all_settings(self):
        try:
            response = requests.get(f"{self.local_base_url}/settings", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def save_settings(self, settings_data: dict):
        try:
            response = requests.patch(f"{self.local_base_url}/settings", json=settings_data, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def list_datasets(self):
        try:
            response = requests.get(f"{self.local_base_url}/datasets", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_dataset_data(self, dataset_name: str):
        try:
            response = requests.get(f"{self.local_base_url}/datasets/{dataset_name}/data", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def create_dataset(self, name: str):
        try:
            payload = {"name": name}
            response = requests.post(f"{self.local_base_url}/datasets", json=payload, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def add_data_to_dataset(self, dataset_name: str, data_list: list):
        try:
            payload = {"data": data_list}
            response = requests.post(f"{self.local_base_url}/datasets/{dataset_name}/data", json=payload, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def start_training_job(self, base_model_id, dataset_name, new_model_name, training_args):
        try:
            payload = {
                "base_model_id": base_model_id,
                "dataset_name": dataset_name,
                "new_model_name": new_model_name,
                "training_args": training_args
            }
            response = requests.post(f"{self.local_base_url}/training/start", json=payload, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_training_job_status(self, job_id: str):
        try:
            response = requests.get(f"{self.local_base_url}/training/status/{job_id}", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def start_model_conversion(self, source_model_folder: str, output_gguf_name: str, quantize_method: str):
        try:
            payload = {
                "source_model_folder": source_model_folder,
                "output_gguf_name": output_gguf_name,
                "quantize_method": quantize_method
            }
            response = requests.post(f"{self.local_base_url}/models/convert", json=payload, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def start_model_requantize(self, source_gguf_path: str, output_gguf_name: str, quantize_method: str):
        try:
            payload = {
                "source_gguf_path": source_gguf_path,
                "output_gguf_name": output_gguf_name,
                "quantize_method": quantize_method
            }
            response = requests.post(f"{self.local_base_url}/models/requantize", json=payload, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_conversion_status(self, job_id: str):
        try:
            response = requests.get(f"{self.local_base_url}/models/convert/status/{job_id}", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_agents(self):
        try:
            response = requests.get(f"{self.local_base_url}/agents", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def save_agent(self, agent_data: dict):
        try:
            response = requests.post(f"{self.local_base_url}/agents", json=agent_data, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def delete_agent(self, agent_id: str):
        try:
            response = requests.delete(f"{self.local_base_url}/agents/{agent_id}", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def run_agent(self, agent_id: str, objective: str):
        try:
            payload = {"objective": objective}
            response = requests.post(f"{self.local_base_url}/agents/{agent_id}/run", json=payload, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_agent_run_status(self, run_id: str):
        try:
            response = requests.get(f"{self.local_base_url}/agents/run/{run_id}", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def stop_agent_run(self, run_id: str):
        try:
            response = requests.post(f"{self.local_base_url}/agents/run/{run_id}/stop", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_marketplace_ads(self):
        cache_key = "marketplace_ads"
        with self.cache_lock:
            if cache_key in self.cache:
                cached_data, timestamp = self.cache[cache_key]
                if time.time() - timestamp < 86400:
                    return True, cached_data
        url = f"https://raw.githubusercontent.com/{self.marketplace_repo_owner}/{self.marketplace_repo_name}/{self.marketplace_branch}/ads.json"
        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            all_ads = response.json()
            selected_ads = random.sample(all_ads, min(6, len(all_ads)))
            with self.cache_lock:
                self.cache[cache_key] = (selected_ads, time.time())
            return True, selected_ads
        except requests.exceptions.RequestException as e:
            return False, f"Network error fetching ads: {e}" # English Hardcode
        except (json.JSONDecodeError, ValueError):
            return False, "Failed to parse ads.json." # English Hardcode
    def get_marketplace_index(self, component_type: str):
        cache_key = f"marketplace_index_{component_type}"
        with self.cache_lock:
            if cache_key in self.cache:
                cached_data, timestamp = self.cache[cache_key]
                if time.time() - timestamp < 86400: # Cache for 1 day
                    return True, cached_data
        folder_map = {
            "modules": "modules", "plugins": "plugins", "widgets": "widgets", "presets": "presets",
            "triggers": "triggers", "ai_providers": "ai_providers", "ai_models": "ai_models"
        }
        folder_name = folder_map.get(component_type)
        if not folder_name: return False, f"Unknown component type for marketplace: {component_type}" # English Hardcode
        url = f"https://raw.githubusercontent.com/{self.marketplace_repo_owner}/{self.marketplace_repo_name}/{self.marketplace_branch}/{folder_name}/index.json"
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 404: return True, []
            response.raise_for_status()
            data = response.json()
            with self.cache_lock:
                self.cache[cache_key] = (data, time.time())
            return True, data
        except requests.exceptions.RequestException as e:
            return False, f"Network error fetching marketplace index: {e}" # English Hardcode
        except json.JSONDecodeError:
            return False, f"Failed to parse marketplace index.json for {component_type}." # English Hardcode
    def trigger_hot_reload(self):
        try:
            response = requests.post(f"{self.local_base_url}/system/actions/hot_reload", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_presets(self):
        try:
            response = requests.get(f"{self.local_base_url}/presets", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_preset_data(self, preset_name):
        try:
            response = requests.get(f"{self.local_base_url}/presets/{preset_name}", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def save_preset(self, preset_name, workflow_data):
        try:
            payload = {"name": preset_name, "workflow_data": workflow_data}
            response = requests.post(f"{self.local_base_url}/presets", json=payload, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def delete_preset(self, preset_name):
        try:
            response = requests.delete(f"{self.local_base_url}/presets/{preset_name}", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_preset_versions(self, preset_name: str):
        try:
            response = requests.get(f"{self.local_base_url}/presets/{preset_name}/versions", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def load_preset_version(self, preset_name: str, version_filename: str):
        try:
            response = requests.get(f"{self.local_base_url}/presets/{preset_name}/versions/{version_filename}", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def delete_preset_version(self, preset_name: str, version_filename: str):
        try:
            response = requests.delete(f"{self.local_base_url}/presets/{preset_name}/versions/{version_filename}", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_variables(self):
        try:
            response = requests.get(f"{self.local_base_url}/variables", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def update_variable(self, name, value, is_secret, is_enabled=True, mode=None):
        try:
            payload = {"value": value, "is_secret": is_secret, "is_enabled": is_enabled}
            if mode: payload["mode"] = mode
            response = requests.put(f"{self.local_base_url}/variables/{name}", json=payload, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def update_variable_state(self, name: str, is_enabled: bool):
        try:
            payload = {"enabled": is_enabled}
            response = requests.patch(f"{self.local_base_url}/variables/{name}/state", json=payload, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def delete_variable(self, name):
        try:
            response = requests.delete(f"{self.local_base_url}/variables/{name}", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_components(self, component_type: str, component_id: str = None):
        try:
            url = f"{self.local_base_url}/{component_type}"
            if component_id: url += f"/{component_id}"
            response = requests.get(url, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def install_component(self, component_type: str, zip_filepath: str):
        try:
            with open(zip_filepath, 'rb') as f:
                headers = self._get_local_auth_headers()
                files = {'file': (os.path.basename(zip_filepath), f, 'application/zip')}
                response = requests.post(f"{self.local_base_url}/{component_type}/install", files=files, headers=headers)
            return self._handle_response(response)
        except FileNotFoundError:
            return False, f"Local file not found: {zip_filepath}" # English Hardcode
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def delete_component(self, component_type: str, component_id: str):
        try:
            response = requests.delete(f"{self.local_base_url}/{component_type}/{component_id}", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def update_component_state(self, component_type: str, component_id: str, is_paused: bool):
        try:
            payload = {"paused": is_paused}
            response = requests.patch(f"{self.local_base_url}/{component_type}/{component_id}", json=payload, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_dashboard_layout(self, tab_id: str):
        try:
            response = requests.get(f"{self.local_base_url}/uistate/dashboards/{tab_id}", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def save_dashboard_layout(self, tab_id: str, layout_data: dict):
        try:
            response = requests.post(f"{self.local_base_url}/uistate/dashboards/{tab_id}", json=layout_data, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_tab_session(self):
        try:
            response = requests.get(f"{self.local_base_url}/uistate/session/tabs", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def save_tab_session(self, tabs_data: list):
        try:
            response = requests.post(f"{self.local_base_url}/uistate/session/tabs", json=tabs_data, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def open_managed_tab(self, tab_key: str):
        try:
            payload = {"tab_key": tab_key}
            response = requests.post(f"{self.local_base_url}/ui/actions/open_tab", json=payload, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def upload_component(self, comp_type: str, component_id: str, description: str, tier: str):
        try:
            payload = {
                "comp_type": comp_type,
                "component_id": component_id,
                "description": description,
                "tier": tier
            }
            response = requests.post(f"{self.local_base_url}/addons/upload", json=payload, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def upload_model(self, model_path: str, description: str, tier: str):
        try:
            form_data = {
                "description": description,
                "tier": tier,
                "model_id": os.path.basename(model_path).replace('.gguf', '')
            }
            with open(model_path, 'rb') as f:
                files = {'file': (os.path.basename(model_path), f, 'application/octet-stream')}
                response = requests.post(
                    f"{self.local_base_url}/models/upload",
                    data=form_data,
                    files=files,
                    headers=self._get_local_auth_headers()
                )
            return self._handle_response(response)
        except FileNotFoundError:
            return False, f"Local model file not found: {model_path}" # English Hardcode
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_prompts(self):
        try:
            response = requests.get(f"{self.local_base_url}/prompts", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_prompt(self, prompt_id: str):
        try:
            response = requests.get(f"{self.local_base_url}/prompts/{prompt_id}", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def create_prompt(self, prompt_data: dict):
        try:
            response = requests.post(f"{self.local_base_url}/prompts", json=prompt_data, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def update_prompt(self, prompt_id: str, prompt_data: dict):
        try:
            response = requests.put(f"{self.local_base_url}/prompts/{prompt_id}", json=prompt_data, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def delete_prompt(self, prompt_id: str):
        try:
            response = requests.delete(f"{self.local_base_url}/prompts/{prompt_id}", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def delete_dataset(self, name: str):
        try:
            response = requests.delete(f"{self.local_base_url}/datasets/{name}", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.ConnectionError as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_trigger_rules(self):
        try:
            response = requests.get(f"{self.local_base_url}/triggers/rules", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.RequestException as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def get_trigger_definitions(self):
        try:
            response = requests.get(f"{self.local_base_url}/triggers/definitions", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.RequestException as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def create_trigger_rule(self, rule_data: dict):
        try:
            response = requests.post(f"{self.local_base_url}/triggers/rules", json=rule_data, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.RequestException as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def update_trigger_rule(self, rule_id: str, rule_data: dict):
        try:
            response = requests.put(f"{self.local_base_url}/triggers/rules/{rule_id}", json=rule_data, headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.RequestException as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def delete_trigger_rule(self, rule_id: str):
        try:
            response = requests.delete(f"{self.local_base_url}/triggers/rules/{rule_id}", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.RequestException as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
    def reload_triggers(self):
        try:
            response = requests.post(f"{self.local_base_url}/triggers/actions/reload", headers=self._get_local_auth_headers())
            return self._handle_response(response)
        except requests.exceptions.RequestException as e:
            return False, f"Connection to API server failed: {e}" # English Hardcode
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\api_contract.py
# JUMLAH BARIS : 358
#######################################################################

```py
from typing import List, Dict, Any, Callable, Tuple
from tkinter import StringVar, ttk
from abc import ABC, abstractmethod
class BaseBrainProvider(ABC):
    """
    The abstract base class (contract) that all AI Brain Providers for the Agent Host must implement.
    A brain is responsible for the core Observe-Think-Act loop.
    """
    def __init__(self, module_id: str, services: dict):
        self.kernel = services.get("kernel")
        self.loc = services.get("loc")
        self.logger = services.get("logger", print)
        self.module_id = module_id
        self.manifest = {}
        module_manager = self.kernel.get_service("module_manager_service") if self.kernel else None
        if module_manager:
            manifest_data = module_manager.get_manifest(self.module_id)
            if manifest_data:
                self.manifest = manifest_data
    @abstractmethod
    def get_provider_name(self) -> str:
        """
        Returns the display name of the brain provider.
        """
        raise NotImplementedError
    @abstractmethod
    def is_ready(self) -> tuple[bool, str]:
        """
        Checks if the provider is properly configured and ready to think.
        Returns a tuple of (is_ready: bool, message: str).
        """
        raise NotImplementedError
    @abstractmethod
    def think(self, objective: str, tools_string: str, history: list, last_observation: str) -> dict:
        """
        Takes the current state of the agent and returns a JSON object with 'thought' and 'action'.
        This is the core of the agent's decision-making process.
        """
        raise NotImplementedError
    def get_manifest(self) -> dict:
        """
        Returns the manifest data for this provider.
        """
        return self.manifest
class BaseAIProvider(ABC):
    """
    The abstract base class (contract) that all AI Providers must implement.
    [UPGRADED] Now holds its own manifest data.
    [UPGRADED V2] Now includes a standard readiness check method.
    """
    def __init__(self, kernel, manifest: dict):
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        self.manifest = manifest
    @abstractmethod
    def get_provider_name(self) -> str:
        """
        Returns the display name of the provider.
        """
        raise NotImplementedError
    @abstractmethod
    def generate_response(self, prompt: str) -> dict:
        """
        Processes a prompt and returns a standardized dictionary.
        """
        raise NotImplementedError
    @abstractmethod
    def is_ready(self) -> tuple[bool, str]:
        """
        Checks if the provider is properly configured and ready to accept requests.
        Returns a tuple of (is_ready: bool, message: str).
        """
        raise NotImplementedError
    def get_manifest(self) -> dict:
        """
        Returns the manifest data for this provider.
        """
        return self.manifest
class IDataPreviewer(ABC):
    """
    An optional interface for modules that can provide a real-time preview
    of their potential output data based on their current configuration.
    This is the foundation for the "Data Canvas" feature.
    """
    @abstractmethod
    def get_data_preview(self, config: Dict[str, Any]) -> Any:
        """
        Executes a limited, sample version of the module's logic to return a data preview.
        This method MUST NOT have side effects and should return quickly.
        Args:
            config: The current configuration values from the properties UI.
        Returns:
            A sample of the data the module would produce (e.g., a list of dicts, a string).
        """
        raise NotImplementedError
class IDynamicOutputSchema(ABC):
    """
    An interface for modules whose output data schema can change dynamically
    based on their current configuration.
    """
    @abstractmethod
    def get_dynamic_output_schema(self, current_config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Returns a list of output schema dictionaries based on the node's config.
        Example: [{'name': 'data.user_name', 'type': 'string', 'description': '...'}]
        """
        raise NotImplementedError
class IExecutable(ABC):
    """Interface for modules that can be executed in a workflow."""
    @abstractmethod
    def execute(self, payload: Dict, config: Dict, status_updater: Callable, ui_callback: Callable, mode: str = 'EXECUTE', **kwargs): # (ADDED) **kwargs to support special modules like Agent Host
        raise NotImplementedError
class IConfigurableUI(ABC):
    """Interface for modules that provide a custom properties UI."""
    @abstractmethod
    def create_properties_ui(self, parent_frame, get_current_config, available_vars):
        raise NotImplementedError
class IDynamicPorts(ABC):
    """Interface for modules whose output ports can change dynamically."""
    @abstractmethod
    def get_dynamic_ports(self, current_config):
        raise NotImplementedError
class BaseModule:
    """
    Kelas dasar yang harus di-inherit oleh semua prosesor modul.
    Versi ini diperluas untuk mendukung Arsitektur Modul Mandiri.
    """
    def __init__(self, module_id: str, services: Dict[str, Any]):
        """
        Konstruktor baru yang menerima layanan yang dibutuhkan secara eksplisit.
        (FIXED) Now correctly assigns all injected services to self.
        """
        self.module_id = module_id
        for service_name, service_instance in services.items():
            setattr(self, service_name, service_instance)
        self.manifest = {}
        if hasattr(self, 'module_manager_service') and self.module_manager_service:
            manifest_data = self.module_manager_service.get_manifest(self.module_id)
            if manifest_data:
                self.manifest = manifest_data
        if not hasattr(self, 'loc'):
            self.loc = services.get("loc")
        if not hasattr(self, 'logger'):
            self.logger = services.get("logger", print) # Fallback to print if not provided
    def on_install(self):
        """Called once when the module is first installed or discovered."""
        pass
    def on_load(self):
        """Called when the module is loaded or enabled."""
        pass
    def on_canvas_load(self, node_id: str):
        """
        Called by the CanvasManager right after a node instance is visually
        created on the canvas, providing it with its unique instance ID.
        """
        pass
    def on_unload(self):
        """Called when the module is unloaded or disabled."""
        pass
    def validate(self, config: Dict[str, Any], connected_input_ports: List[str]) -> Tuple[bool, str]:
        """
        Memvalidasi konfigurasi node saat ini.
        Metode ini harus di-override oleh modul turunan jika memerlukan validasi khusus.
        """
        return (True, "")
    def pause_workflow(self):
        workflow_executor = getattr(self, 'workflow_executor_service', None)
        if workflow_executor:
            workflow_executor.pause_execution()
        else:
            if self.loc:
                self.logger(self.loc.get('api_contract_err_executor_not_requested', fallback="Error: The 'workflow_executor_service' was not requested by this module."), "ERROR")
            else:
                self.logger("Error: The 'workflow_executor_service' was not requested by this module.", "ERROR")
    def resume_workflow(self):
        workflow_executor = getattr(self, 'workflow_executor_service', None)
        if workflow_executor:
            workflow_executor.resume_execution()
        else:
            if self.loc:
                self.logger(self.loc.get('api_contract_err_executor_not_requested', fallback="Error: The 'workflow_executor_service' was not requested by this module."), "ERROR")
            else:
                self.logger("Error: The 'workflow_executor_service' was not requested by this module.", "ERROR")
    def request_manual_approval(self, message: str, callback: Callable[[str], None]):
        if hasattr(self, 'kernel'):
            self.kernel.display_approval_popup(self.module_id, message, callback)
        else:
            if self.loc:
                self.logger(self.loc.get('api_contract_err_kernel_not_requested', fallback="Error: The 'kernel' service was not requested, cannot display popup."), "ERROR")
            else:
                self.logger("Error: The 'kernel' service was not requested, cannot display popup.", "ERROR")
    def publish_event(self, event_name: str, event_data: Dict[str, Any]):
        event_bus = getattr(self, 'event_bus', None)
        if event_bus:
            event_bus.publish(event_name, event_data, publisher_id=self.module_id)
        else:
            if self.loc:
                self.logger(self.loc.get('api_contract_err_eventbus_not_requested', eventName=event_name, fallback=f"Error: The 'event_bus' service was not requested, cannot publish event '{event_name}'."), "ERROR")
            else:
                self.logger(f"Error: The 'event_bus' service was not requested, cannot publish event '{event_name}'.", "ERROR")
class BaseUIProvider:
    """
    Antarmuka (interface) yang harus diimplementasikan oleh modul
    yang ingin menyediakan komponen UI kustom ke aplikasi utama.
    """
    def get_ui_tabs(self) -> List[Dict[str, Any]]:
        return []
    def get_menu_items(self) -> List[Dict[str, Any]]:
        return []
class BaseDashboardWidget(ttk.Frame):
    """
    Kelas dasar yang harus di-inherit oleh semua widget dashboard kustom.
    Menyediakan kerangka kerja dasar dan akses ke kernel.
    """
    def __init__(self, parent, coordinator_tab, kernel, widget_id: str, **kwargs):
        super().__init__(parent, **kwargs)
        self.parent = parent
        self.coordinator_tab = coordinator_tab
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        self.widget_id = widget_id
    def on_widget_load(self):
        pass
    def on_widget_destroy(self):
        pass
    def refresh_content(self):
        pass
    def get_widget_state(self) -> dict:
        """
        Called by the DashboardManager when saving the layout.
        Widgets should override this to return a dictionary of their savable state.
        """
        return {}
    def load_widget_state(self, state: dict):
        """
        Called by the DashboardManager after a widget is created and a saved state is available.
        Widgets should override this to restore their state from the dictionary.
        """
        pass
class LoopConfig:
    """
    Struktur data untuk mendefinisikan konfigurasi looping pada sebuah step.
    Ini akan digunakan dalam properti modul atau sebagai bagian dari data node.
    """
    LOOP_TYPE_COUNT = "count"
    LOOP_TYPE_CONDITION = "condition"
    def __init__(self, loop_type: str = LOOP_TYPE_COUNT, iterations: int = 1, condition_var: str = None, condition_op: str = None, condition_val: Any = None,
                 enable_sleep: bool = False, sleep_type: str = "static", static_duration: int = 1, random_min: int = 1, random_max: int = 5):
        if loop_type not in [self.LOOP_TYPE_COUNT, self.LOOP_TYPE_CONDITION]:
            raise ValueError(f"Tipe loop tidak valid: {loop_type}. Harus '{self.LOOP_TYPE_COUNT}' atau '{self.LOOP_TYPE_CONDITION}'.")
        self.loop_type = loop_type
        self.iterations = iterations
        self.condition_var = condition_var
        self.condition_op = condition_op
        self.condition_val = condition_val
        self.enable_sleep = enable_sleep
        self.sleep_type = sleep_type
        self.static_duration = static_duration
        self.random_min = random_min
        self.random_max = random_max
    def to_dict(self) -> Dict[str, Any]:
        """Mengubah objek LoopConfig menjadi dictionary."""
        return {
            "loop_type": self.loop_type,
            "iterations": self.iterations,
            "condition_var": self.condition_var,
            "condition_op": self.condition_op,
            "condition_val": self.condition_val,
            "enable_sleep": self.enable_sleep,
            "sleep_type": self.sleep_type,
            "static_duration": self.static_duration,
            "random_min": self.random_min,
            "random_max": self.random_max
        }
    @staticmethod
    def from_dict(data: Dict[str, Any]):
        """Membuat objek LoopConfig dari dictionary."""
        return LoopConfig(
            loop_type=data.get("loop_type", LoopConfig.LOOP_TYPE_COUNT),
            iterations=data.get("iterations", 1),
            condition_var=data.get("condition_var"),
            condition_op=data.get("condition_op"),
            condition_val=data.get("condition_val"),
            enable_sleep=data.get("enable_sleep", False),
            sleep_type=data.get("sleep_type", "static"),
            static_duration=data.get("static_duration", 1),
            random_min=data.get("random_min", 1),
            random_max=data.get("random_max", 5)
        )
class EnumVarWrapper:
    """
    Wrapper untuk StringVar yang menangani konversi antara label UI (yang dilokalisasi)
    dan nilai internal (value) untuk properti bertipe enum.
    """
    def __init__(self, string_var: StringVar, label_to_value_map: Dict[str, str], value_to_label_map: Dict[str, str]):
        self.sv = string_var
        self.label_to_value_map = label_to_value_map
        self.value_to_label_map = value_to_label_map
    def get(self):
        """Mengembalikan nilai internal (value) yang sebenarnya."""
        return self.label_to_value_map.get(self.sv.get(), self.sv.get())
    def set(self, value):
        """Mengatur StringVar berdasarkan nilai internal (value) yang diberikan."""
        self.sv.set(self.value_to_label_map.get(value, value))
    def trace_add(self, mode, callback):
        """Meneruskan panggilan trace ke StringVar yang mendasarinya."""
        self.sv.trace_add(mode, callback)
class BaseTriggerListener:
    """
    Kelas dasar (kontrak) untuk semua modul Pemicu (Trigger).
    Setiap pemicu yang ingin mendengarkan kejadian sistem (file, proses, waktu, dll.)
    wajib mewarisi kelas ini.
    """
    def __init__(self, trigger_id: str, config: Dict[str, Any], services: Dict[str, Any], **kwargs):
        """
        Konstruktor dibuat lebih fleksibel dengan **kwargs.
        Ini akan mencegah crash jika 'rule_id' tidak dilemparkan,
        dan kita bisa memberikan peringatan yang lebih jelas.
        """
        self.trigger_id = trigger_id
        self.config = config
        self._callback = None
        self.is_running = False
        self.rule_id = kwargs.get('rule_id')
        for service_name, service_instance in services.items():
            setattr(self, service_name, service_instance)
        self.logger = getattr(self, 'logger', print)
        self.loc = getattr(self, 'loc', None) or getattr(self, 'kernel', None) and self.kernel.get_service("localization_manager")
        if not self.rule_id:
            if self.loc:
                self.logger(self.loc.get('api_contract_warn_trigger_no_ruleid', triggerId=self.trigger_id, fallback=f"CRITICAL WARNING FOR TRIGGER '{self.trigger_id}': Listener was created without a rule_id. This trigger will be unable to run a workflow."), "ERROR")
            else:
                self.logger(f"CRITICAL WARNING FOR TRIGGER '{self.trigger_id}': Listener created without rule_id. It will not be able to run a workflow.", "ERROR")
    def set_callback(self, callback: Callable[[Dict[str, Any]], None]):
        self._callback = callback
    def start(self):
        raise NotImplementedError("Setiap Pemicu harus mengimplementasikan metode 'start'.")
    def stop(self):
        raise NotImplementedError("Setiap Pemicu harus mengimplementasikan metode 'stop'.")
    def _on_event(self, event_data: Dict[str, Any]):
        if self._callback and callable(self._callback):
            try:
                if self.rule_id:
                    event_data['rule_id'] = self.rule_id
                    self.logger(f"Trigger '{self.trigger_id}' detected an event: {event_data}", "DEBUG") # English Log
                    self._callback(event_data)
                else:
                    self.logger(f"Trigger '{self.trigger_id}' detected an event, but it was cancelled because it has no rule_id.", "WARN") # English Log
            except Exception as e:
                self.logger(f"Error during callback execution for trigger '{self.trigger_id}': {e}", "ERROR")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\exceptions.py
# JUMLAH BARIS : 38
#######################################################################

```py
"""
Central repository for all custom Flowork exceptions.
This allows for specific error handling and clearer debugging.
"""
class FloworkException(Exception):
    """Base exception for all custom errors in the application."""
    pass
class PresetNotFoundError(FloworkException):
    """Raised when a specified workflow preset cannot be found."""
    pass
class ModuleValidationError(FloworkException):
    """Raised when a module's property validation fails."""
    pass
class ApiKeyMissingError(FloworkException):
    """Raised when a required API key is not found in the Variable Manager."""
    pass
class DependencyError(FloworkException):
    """Raised when installing a module's requirements.txt fails."""
    pass
class SignatureVerificationError(FloworkException):
    """Raised when a digital signature from an online resource is invalid."""
    pass
class MandatoryUpdateRequiredError(FloworkException):
    """Raised by the StartupService when a mandatory update is detected."""
    def __init__(self, message, update_info=None):
        super().__init__(message)
        self.update_info = update_info or {}
class PermissionDeniedError(FloworkException):
    """Raised when an action is attempted without the required license tier or permission."""
    pass
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\kernel.py
# JUMLAH BARIS : 15
#######################################################################

```py
try:
    from .kernel_logic import *
except ImportError as e:
    print("FATAL KERNEL ERROR: Could not load the compiled kernel logic (kernel_logic.kernel).") # English log
    print(f"Ensure you have run the build_engine.py script. Details: {e}") # English log
    import sys
    sys.exit(1)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\kernel_logic.py
# JUMLAH BARIS : 459
#######################################################################

```py
import os
import sys
import json
import time
import logging
import threading
import queue
import webbrowser
import importlib
import datetime
from typing import List, Dict, Any, Callable
import requests
from packaging import version
from flowork_kernel.exceptions import PermissionDeniedError
class ServiceWorkflowProxy:
    def __init__(self, kernel, service_id, preset_path):
        self.kernel = kernel
        self.service_id = service_id
        self.preset_path = preset_path
        self.workflow_data = None
        self.nodes = {}
        self.connections = {}
        self._load_workflow_definition()
    def _load_workflow_definition(self):
        try:
            if not os.path.exists(self.preset_path):
                raise FileNotFoundError(f"Service preset file not found: {self.preset_path}")
            with open(self.preset_path, 'r', encoding='utf-8') as f:
                self.workflow_data = json.load(f)
            self.nodes = {node['id']: node for node in self.workflow_data.get('nodes', [])}
            self.connections = {conn['id']: conn for conn in self.workflow_data.get('connections', [])}
            self.kernel.write_to_log(f"Service workflow definition for '{self.service_id}' loaded successfully.", "SUCCESS")
        except Exception as e:
            self.kernel.write_to_log(f"CRITICAL: Failed to load service workflow for '{self.service_id}': {e}", "ERROR")
            self.workflow_data = None
    def reload_definition(self):
        """Public method to manually trigger a reload of the workflow definition."""
        self.kernel.write_to_log(f"Proxy '{self.service_id}': Hot reload triggered.", "WARN") # English Log
        self._load_workflow_definition()
    def __getattr__(self, name):
        def method(*args, **kwargs):
            self.kernel.write_to_log(f"Proxy '{self.service_id}': Method '{name}' called. Executing corresponding workflow...", "INFO")
            if not self.workflow_data:
                self.kernel.write_to_log(f"Cannot execute '{name}' for service '{self.service_id}', workflow definition failed to load.", "ERROR")
                return None
            start_node_id = None
            sanitized_name = name.replace(' ', '_')
            for node_id, node_data in self.nodes.items():
                if node_data.get('name', '').strip().replace(' ', '_') == sanitized_name:
                    start_node_id = node_id
                    break
            if not start_node_id:
                self.kernel.write_to_log(f"No start node named '{name}' found in workflow for service '{self.service_id}'.", "ERROR")
                return None
            context_id = f"service_call_{self.service_id}_{name}_{time.time()}"
            executor = self.kernel.get_service("workflow_executor_service")
            if not executor:
                self.kernel.write_to_log(f"WorkflowExecutorService not available to run service '{self.service_id}'.", "CRITICAL")
                return None
            initial_payload = {"data": { "args": args, "kwargs": kwargs }, "history": []}
            execution_result = executor.execute_workflow_synchronous(
                self.nodes, self.connections, initial_payload, logger=self.kernel.write_to_log,
                status_updater=lambda a,b,c: None, highlighter=lambda a,b: None,
                ui_callback=lambda func, *a: func(*a), workflow_context_id=context_id, mode='EXECUTE',
                job_status_updater=None, start_node_id=start_node_id
            )
            if isinstance(execution_result, dict) and "payload" in execution_result:
                return execution_result["payload"]
            else:
                return execution_result
        return method
class Kernel:
    instance = None
    APP_VERSION = "1.0.0"
    license_tier: str = "free"
    is_premium: bool = False
    DEV_MODE_PUBLIC_KEY = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAysqZG2+F82W0TgLHmF3Y
0GRPEZvXvmndTY84N/wA1ljt+JxMBVsmcVTkv8f1TrmFRD19IDzl2Yzb2lgqEbEy
GFxHhudC28leDsVEIp8B+oYWVm8Mh242YKYK8r5DAvr9CPQivnIjZ4BWgKKddMTd
harVxLF2CoSoTs00xWKd6VlXfoW9wdBvoDVifL+hCMepgLLdQQE4HbamPDJ3bpra
pCgcAD5urmVoJEUJdjd+Iic27RBK7jD1dWDO2MASMh/0IyXyM8i7RDymQ88gZier
U0OdWzeCWGyl4EquvR8lj5GNz4vg2f+oEY7h9AIC1f4ARtoihc+apSntqz7nAqa/
sQIDAQAB
-----END PUBLIC KEY-----"""
    TIER_HIERARCHY = {
        "free": 0,
        "basic": 1,
        "pro": 2,
        "architect": 3,
        "enterprise": 4
    }
    SERVICE_CAPABILITY_MAP = {
        "ai_provider_manager_service": "ai_provider_access",
        "ai_architect_service": "ai_architect",
        "ai_training_service": "ai_local_models",
        "model_converter_service": "ai_local_models",
        "agent_manager_service": "ai_architect",
        "agent_executor_service": "ai_architect",
        "screen_recorder_service": "screen_recorder"
    }
    MODULE_CAPABILITY_MAP = {
        "advanced_web_scraper_module_1a2b": "web_scraping_advanced",
        "stable_diffusion_xl_module": "ai_local_models",
        "stable_video_diffusion_module_c4d3": "ai_local_models",
        "sentiment_analysis_module": "ai_local_models",
        "text_to_speech_module": "ai_local_models",
        "ai_center_module": "ai_provider_access",
        "prompt_engineer_module_a1b2": "ai_provider_access",
        "nuitka_compiler_module_b4a1": "core_compiler",
        "core_compiler_module": "core_compiler",
        "sub_workflow_module": "preset_versioning"
    }
    class FileSystemProxy:
        def __init__(self, kernel):
            self.kernel = kernel
            self.os_module = os
            self.shutil_module = __import__('shutil')
        def _check_permission(self, caller_module_id: str, required_permission: str):
            if not caller_module_id: return
            module_manager = self.kernel.get_service("module_manager_service")
            if not module_manager: raise PermissionDeniedError("Cannot verify permissions: ModuleManagerService is not available.")
            permissions = module_manager.get_module_permissions(caller_module_id)
            if required_permission not in permissions and "file_system:all" not in permissions:
                raise PermissionDeniedError(f"Module '{caller_module_id}' does not have the required permission: '{required_permission}'")
        def read(self, file_path, mode='r', encoding='utf-8', caller_module_id: str = None):
            self._check_permission(caller_module_id, "file_system:read")
            with open(file_path, mode, encoding=encoding) as f:
                return f.read()
        def write(self, file_path, data, mode='w', encoding='utf-8', caller_module_id: str = None):
            self._check_permission(caller_module_id, "file_system:write")
            with open(file_path, mode, encoding=encoding) as f:
                f.write(data)
        def exists(self, path, caller_module_id: str = None):
            self._check_permission(caller_module_id, "file_system:read")
            return self.os_module.path.exists(path)
        def remove(self, path, caller_module_id: str = None):
            self._check_permission(caller_module_id, "file_system:write")
            return self.os_module.remove(path)
        def rmtree(self, path, caller_module_id: str = None):
            self._check_permission(caller_module_id, "file_system:write")
            return self.shutil_module.rmtree(path)
    class NetworkProxy:
        def __init__(self, kernel):
            self.kernel = kernel
            self.requests_module = requests
        def _check_permission(self, caller_module_id: str, required_permission: str):
            if not caller_module_id: return
            module_manager = self.kernel.get_service("module_manager_service")
            if not module_manager: raise PermissionDeniedError("Cannot verify permissions: ModuleManagerService is not available.")
            permissions = module_manager.get_module_permissions(caller_module_id)
            if required_permission not in permissions and "network:all" not in permissions:
                 raise PermissionDeniedError(f"Module '{caller_module_id}' does not have the required permission: '{required_permission}'")
        def get(self, url, caller_module_id: str = None, **kwargs):
            self._check_permission(caller_module_id, "network:get")
            return self.requests_module.get(url, **kwargs)
        def post(self, url, caller_module_id: str = None, **kwargs):
            self._check_permission(caller_module_id, "network:post")
            return self.requests_module.post(url, **kwargs)
    def __init__(self, project_root_path: str):
        Kernel.instance = self
        self.project_root_path = project_root_path
        self.is_dev_mode = self._validate_dev_mode()
        if self.is_dev_mode:
            self._log_dev_mode_on_init = True
        else:
            self._log_dev_mode_on_init = False
        self.services: Dict[str, Any] = {}
        self.root = None
        self.startup_complete = False
        self.current_user = None
        self.data_path = os.path.join(self.project_root_path, "data")
        self.logs_path = os.path.join(self.project_root_path, "logs")
        self.modules_path = os.path.join(self.project_root_path, "modules")
        self.plugins_path = os.path.join(self.project_root_path, "plugins")
        self.system_plugins_path = os.path.join(self.project_root_path, "system_plugins")
        self.widgets_path = os.path.join(self.project_root_path, "widgets")
        self.themes_path = os.path.join(self.project_root_path, "themes")
        self.triggers_path = os.path.join(self.project_root_path, "triggers")
        self.locales_path = os.path.join(self.project_root_path, "locales")
        self.ai_providers_path = os.path.join(self.project_root_path, "ai_providers")
        self.formatters_path = os.path.join(self.project_root_path, "formatters")
        os.makedirs(self.data_path, exist_ok=True)
        os.makedirs(self.logs_path, exist_ok=True)
        self.log_queue = queue.Queue()
        self.cmd_log_queue = queue.Queue()
        self.log_viewer_references = {}
        self.file_system = self.FileSystemProxy(self)
        self.network = self.NetworkProxy(self)
        self._setup_file_logger()
        if self._log_dev_mode_on_init:
            self.write_to_log("Kernel booted in secure DEVELOPMENT MODE.", "WARN") # English Log
        self._load_services_from_manifest()
    def _validate_dev_mode(self) -> bool:
        """
        Checks for the existence of devmode.on and verifies its content.
        Returns True only if the file exists and contains the correct public key.
        """
        dev_mode_file = os.path.join(self.project_root_path, "devmode.on")
        if not os.path.exists(dev_mode_file):
            return False
        try:
            with open(dev_mode_file, 'r', encoding='utf-8') as f:
                content = f.read().strip()
            if content == self.DEV_MODE_PUBLIC_KEY.strip():
                return True
            else:
                self._log_dev_mode_on_init = True
                print("[KERNEL-WARN] devmode.on file found, but its content is invalid. DEV MODE WILL NOT ACTIVATE.") # English Log
                return False
        except Exception:
            print("[KERNEL-ERROR] Could not read devmode.on file. DEV MODE WILL NOT ACTIVATE.") # English Log
            return False
    @property
    def ai_manager(self):
        return self.get_service("ai_provider_manager_service")
    @property
    def loc(self):
        """ (ADDED) Provides a safe, official public accessor for the LocalizationManager. """
        return self.get_service("localization_manager")
    @property
    def event_bus(self):
        """ (ADDED) Provides a safe, official public accessor for the EventBus. """
        return self.get_service("event_bus")
    def register_ui_service(self, service_id: str, instance: object):
        if service_id in self.services:
            self.write_to_log(f"Service '{service_id}' is being overwritten by a UI-bound instance.", "WARN")
        self.services[service_id] = instance
        self.write_to_log(f"UI-bound service '{service_id}' registered successfully.", "SUCCESS")
    def _log_queue_worker(self):
        while True:
            try:
                log_record = self.log_queue.get()
                if not self.log_viewer_references:
                    print(f"[{log_record['level']}] (No Logger) {log_record['message']}")
                    self.log_queue.task_done()
                    continue
                for tab_id, log_viewer in list(self.log_viewer_references.items()):
                    if self.root and hasattr(self.root, 'after'):
                        self.root.after(0, lambda lv=log_viewer, lr=log_record: lv.write_to_log(lr['message'], lr['level']))
                self.log_queue.task_done()
            except Exception as e:
                print(f"[LOG WORKER ERROR] {e}")
                time.sleep(1)
    def _load_services_from_manifest(self):
        manifest_path = os.path.join(os.path.dirname(__file__), 'services.json')
        self.write_to_log(f"Kernel: Loading services from manifest: {manifest_path}", "INFO")
        try:
            with open(manifest_path, 'r', encoding='utf-8') as f:
                services_manifest = json.load(f)
            service_order = [
                "integrity_checker_service",
                "license_manager_service",
                "event_bus",
                "localization_manager",
                "state_manager",
                "permission_manager_service",
                "variable_manager",
                "preset_manager_service",
                "tab_manager_service"
            ]
            all_services = services_manifest['services']
            loaded_ids = set()
            for service_id in service_order:
                service_config = next((s for s in all_services if s['id'] == service_id), None)
                if service_config:
                    self._load_service(service_config)
                    loaded_ids.add(service_id)
            if "license_manager_service" in self.services:
                self.write_to_log("Kernel: Running early license verification...", "INFO") # English Log
                license_manager = self.get_service("license_manager_service", is_system_call=True)
                if hasattr(license_manager, 'verify_license_on_startup'):
                    license_manager.verify_license_on_startup()
                self.write_to_log(f"Kernel: License tier confirmed as '{self.license_tier.upper()}' before loading premium services.", "SUCCESS") # English Log
            for service_config in all_services:
                if service_config['id'] not in loaded_ids:
                    self._load_service(service_config)
            self.write_to_log("Kernel: All services loaded. Creating aliases...", "DEBUG")
            if "preset_manager_service" in self.services:
                self.services["preset_manager"] = self.services["preset_manager_service"]
                self.write_to_log("Alias 'preset_manager' created for 'preset_manager_service'.", "SUCCESS")
            if "variable_manager" in self.services:
                self.services["variable_manager_service"] = self.services["variable_manager"]
                self.write_to_log("Alias 'variable_manager_service' created for 'variable_manager'.", "SUCCESS")
        except Exception as e:
            raise RuntimeError(f"Could not load services manifest: {e}") from e
    def _load_service(self, service_config: Dict[str, str]):
        service_id = service_config['id']
        service_type = service_config.get("type", "class")
        try:
            if service_id in self.SERVICE_CAPABILITY_MAP:
                capability_needed = self.SERVICE_CAPABILITY_MAP[service_id]
                permission_manager = self.services.get("permission_manager_service")
                if permission_manager and not permission_manager.check_permission(capability_needed, is_system_call=True):
                    raise PermissionDeniedError(f"Permission denied to LOAD service '{service_id}' - requires '{capability_needed}'.")
            if service_type == "service_workflow":
                preset_path = service_config.get("preset_path")
                if not preset_path:
                    self.write_to_log(f"Failed to load service workflow '{service_id}': 'preset_path' is missing.", "ERROR")
                    return
                full_preset_path = os.path.join(self.project_root_path, preset_path)
                self.services[service_id] = ServiceWorkflowProxy(self, service_id, full_preset_path)
            else:
                module_path = service_config['path']
                class_name = service_config['class']
                module = importlib.import_module(module_path)
                ServiceClass = getattr(module, class_name)
                self.services[service_id] = ServiceClass(self, service_id)
                self.write_to_log(f"Service '{service_id}' loaded successfully.", "SUCCESS")
        except PermissionDeniedError as e:
            self.write_to_log(f"Failed to load service '{service_id}' due to insufficient permissions: {e}", "WARN")
            return
        except Exception as e:
            self.write_to_log(f"Failed to load service '{service_id}': {e}", "ERROR")
            if service_id in ["event_bus", "localization_manager", "integrity_checker_service", "license_manager_service", "permission_manager_service", "state_manager", "variable_manager_service", "module_manager_service"]:
                raise RuntimeError(f"Critical service '{service_id}' failed to load.") from e
    def get_service(self, service_id: str, is_system_call: bool = False) -> Any:
        try:
            if service_id in self.SERVICE_CAPABILITY_MAP and not is_system_call:
                capability_needed = self.SERVICE_CAPABILITY_MAP[service_id]
                permission_manager = self.services.get("permission_manager_service")
                if permission_manager:
                    permission_manager.check_permission(capability_needed, is_system_call=False)
            service = self.services.get(service_id)
            if not service:
                self.write_to_log(f"Service '{service_id}' requested but not found!", "ERROR")
            return service
        except PermissionDeniedError as e:
            self.write_to_log(f"Permission Denied accessing service '{service_id}': {e}", "WARN")
            raise e
    def start_all_services(self):
        self.write_to_log("Kernel: Minimalist bootloader starting...", "INFO")
        log_worker_thread = threading.Thread(target=self._log_queue_worker, daemon=True)
        log_worker_thread.start()
        self.write_to_log("Kernel: Handing control directly to StartupService...", "INFO")
        try:
            startup_service = self.get_service('startup_service', is_system_call=True)
            if startup_service:
                result = startup_service.run_startup_sequence()
                self.write_to_log(f"Startup sequence finished with status: {result}", "SUCCESS")
            else:
                 self.write_to_log("CRITICAL: StartupService not found! Cannot start application.", "ERROR")
                 raise RuntimeError("StartupService is essential for application startup and was not found.")
        except Exception as e:
            self.write_to_log(f"CRITICAL: Startup sequence failed with an exception: {e}", "ERROR")
            raise e
    def finalize_startup(self):
        self.write_to_log("Kernel: Finalizing startup sequence (UI is ready).", "INFO")
        self.write_to_log("Kernel: Startup finalized. Application is fully operational.", "SUCCESS")
    def hot_reload_components(self):
        self.write_to_log("HOT RELOAD: A component change was detected. Reloading all components...", "WARN")
        for cache_file in ["module_index.cache", "widget_index.cache", "trigger_index.cache"]:
            cache_path = os.path.join(self.data_path, cache_file)
            if os.path.exists(cache_path):
                try:
                    os.remove(cache_path)
                except OSError: pass
        self.get_service("module_manager_service").discover_and_load_modules()
        self.get_service("widget_manager_service").discover_and_load_widgets()
        self.get_service("trigger_manager_service").discover_and_load_triggers()
        self.get_service("localization_manager").load_all_languages()
        if self.event_bus:
            self.event_bus.publish("COMPONENT_LIST_CHANGED", {"status": "hot_reloaded"})
        if self.root and hasattr(self.root, 'refresh_ui_components'):
            self.root.after(100, self.root.refresh_ui_components)
        self.write_to_log("HOT RELOAD: Component reload process finished.", "SUCCESS")
    def stop_all_services(self):
        self.write_to_log("Kernel: Stopping all services...", "INFO")
        for service_id, service_instance in reversed(list(self.services.items())):
            if hasattr(service_instance, 'stop') and callable(getattr(service_instance, 'stop')):
                try:
                    if not isinstance(service_instance, ServiceWorkflowProxy):
                        service_instance.stop()
                except Exception as e:
                    self.write_to_log(f"Error stopping service '{service_id}': {e}", "ERROR")
        for service_id, service_instance in reversed(list(self.services.items())):
             if isinstance(service_instance, threading.Thread) and service_instance.is_alive():
                service_instance.join(timeout=2)
    def is_premium_user(self) -> bool:
        return self.is_premium
    def is_monetization_active(self) -> bool:
        license_manager = self.get_service("license_manager_service", is_system_call=True)
        if license_manager and license_manager.remote_permission_rules:
            return license_manager.remote_permission_rules.get("monetization_active", True)
        return True
    def is_tier_sufficient(self, required_tier: str) -> bool:
        if not self.is_monetization_active():
            return True
        user_level = self.TIER_HIERARCHY.get(self.license_tier.lower(), 0)
        required_level = self.TIER_HIERARCHY.get(required_tier.lower(), 99)
        return user_level >= required_level
    def activate_license_online(self, full_license_content: dict):
        license_manager = self.get_service("license_manager_service")
        if license_manager:
            return license_manager.activate_license_on_server(full_license_content)
        return False, "License Manager service not found."
    def deactivate_license_online(self):
        license_manager = self.get_service("license_manager_service")
        if license_manager:
            return license_manager.deactivate_license_on_server()
        return False, "License Manager service not found."
    def register_log_viewer(self, tab_id: str, log_viewer_instance):
        if self.log_viewer_references.get(tab_id) is log_viewer_instance:
            return
        self.write_to_log(f"Log Viewer for tab ID '{tab_id}' has been registered.", "DEBUG")
        self.log_viewer_references[tab_id] = log_viewer_instance
    def unregister_log_viewer(self, tab_id: str):
        if tab_id in self.log_viewer_references:
            del self.log_viewer_references[tab_id]
    def set_root(self, root_window):
        self.root = root_window
    def _setup_file_logger(self):
        self.file_logger = logging.getLogger('FloworkFileLogger')
        self.file_logger.setLevel(logging.DEBUG)
        log_file_path = os.path.join(self.logs_path, f"flowork_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
        if not self.file_logger.handlers:
            file_handler = logging.FileHandler(log_file_path, encoding='utf-8')
            formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(message)s', datefmt='%H:%M:%S')
            file_handler.setFormatter(formatter)
            self.file_logger.addHandler(file_handler)
    def write_to_log(self, message, level="INFO"):
        log_record = {"message": str(message), "level": level.upper()}
        self.log_queue.put(log_record)
    def display_approval_popup(self, module_id: str, message: str, callback_func: Callable):
        module_manager = self.get_service("module_manager_service")
        if not module_manager:
            if callable(callback_func):
                threading.Thread(target=callback_func, args=('REJECTED',)).start()
            return
        module_manager.register_approval_callback(module_id, callback_func)
        if self.root and hasattr(self.root, 'popup_manager'):
             self.root.popup_manager.show_approval(module_id, "Current Workflow", message)
        else:
            if callable(callback_func):
                threading.Thread(target=callback_func, args=('REJECTED',)).start()
    def display_permission_denied_popup(self, message: str):
        if self.root and hasattr(self.root, 'show_permission_denied_popup'):
            self.root.show_permission_denied_popup(message)
        else:
            self.write_to_log(f"PERMISSION_DENIED_POPUP_FALLBACK: {message}", "CRITICAL")
    def trigger_workflow_from_node(self, target_node_id: str, payload: dict):
        """
        Finds the correct workflow tab containing the target node and starts
        execution from that specific node.
        """
        self.write_to_log(f"Kernel received request to trigger workflow from node '{target_node_id}'.", "INFO") # English Log
        executor = self.get_service("workflow_executor_service")
        if executor:
            executor.trigger_workflow_from_node(target_node_id, payload)
        else:
            self.write_to_log("WorkflowExecutorService not available, cannot trigger node.", "ERROR") # English Log
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services.json
# JUMLAH BARIS : 197
#######################################################################

```json
{
    "services": [
        {
            "id": "integrity_checker_service",
            "path": "flowork_kernel.services.integrity_checker_service.integrity_checker_service",
            "class": "IntegrityCheckerService"
        },
        {
            "id": "license_manager_service",
            "path": "flowork_kernel.services.license_manager_service.license_manager_service",
            "class": "LicenseManagerService"
        },
        {
            "id": "permission_manager_service",
            "path": "flowork_kernel.services.permission_manager_service.permission_manager_service",
            "class": "PermissionManagerService"
        },
        {
            "id": "event_bus",
            "path": "flowork_kernel.services.event_bus_service.event_bus_service",
            "class": "EventBusService"
        },
        {
            "id": "localization_manager",
            "path": "flowork_kernel.services.localization_manager_service.localization_manager_service",
            "class": "LocalizationManagerService"
        },
        {
            "id": "tab_manager_service",
            "path": "flowork_kernel.services.tab_manager_service.tab_manager_service",
            "class": "TabManagerService"
        },
        {
            "id": "update_service",
            "path": "flowork_kernel.services.update_service.update_service",
            "class": "UpdateService"
        },
        {
            "id": "startup_service",
            "path": "flowork_kernel.services.startup_service.startup_service",
            "class": "StartupService"
        },
        {
            "id": "diagnostics_service",
            "path": "flowork_kernel.services.diagnostics_service.diagnostics_service",
            "class": "DiagnosticsService"
        },
        {
            "id": "scanner_manager_service",
            "path": "flowork_kernel.services.scanner_manager_service.scanner_manager_service",
            "class": "ScannerManagerService"
        },
        {
            "id": "documentation_service",
            "path": "flowork_kernel.services.documentation_service.documentation_service",
            "class": "DocumentationService"
        },
        {
            "id": "community_addon_service",
            "path": "flowork_kernel.services.community_addon_service.community_addon_service",
            "class": "CommunityAddonService"
        },
        {
            "id": "theme_manager",
            "path": "generated_services.theme_manager_service.service",
            "class": "ThemeManagerService",
            "source_workflow": "core_services/theme_manager.flowork"
        },
        {
            "id": "state_manager",
            "path": "flowork_kernel.services.state_manager_service.state_manager_service",
            "class": "StateManagerService"
        },
        {
            "id": "database_service",
            "path": "flowork_kernel.services.database_service.database_service",
            "class": "DatabaseService"
        },
        {
            "id": "dataset_manager_service",
            "path": "flowork_kernel.services.dataset_manager_service.dataset_manager_service",
            "class": "DatasetManagerService"
        },
        {
            "id": "ai_training_service",
            "path": "flowork_kernel.services.ai_training_service.ai_training_service",
            "class": "AITrainingService"
        },
        {
            "id": "model_converter_service",
            "path": "flowork_kernel.services.model_converter_service.model_converter_service",
            "class": "ModelConverterService"
        },
        {
            "id": "variable_manager",
            "path": "flowork_kernel.services.variable_manager_service.variable_manager_service",
            "class": "VariableManagerService"
        },
        {
            "id": "preset_manager_service",
            "path": "generated_services.preset_manager_service.service",
            "class": "PresetManagerService",
            "source_workflow": "core_services/preset_manager.flowork"
        },
        {
            "id": "module_manager_service",
            "path": "flowork_kernel.services.module_manager_service.module_manager_service",
            "class": "ModuleManagerService"
        },
        {
            "id": "plugin_manager_service",
            "path": "flowork_kernel.services.plugin_manager_service.plugin_manager_service",
            "class": "PluginManagerService"
        },
        {
            "id": "widget_manager_service",
            "path": "flowork_kernel.services.widget_manager_service.widget_manager_service",
            "class": "WidgetManagerService"
        },
        {
            "id": "trigger_manager_service",
            "path": "flowork_kernel.services.trigger_manager_service.trigger_manager_service",
            "class": "TriggerManagerService"
        },
        {
            "id": "scheduler_manager_service",
            "path": "flowork_kernel.services.scheduler_manager_service.scheduler_manager_service",
            "class": "SchedulerManagerService"
        },
        {
            "id": "api_server_service",
            "path": "flowork_kernel.services.api_server_service.api_server_service",
            "class": "ApiServerService"
        },
        {
            "id": "behavior_manager_service",
            "path": "flowork_kernel.services.behavior_manager_service.behavior_manager_service",
            "class": "BehaviorManagerService"
        },
        {
            "id": "formatter_manager_service",
            "path": "generated_services.formatter_manager_service.service",
            "class": "FormatterManagerService",
            "source_workflow": "core_services/formatter_manager.flowork"
        },
        {
            "id": "prompt_manager_service",
            "path": "flowork_kernel.services.prompt_manager_service.prompt_manager_service",
            "class": "PromptManagerService"
        },
        {
            "id": "ai_provider_manager_service",
            "path": "flowork_kernel.services.ai_provider_manager_service.ai_provider_manager_service",
            "class": "AIProviderManagerService"
        },
        {
            "id": "ai_analyzer_service",
            "path": "flowork_kernel.services.ai_analyzer_service.ai_analyzer_service",
            "class": "AIAnalyzerService"
        },
        {
            "id": "ai_architect_service",
            "path": "flowork_kernel.services.ai_architect_service.ai_architect_service",
            "class": "AiArchitectService"
        },
        {
            "id": "semantic_search_service",
            "path": "flowork_kernel.services.semantic_search_service.semantic_search_service",
            "class": "SemanticSearchService"
        },
        {
            "id": "agent_manager_service",
            "path": "flowork_kernel.services.agent_manager_service.agent_manager_service",
            "class": "AgentManagerService"
        },
        {
            "id": "workflow_executor_service",
            "path": "flowork_kernel.services.workflow_executor_service.workflow_executor_service",
            "class": "WorkflowExecutorService"
        },
        {
            "id": "screen_recorder_service",
            "path": "flowork_kernel.services.screen_recorder_service.screen_recorder_service",
            "class": "ScreenRecorderService"
        },
        {
            "id": "auto_compiler_service",
            "path": "flowork_kernel.services.auto_compiler_service.auto_compiler_service",
            "class": "AutoCompilerService"
        },
        {
            "id": "agent_executor_service",
            "path": "flowork_kernel.services.agent_executor_service.agent_executor_service",
            "class": "AgentExecutorService"
        }
    ]
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\webhook_server.py
# JUMLAH BARIS : 143
#######################################################################

```py
import http.server
import socketserver
import threading
import json
import logging
import uuid
import queue # (COMMENT) This import seems to be used correctly.
from urllib.parse import urlparse, unquote
class WebhookRequestHandler(http.server.BaseHTTPRequestHandler):
    """
    Handles incoming HTTP requests. Now acts as a router
    for /webhook and /api endpoints, and handles GET and POST requests.
    """
    def do_POST(self):
        """Handles all POST requests."""
        parsed_path = urlparse(self.path)
        path_parts = [part for part in unquote(parsed_path.path).strip('/').split('/') if part]
        if not path_parts:
            self._send_response(404, {"error": "Endpoint not found."})
            return
        request_type = path_parts[0]
        if request_type == 'webhook':
            if len(path_parts) == 2:
                preset_name = path_parts[1]
                self._handle_workflow_trigger(preset_name)
            else:
                self._send_response(400, {"error": "Invalid webhook format. Use /webhook/{preset_name}"})
        elif request_type == 'api':
            self._handle_api_request(path_parts)
        else:
            self._send_response(404, {"error": f"Unknown endpoint '{request_type}'."})
    def do_GET(self):
        """Handles all GET requests, specifically for status checks and fetching diagnostic results."""
        parsed_path = urlparse(self.path)
        path_parts = [part for part in unquote(parsed_path.path).strip('/').split('/') if part]
        if not path_parts:
            self._send_response(404, {"error": "Endpoint not found."})
            return
        if len(path_parts) == 4 and path_parts[0] == 'api' and path_parts[1] == 'management' and path_parts[2] == 'status':
            job_id = path_parts[3]
            logging.info(f"API: Received status request for job_id: {job_id}")
            status_info = self.server.kernel.get_job_status(job_id)
            if status_info:
                self._send_response(200, status_info)
            else:
                self._send_response(404, {"error": f"Job with ID '{job_id}' not found."})
        elif len(path_parts) == 3 and path_parts[0] == 'api' and path_parts[1] == 'diagnostics' and path_parts[2] == 'raw_log':
            self.server.kernel.write_to_log("API: Received request to fetch Raw CMD Log.", "INFO")
            all_logs = []
            while not self.server.kernel.cmd_log_queue.empty():
                try:
                    all_logs.append(self.server.kernel.cmd_log_queue.get_nowait())
                except queue.Empty:
                    break
            self._send_response(200, {"console_output": "\n".join(all_logs)})
        else:
            self._send_response(404, {"error": "Invalid GET endpoint or not found."})
    def _handle_api_request(self, path_parts):
        """Processes various commands coming through /api/... (for POST only)"""
        if len(path_parts) == 3 and path_parts[0] == 'api' and path_parts[1] == 'diagnostics' and path_parts[2] == 'start_scan':
            self.server.kernel.write_to_log("API: Received request to start Sanity Scan...", "INFO")
            diag_plugin = self.server.kernel.module_manager.get_instance("system_diagnostics_plugin")
            if diag_plugin and hasattr(diag_plugin, 'start_scan_headless'):
                scan_id = str(uuid.uuid4())
                result_data = diag_plugin.start_scan_headless(scan_id)
                self._send_response(200, result_data) # Directly return the result with a 200 OK status
            else:
                self._send_response(500, {"error": "Diagnostics plugin not found or not ready."})
            return
        if len(path_parts) == 4 and path_parts[1] == 'management' and path_parts[2] == 'start':
            preset_name = path_parts[3]
            logging.info(f"API received to start preset '{preset_name}'. Triggering execution...")
            job_id = self.server.kernel.trigger_workflow_by_api(preset_name)
            if job_id:
                self._send_response(200, {"status": "success", "message": f"Workflow for preset '{preset_name}' started successfully.", "job_id": job_id})
            else:
                self._send_response(404, {"status": "failed", "message": f"Preset '{preset_name}' not found or failed to start."})
        else:
            self._send_response(400, {"error": "Invalid API command format."})
    def _handle_workflow_trigger(self, preset_name):
        """Processes the workflow trigger from a valid request (old logic)."""
        try:
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            webhook_data = json.loads(post_data)
            logging.info(f"Webhook received for preset '{preset_name}'. Triggering execution...")
            self.server.kernel.trigger_workflow_by_webhook(preset_name, webhook_data)
            self._send_response(200, {"status": "success", "message": f"Workflow for preset '{preset_name}' was triggered successfully."})
        except json.JSONDecodeError:
            self._send_response(400, {"error": "Bad Request: Body must be in valid JSON format."})
        except Exception as e:
            logging.error(f"Error handling webhook for preset '{preset_name}': {e}")
            self._send_response(500, {"error": f"Internal Server Error: {e}"})
    def _send_response(self, status_code, response_data):
        """Sends an HTTP response back to the client."""
        self.send_response(status_code)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(json.dumps(response_data).encode('utf-8'))
    def log_message(self, format, *args):
        """Redirects server logs to the main logging system."""
        logging.info(f"WebhookServer: {args[0]}")
class WebhookServer:
    """
    Manages the lifecycle of the HTTP server running in a separate thread.
    """
    def __init__(self, kernel_instance, host="0.0.0.0", port=8989):
        self.kernel = kernel_instance
        self.host = host
        self.port = port
        self.thread = None
        self.httpd = None
    def start(self):
        """Starts the HTTP server in a new thread."""
        try:
            self.httpd = socketserver.TCPServer((self.host, self.port), WebhookRequestHandler)
            self.httpd.kernel = self.kernel
            self.thread = threading.Thread(target=self.httpd.serve_forever)
            self.thread.daemon = True
            self.thread.start()
            self.kernel.write_to_log(f"Webhook/API Server started and listening on http://{self.host}:{self.port}", "SUCCESS")
        except OSError as e:
            self.kernel.write_to_log(f"FAILED to start Webhook/API server on port {self.port}: {e}. The port might already be in use.", "ERROR")
            self.httpd = None
        except Exception as e:
            self.kernel.write_to_log(f"An unexpected error occurred while starting the Webhook/API server: {e}", "ERROR")
            self.httpd = None
    def stop(self):
        """Stops the HTTP server safely."""
        if self.httpd and self.thread and self.thread.is_alive():
            self.kernel.write_to_log("Stopping Webhook/API server...", "INFO")
            self.httpd.shutdown()
            self.httpd.server_close()
            self.thread.join(timeout=2)
            self.kernel.write_to_log("Webhook/API server stopped successfully.", "SUCCESS")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\core\build_security.py
# JUMLAH BARIS : 17
#######################################################################

```py
import os
import sys
OFFICIAL_BUILD_SIGNATURE = ""
def perform_runtime_check(module_file_path):
    """
    (COMMENT) This security check is currently disabled as per user request.
    The function is kept to prevent import errors but does nothing.
    """
    pass
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\core\input_schema.py
# JUMLAH BARIS : 26
#######################################################################

```py
from typing import Dict, Any
class InputVar:
    """Defines a single expected input variable for a module's payload."""
    def __init__(self, display_name: str, var_type: str, required: bool = False, description: str = ""):
        self.display_name = display_name
        self.var_type = var_type
        self.required = required
        self.description = description
class InputSchema:
    """Manages the collection of input variables for a module."""
    def __init__(self, variables: Dict[str, InputVar]):
        self.variables = variables
    def get_var(self, key: str, payload: Dict[str, Any]) -> Any:
        """Safely retrieves a variable's value from a payload."""
        return payload.get('data', {}).get(key)
def create_input_schema(**kwargs: InputVar) -> InputSchema:
    """Factory function to easily create an InputSchema instance."""
    return InputSchema(kwargs)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\core\output_schema.py
# JUMLAH BARIS : 22
#######################################################################

```py
from typing import Dict, Any
class OutputVar:
    """Defines a single variable that a module guarantees to output."""
    def __init__(self, display_name: str, var_type: str, description: str = ""):
        self.display_name = display_name
        self.var_type = var_type
        self.description = description
class OutputSchema:
    """Manages the collection of output variables for a module."""
    def __init__(self, variables: Dict[str, OutputVar]):
        self.variables = variables
def create_output_schema(**kwargs: OutputVar) -> OutputSchema:
    """Factory function to easily create an OutputSchema instance."""
    return OutputSchema(kwargs)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\core\permission_hook.py
# JUMLAH BARIS : 62
#######################################################################

```py
import sys
from flowork_kernel.kernel import Kernel
from flowork_kernel.exceptions import PermissionDeniedError
_kernel_instance = None
def get_kernel():
    global _kernel_instance
    if _kernel_instance is None:
        _kernel_instance = Kernel.instance
    return _kernel_instance
class PermissionHook:
    """
    A Python Import Hook that acts as a gatekeeper for premium libraries.
    """
    PROTECTED_MODULES = {
        "selenium": "web_scraping_advanced",
        "webdriver_manager": "web_scraping_advanced",
        "torch": "ai_local_models",
        "diffusers": "ai_local_models",
        "transformers": "ai_local_models",
        "llama_cpp": "ai_local_models",
        "moviepy": "video_processing",
        "nuitka": "core_compilation"
    }
    def __init__(self):
        self._active = False
        kernel = get_kernel()
        if kernel:
            event_bus = kernel.get_service("event_bus", is_system_call=True)
            if event_bus:
                event_bus.subscribe("event_all_services_started", "PermissionHookActivator", self.activate)
    def activate(self, event_data=None):
        """Activates the hook to start enforcing permissions."""
        kernel = get_kernel()
        if kernel:
            kernel.write_to_log("PermissionHook: Activating import-level security.", "SUCCESS")
        self._active = True
    def find_spec(self, fullname, path, target=None):
        """
        The core method of the import hook.
        """
        if not self._active:
            return None
        module_root = fullname.split('.')[0]
        if module_root in self.PROTECTED_MODULES:
            kernel = get_kernel()
            if kernel:
                permission_manager = kernel.get_service("permission_manager_service", is_system_call=True)
                capability = self.PROTECTED_MODULES[module_root]
                if permission_manager:
                    try:
                        permission_manager.check_permission(capability)
                    except PermissionDeniedError as e:
                        raise e
        return None
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\core_runners\bash.json
# JUMLAH BARIS : 6
#######################################################################

```json
{
    "language_name": "Bash Script",
    "command": "bash",
    "file_extension": ".sh",
    "version_argument": "--version"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\core_runners\javascript.json
# JUMLAH BARIS : 6
#######################################################################

```json
{
    "language_name": "JavaScript (Node.js)",
    "command": "node",
    "file_extension": ".js",
    "version_argument": "--version"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\core_runners\perl.json
# JUMLAH BARIS : 6
#######################################################################

```json
{
    "language_name": "Perl",
    "command": "perl",
    "file_extension": ".pl",
    "version_argument": "-v"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\core_runners\php.json
# JUMLAH BARIS : 6
#######################################################################

```json
{
    "language_name": "PHP",
    "command": "php",
    "file_extension": ".php",
    "version_argument": "-v"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\core_runners\python.json
# JUMLAH BARIS : 6
#######################################################################

```json
{
    "language_name": "Python",
    "command": "python",
    "file_extension": ".py",
    "version_argument": "--version"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\core_runners\ruby.json
# JUMLAH BARIS : 6
#######################################################################

```json
{
    "language_name": "Ruby",
    "command": "ruby",
    "file_extension": ".rb",
    "version_argument": "--version"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\execution\CheckpointManager.py
# JUMLAH BARIS : 59
#######################################################################

```py
class CheckpointManager:
    """
    Abstracts the process of saving and loading workflow state (checkpoints).
    This keeps the main executor clean from state management details.
    """
    def __init__(self, kernel):
        """
        Initializes the checkpoint manager.
        Args:
            kernel: The main application kernel to access state manager.
        """
        self.kernel = kernel
        self.state_manager = self.kernel.get_service("state_manager")
    def save(self, context_id: str, node_id: str, payload: dict, node_name: str):
        """
        Saves the current state of the workflow as a checkpoint.
        Args:
            context_id: The unique ID for the current workflow execution.
            node_id: The ID of the node after which the state is being saved.
            payload: The payload to save.
            node_name: The name of the node for logging purposes.
        """
        if not self.state_manager:
            self.kernel.write_to_log("CheckpointManager Error: StateManager service not available.", "ERROR")
            return
        checkpoint_key = f"checkpoint::{context_id}"
        checkpoint_data = {
            "node_id": node_id,
            "payload": payload
        }
        self.state_manager.set(checkpoint_key, checkpoint_data)
        self.kernel.write_to_log(f"CHECKPOINT: Workflow state saved after node '{node_name}'.", "INFO")
    def load(self, context_id: str):
        """
        Loads a checkpoint for a given workflow context.
        Args:
            context_id: The unique ID for the workflow execution.
        Returns:
            A tuple (resume_node_id, resume_payload) or (None, None) if not found.
        """
        if not self.state_manager:
            return None, None
        checkpoint_key = f"checkpoint::{context_id}"
        saved_checkpoint = self.state_manager.get(checkpoint_key)
        if saved_checkpoint and isinstance(saved_checkpoint, dict):
            resume_node_id = saved_checkpoint.get("node_id")
            resume_payload = saved_checkpoint.get("payload")
            if resume_node_id and resume_payload is not None:
                self.state_manager.delete(checkpoint_key) # Consume the checkpoint
                return resume_node_id, resume_payload
        return None, None
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\execution\LoopHandler.py
# JUMLAH BARIS : 106
#######################################################################

```py
import time
import random
from ..utils.type_converter import to_number
class LoopHandler:
    """
    Manages the entire lifecycle of a loop for a node execution.
    Handles count-based and condition-based loops, including delays.
    """
    def __init__(self, kernel, core_executor_func):
        """
        Initializes the loop handler.
        Args:
            kernel: The main application kernel.
            core_executor_func (function): The core function that executes a single node attempt.
        """
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        self.state_manager = self.kernel.get_service("state_manager")
        self.core_executor_func = core_executor_func
    def execute_with_loop(self, payload: dict, config: dict, node_info: dict, context_id: str, mode: str):
        """
        Wraps the execution of a node with looping logic if enabled in the config.
        Args:
            payload: The current workflow payload.
            config: The resolved configuration for the node.
            node_info: The dictionary containing all node data.
            context_id: The unique ID for the current workflow execution context.
            mode: The execution mode ('EXECUTE' or 'SIMULATE').
        Returns:
            The final payload after the loop completes or the first error encountered.
        """
        node_id = node_info.get("id")
        node_name = node_info.get("name", "[Unnamed]")
        loop_state_key = f"loop_progress::{context_id}::{node_id}"
        start_iteration = self.state_manager.get(loop_state_key, 0)
        if start_iteration > 0:
            self.kernel.write_to_log(f"Resuming loop for node '{node_name}' from iteration {start_iteration + 1}", "INFO") # English Log
        loop_count = start_iteration
        current_payload = payload
        while True:
            if self.kernel.get_service("workflow_executor_service")._stop_event.is_set():
                self.kernel.write_to_log(f"Loop for node '{node_name}' stopped by user.", "WARN") # English Log
                break
            self.kernel.get_service("workflow_executor_service")._pause_event.wait()
            loop_type = config.get('loop_type', 'count')
            if loop_type == 'count':
                total_iterations = config.get('loop_iterations', 1)
                if loop_count >= total_iterations:
                    self.kernel.write_to_log(f"Count-based loop for '{node_name}' finished after {loop_count} iterations.", "INFO") # English Log
                    break
            elif loop_type == 'condition':
                if self._check_condition(current_payload, config):
                    self.kernel.write_to_log(f"Condition for loop on node '{node_name}' met. Exiting loop.", "INFO") # English Log
                    break
            execution_result = self.core_executor_func(current_payload, config, node_info, context_id, mode)
            if isinstance(execution_result, Exception):
                self.kernel.write_to_log(f"Error during loop iteration {loop_count + 1} for node '{node_name}': {execution_result}", "ERROR") # English Log
                current_payload = execution_result # (COMMENT) Propagate the error
                break
            if isinstance(execution_result, dict) and "payload" in execution_result:
                current_payload = execution_result.get("payload", current_payload)
            else:
                current_payload = execution_result
            loop_count += 1
            if mode == 'EXECUTE':
                self.state_manager.set(loop_state_key, loop_count)
            self._handle_sleep(config, node_name, mode)
        if mode == 'EXECUTE':
            self.state_manager.delete(loop_state_key) # (COMMENT) Clean up loop state
        return current_payload
    def _check_condition(self, payload: dict, config: dict) -> bool:
        var_path = config.get('loop_condition_var')
        operator = config.get('loop_condition_op')
        target_value = config.get('loop_condition_val')
        if not var_path:
            return True # (COMMENT) Exit loop if condition var is not set
        from ..utils.payload_helper import get_nested_value
        actual_value = get_nested_value(payload, var_path)
        if isinstance(actual_value, (int, float)):
            target_value = to_number(target_value)
        elif isinstance(actual_value, bool):
            target_value = str(target_value).lower() == 'true'
        if operator == '==': return actual_value == target_value
        if operator == '!=': return actual_value != target_value
        return False
    def _handle_sleep(self, config: dict, node_name: str, mode: str):
        if config.get('enable_sleep', False) and mode == 'EXECUTE':
            sleep_duration = 0
            if config.get('sleep_type') == 'static':
                sleep_duration = config.get('static_duration', 1)
                self.kernel.write_to_log(f"Loop on '{node_name}': Sleeping for {sleep_duration} seconds.", "INFO") # English Log
            elif config.get('sleep_type') == 'random_range':
                min_sleep = config.get('random_min', 1)
                max_sleep = config.get('random_max', 5)
                sleep_duration = random.randint(min_sleep, max_sleep)
                self.kernel.write_to_log(f"Loop on '{node_name}': Sleeping for a random duration of {sleep_duration}s.", "INFO") # English Log
            if sleep_duration > 0:
                time.sleep(sleep_duration)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\execution\RetryHandler.py
# JUMLAH BARIS : 51
#######################################################################

```py
import time
class RetryHandler:
    """
    Wraps the execution of a node with retry logic.
    If the execution fails, it waits for a specified delay and tries again.
    """
    def __init__(self, kernel, core_executor_func):
        """
        Initializes the retry handler.
        Args:
            kernel: The main application kernel.
            core_executor_func (function): The core function that executes a single node attempt.
        """
        self.kernel = kernel
        self.loc = self.kernel.get_service("localization_manager")
        self.core_executor_func = core_executor_func
    def execute_with_retries(self, payload: dict, config: dict, node_info: dict, context_id: str, mode: str):
        """
        Executes the core node logic, retrying on failure if configured.
        Args:
            (Same as LoopHandler.execute_with_loop)
        Returns:
            The result of the last successful attempt, or the exception from the final attempt.
        """
        retry_attempts = config.get('retry_attempts', 0)
        retry_delay = config.get('retry_delay_seconds', 5)
        node_name = node_info.get("name", "[Unnamed]")
        last_exception = None
        for attempt in range(retry_attempts + 1):
            if self.kernel.get_service("workflow_executor_service")._stop_event.is_set():
                self.kernel.write_to_log(f"Retry for node '{node_name}' cancelled by user.", "WARN")
                break
            if attempt > 0:
                self.kernel.write_to_log(
                    f"Node '{node_name}' failed. Retrying in {retry_delay}s... (Attempt {attempt}/{retry_attempts})", "WARN"
                )
                time.sleep(retry_delay)
            result = self.core_executor_func(payload, config, node_info, context_id, mode)
            if not isinstance(result, Exception):
                return result # Success
            last_exception = result
        self.kernel.write_to_log(f"Node '{node_name}' failed after all {retry_attempts} retry attempts.", "ERROR")
        return last_exception
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\execution\VariableResolver.py
# JUMLAH BARIS : 50
#######################################################################

```py
import re
class VariableResolver:
    """
    A dedicated class for resolving variable placeholders within a node's configuration.
    It recursively handles dictionaries, lists, and strings.
    """
    def __init__(self, kernel):
        """
        Initializes the resolver with a kernel instance to access services.
        Args:
            kernel: The main application kernel.
        """
        self.kernel = kernel
    def resolve(self, config_item: any) -> any:
        """
        Recursively resolves variable placeholders in a given configuration item.
        Args:
            config_item: The configuration item (string, dict, list) to resolve.
        Returns:
            The configuration item with all placeholders replaced by their actual values.
        """
        variable_manager = self.kernel.get_service("variable_manager")
        if isinstance(config_item, dict):
            return {k: self.resolve(v) for k, v in config_item.items()}
        elif isinstance(config_item, list):
            return [self.resolve(elem) for elem in config_item]
        elif isinstance(config_item, str):
            pattern = r'\{\{vars\.([A-Z0-9_]+)\}\}'
            match_full = re.fullmatch(pattern, config_item)
            if match_full:
                var_name = match_full.group(1)
                if variable_manager: # MODIFIED: Use the locally fetched instance
                    return variable_manager.get_variable(var_name)
                return config_item # Fallback if service not found
            def replace_match(match):
                var_name = match.group(1)
                if variable_manager: # MODIFIED: Use the locally fetched instance
                    value = variable_manager.get_variable(var_name)
                    return str(value) if value is not None else match.group(0)
                return match.group(0) # Fallback if service not found
            return re.sub(pattern, replace_match, config_item)
        return config_item
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\factories\ParserFactory.py
# JUMLAH BARIS : 27
#######################################################################

```py
class ParserFactory:
    """
    The central factory for creating data parser instances.
    This is the only class that should directly talk to the FormatterManagerService.
    """
    @staticmethod
    def create_parser(kernel, formatter_id: str):
        """
        Creates a formatter instance based on the requested ID.
        Args:
            kernel: The main kernel instance.
            formatter_id (str): The ID of the desired formatter (e.g., 'csv_formatter').
        Returns:
            A formatter instance object, or None if not found.
        """
        formatter_manager = kernel.get_service("formatter_manager_service")
        if formatter_manager:
            return formatter_manager.get_formatter(formatter_id)
        return None
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\models\AgentModel.py
# JUMLAH BARIS : 22
#######################################################################

```py
from pydantic import BaseModel, Field
from typing import List, Optional
from uuid import UUID, uuid4
class AgentModel(BaseModel):
    """
    Defines the data structure for an autonomous AI Agent.
    Each agent has a brain (an AI model) and a set of tools (modules) it can use.
    """
    id: UUID = Field(default_factory=uuid4)
    name: str
    description: Optional[str] = ""
    brain_model_id: str = Field(..., description="The ID of the GGUF model file that acts as the agent's brain.")
    tool_ids: List[str] = Field(default_factory=list, description="A list of module_ids that this agent is allowed to use as tools.")
    prompt_template: Optional[str] = ""
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\models\ConnectionModel.py
# JUMLAH BARIS : 22
#######################################################################

```py
from pydantic import BaseModel, Field
from typing import Optional
from uuid import UUID, uuid4
class ConnectionModel(BaseModel):
    """
    Represents the data structure for a connection between two nodes.
    Uses an alias for 'from' as it is a reserved keyword in Python.
    """
    id: UUID = Field(default_factory=uuid4)
    from_node: UUID = Field(..., alias='from')
    to_node: UUID = Field(..., alias='to')
    source_port_name: Optional[str] = None
    class Config:
        allow_population_by_field_name = True # Memungkinkan kita mengisi 'from_node' menggunakan 'from'
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\models\ManifestModel.py
# JUMLAH BARIS : 49
#######################################################################

```py
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
class PropertyModel(BaseModel):
    id: str
    type: str
    label: str
    description: Optional[str] = ""
    default: Optional[Any] = None
class PortModel(BaseModel):
    name: str
    display_name: str
    tooltip: Optional[str] = ""
class OutputSchemaModel(BaseModel):
    name: str
    type: str
    description: Optional[str] = ""
class DisplayPropertiesModel(BaseModel):
    color: Optional[str] = "#6c757d"  # default secondary color
    text_color: Optional[str] = "#FFFFFF"
class ManifestModel(BaseModel):
    id: str
    name: str
    author: str
    description: str
    type: str # e.g., "ACTION", "LOGIC", "DASHBOARD_WIDGET"
    entry_point: str
    version: Optional[str] = "1.0"
    requires_input: Optional[bool] = True
    properties: List[PropertyModel] = Field(default_factory=list)
    output_ports: List[PortModel] = Field(default_factory=list)
    requires_services: List[str] = Field(default_factory=list)
    permissions: List[str] = Field(default_factory=list)
    output_schema: List[OutputSchemaModel] = Field(default_factory=list)
    display_properties: Optional[DisplayPropertiesModel] = Field(default_factory=DisplayPropertiesModel)
    is_system: Optional[bool] = False # For widgets
    config_ui_entry_point: Optional[str] = None # For triggers
    is_service: Optional[bool] = False # For service plugins
    main_processor_file: Optional[str] = None
    dependencies_file: Optional[str] = None
    supported_languages: List[str] = Field(default_factory=list)
    is_paused: Optional[bool] = False
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\models\NodeModel.py
# JUMLAH BARIS : 23
#######################################################################

```py
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any
from uuid import UUID, uuid4
class NodeModel(BaseModel):
    """
    Represents the data structure for a single node in a workflow.
    Ensures that every node has a consistent and valid set of attributes.
    """
    id: UUID = Field(default_factory=uuid4)
    name: str
    x: float
    y: float
    module_id: str
    description: Optional[str] = ""
    config_values: Dict[str, Any] = Field(default_factory=dict)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\models\WorkflowPayloadModel.py
# JUMLAH BARIS : 19
#######################################################################

```py
from pydantic import BaseModel, Field
from typing import Dict, Any, List
class WorkflowPayloadModel(BaseModel):
    """
    Defines the standard structure for the payload object that flows
    between nodes in a workflow.
    This ensures that the payload always contains a 'data' dictionary
    and a 'history' list, preventing unexpected KeyError exceptions.
    """
    data: Dict[str, Any] = Field(default_factory=dict)
    history: List[Any] = Field(default_factory=list)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\base_service.py
# JUMLAH BARIS : 39
#######################################################################

```py
class BaseService:
    """
    The base class for all services in the Flowork ecosystem.
    Each service inherits from this class to ensure it has a consistent
    initialization method and can be managed by the Kernel's lifecycle.
    """
    def __init__(self, kernel, service_id: str):
        """
        Initializes the service.
        Args:
            kernel: The main Kernel instance, providing access to other services and core functions.
            service_id (str): The unique identifier for this service, as defined in services.json.
        """
        self.kernel = kernel
        self.service_id = service_id
        self.logger = self.kernel.write_to_log # (ADDED) Logger is now fundamental for all services
        self.loc = None # Will be available after localization_manager is loaded
        if 'localization_manager' in self.kernel.services:
            self.loc = self.kernel.get_service('localization_manager')
    def start(self):
        """
        Optional method to start any background tasks or long-running processes.
        Called by the Kernel during the startup sequence.
        """
        pass
    def stop(self):
        """
        Optional method to gracefully stop any background tasks before the application closes.
        Called by the Kernel during the shutdown sequence.
        """
        pass
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\agent_executor_service\agent_executor_service.py
# JUMLAH BARIS : 113
#######################################################################

```py
import threading
import json
import time
import re
import os
from ..base_service import BaseService
class AgentExecutorService(BaseService):
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.module_manager = self.kernel.get_service("module_manager_service")
        self.workflow_executor = self.kernel.get_service("workflow_executor_service")
        self.ai_manager = self.kernel.get_service("ai_provider_manager_service")
        self.kernel.write_to_log("Service 'AgentExecutor' initialized.", "DEBUG")
    def run_dynamic_agent_synchronous(self, initial_payload: dict, full_prompt_template: str, connected_tools: list, ai_brain_endpoint: str, status_updater, agent_display_updater=lambda text: None, agent_tool_highlighter=lambda node_id: None):
        self.logger(f"Starting synchronous dynamic agent run.", "INFO")
        current_payload = initial_payload.copy()
        if 'data' not in current_payload or not isinstance(current_payload['data'], dict):
            current_payload['data'] = {}
        conversation_history = []
        last_observation = "No actions taken yet."
        max_steps = 10
        tools_prompt_string = self._get_tools_prompt_from_nodes(connected_tools)
        objective = current_payload.get('data', {}).get('prompt', 'No objective provided in payload.')
        for i in range(max_steps):
            status_updater(f"Cycle {i+1}/{max_steps}: Thinking...", "INFO")
            agent_display_updater(f"🤔 Thinking...\n(Cycle {i+1}/{max_steps})")
            prompt_to_brain = full_prompt_template
            prompt_to_brain = prompt_to_brain.replace('{objective}', objective)
            prompt_to_brain = prompt_to_brain.replace('{tools_string}', tools_prompt_string)
            prompt_to_brain = prompt_to_brain.replace('{history}', json.dumps(conversation_history, indent=2))
            prompt_to_brain = prompt_to_brain.replace('{last_observation}', last_observation)
            self.logger(f"Sending prompt to brain: {ai_brain_endpoint}", "DEBUG")
            ai_response = self.ai_manager.query_ai_by_task('text', prompt_to_brain, endpoint_id=ai_brain_endpoint)
            if "error" in ai_response:
                last_observation = f"AI Brain Error: {ai_response['error']}"
                self.logger(f"Error during agent cycle: {last_observation}", "ERROR")
                conversation_history.append({"role": "user", "content": f"Observation: {last_observation}"})
                agent_display_updater(f"❌ Brain Error:\n{ai_response['error']}")
                continue
            action_json_str = ai_response.get('data', '{}')
            self.logger(f"Brain response received: {action_json_str}", "DETAIL")
            try:
                json_match = re.search(r'\{[\s\S]*\}', action_json_str)
                if not json_match:
                    raise json.JSONDecodeError("No valid JSON object found in the AI's response.", action_json_str, 0)
                clean_json_str = json_match.group(0)
                action_data = json.loads(clean_json_str)
                thought = action_data.get("thought", action_data.get("thoughts", "No thought provided."))
                action = action_data.get("action", {})
                tool_to_use = action.get("tool_id")
                tool_data = action.get("data", {})
                conversation_history.append({"role": "assistant", "content": action_json_str})
                status_updater(f"Thought: {thought}", "INFO")
                agent_display_updater(f"💡 Thought:\n{thought}")
                if tool_to_use == "finish":
                    final_answer = action.get('final_answer', "Objective complete.")
                    status_updater(f"Agent decided the objective is complete.", "SUCCESS")
                    agent_display_updater(f"✅ Finished:\n{final_answer}")
                    return final_answer, conversation_history
                if not tool_to_use:
                    raise ValueError("AI brain failed to select a valid tool.")
                status_updater(f"Action: Using tool '{tool_to_use}'", "INFO")
                agent_display_updater(f"🛠️ Using Tool: {tool_to_use}\nData: {json.dumps(tool_data, indent=2)}")
                node_to_run = next((t for t in connected_tools if t.get('module_id') == tool_to_use), None)
                if not node_to_run:
                    raise ValueError(f"Tool '{tool_to_use}' was chosen by the AI, but it is not connected to the Agent Host.")
                agent_tool_highlighter(node_to_run['id'])
                time.sleep(0.5)
                payload_for_tool = current_payload.copy()
                if 'data' not in payload_for_tool or not isinstance(payload_for_tool.get('data'), dict):
                    payload_for_tool['data'] = {}
                payload_for_tool['data'].update(tool_data)
                result_from_tool = self.workflow_executor.execute_workflow_synchronous(
                    nodes={node_to_run['id']: node_to_run},
                    connections={},
                    initial_payload=payload_for_tool, # (MODIFIED) Pass the freshly prepared payload
                    logger=self.logger,
                    status_updater=lambda a,b,c: self.logger(f"Tool Status Update: {b} - {c}", "DETAIL"),
                    highlighter=lambda a,b: None,
                    ui_callback=lambda func, *a: func(*a),
                    workflow_context_id=f"agent_host_step_{i}",
                    mode='EXECUTE',
                    job_status_updater=None
                )
                if isinstance(result_from_tool, Exception):
                    raise result_from_tool
                if isinstance(result_from_tool, dict) and "payload" in result_from_tool:
                    current_payload = result_from_tool["payload"]
                last_observation = json.dumps(current_payload, default=str)
                conversation_history.append({"role": "user", "content": f"Observation: {last_observation}"})
            except Exception as e:
                last_observation = f"An error occurred: {e}"
                self.logger(f"Error during agent cycle: {e}", "ERROR")
                conversation_history.append({"role": "user", "content": f"Observation: {last_observation}"})
                agent_display_updater(f"❌ Error:\n{e}")
        return "Max steps reached.", conversation_history
    def _get_tools_prompt_from_nodes(self, tool_nodes: list) -> str:
        tools_list = []
        for node_data in tool_nodes:
            manifest = self.module_manager.get_manifest(node_data.get('module_id'))
            if manifest:
                tools_list.append(
                    f"- tool_id: {manifest.get('id')}\n  name: {manifest.get('name')}\n  description: {manifest.get('description')}"
                )
        return "\n".join(tools_list)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\agent_manager_service\agent_manager_service.py
# JUMLAH BARIS : 54
#######################################################################

```py
from ..base_service import BaseService
from flowork_kernel.models.AgentModel import AgentModel
import uuid
class AgentManagerService(BaseService):
    """
    Manages the lifecycle (CRUD) of AI Agents within the Flowork ecosystem.
    """
    STATE_KEY = "ai_agents"
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.state_manager = self.kernel.get_service("state_manager")
        self.kernel.write_to_log("Service 'AgentManager' initialized.", "DEBUG")
    def get_all_agents(self) -> list[dict]:
        """Returns a list of all configured agents."""
        agents_dict = self.state_manager.get(self.STATE_KEY, {})
        return list(agents_dict.values())
    def get_agent(self, agent_id: str) -> dict | None:
        """Retrieves a single agent by its ID."""
        agents_dict = self.state_manager.get(self.STATE_KEY, {})
        return agents_dict.get(str(agent_id))
    def save_agent(self, agent_data: dict) -> dict:
        """Creates or updates an agent."""
        try:
            if 'id' not in agent_data or not agent_data['id']:
                agent_data['id'] = str(uuid.uuid4())
            else:
                agent_data['id'] = str(agent_data['id'])
            agent_model = AgentModel(**agent_data)
            agents_dict = self.state_manager.get(self.STATE_KEY, {})
            agents_dict[str(agent_model.id)] = agent_model.model_dump(mode='json')
            self.state_manager.set(self.STATE_KEY, agents_dict)
            self.kernel.write_to_log(f"Agent '{agent_model.name}' saved with ID {agent_model.id}", "SUCCESS")
            return agent_model.model_dump(mode='json')
        except Exception as e:
            self.kernel.write_to_log(f"Failed to save agent: {e}", "ERROR")
            return {"error": str(e)}
    def delete_agent(self, agent_id: str) -> bool:
        """Deletes an agent by its ID."""
        agents_dict = self.state_manager.get(self.STATE_KEY, {})
        if agent_id in agents_dict:
            del agents_dict[agent_id]
            self.state_manager.set(self.STATE_KEY, agents_dict)
            self.kernel.write_to_log(f"Agent with ID {agent_id} has been deleted.", "INFO")
            return True
        self.kernel.write_to_log(f"Attempted to delete non-existent agent with ID {agent_id}.", "WARN")
        return False
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\ai_analyzer_service\ai_analyzer_service.py
# JUMLAH BARIS : 217
#######################################################################

```py
import os
import json
import threading
import re
import hashlib
import traceback
import sys
import subprocess
from ..base_service import BaseService
try:
    from llama_cpp import Llama
    LLAMA_CPP_AVAILABLE = True
except ImportError:
    LLAMA_CPP_AVAILABLE = False
class AIAnalyzerService(BaseService):
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.state_manager = self.kernel.get_service("state_manager")
        self.preset_manager = self.kernel.get_service("preset_manager_service")
        self.event_bus = self.kernel.get_service("event_bus")
        self.kernel.write_to_log("Service 'AIAnalyzerService' initialized.", "DEBUG")
    def start(self):
        self.kernel.write_to_log("AI Co-pilot (New Pattern Analyzer) is ready and waiting for events.", "SUCCESS")
    def stop(self):
        pass
    def request_analysis(self, context_id: str):
        analysis_thread = threading.Thread(target=self._run_analysis, args=(context_id,), daemon=True)
        analysis_thread.start()
    def _run_analysis(self, context_id: str):
        if not self.kernel.is_tier_sufficient('pro'):
            return
        if self.event_bus:
            self.event_bus.publish("AI_ANALYSIS_STARTED", {"message": "AI Co-pilot is analyzing..."})
        self.kernel.write_to_log(f"AI Co-pilot: Analysis request received for context '{context_id}'.", "INFO")
        try:
            preset_name = self.state_manager.get(f"tab_preset_map::{context_id}")
            if not preset_name or not self.preset_manager:
                return
            preset_data = self.preset_manager.get_preset_data(preset_name)
            if not preset_data: return
            active_master_ai_id = self.loc.get_setting("ai_model_for_text")
            logical_structure = {
                'nodes': [{k: v for k, v in node.items() if k not in ['x', 'y']} for node in preset_data.get('nodes', [])],
                'connections': preset_data.get('connections', [])
            }
            workflow_str = json.dumps(logical_structure, sort_keys=True) + str(active_master_ai_id)
            workflow_hash = hashlib.md5(workflow_str.encode('utf-8')).hexdigest()
            cache_key = f"ai_suggestion::{preset_name}::{workflow_hash}"
            cached_suggestions = self.state_manager.get(cache_key)
            if cached_suggestions is not None:
                is_cache_valid = False
                try:
                    json_matches = re.findall(r'\{[\s\S]*?\}', cached_suggestions)
                    if json_matches:
                        for match in json_matches:
                            json.loads(match)
                        is_cache_valid = True
                except (json.JSONDecodeError, AttributeError, TypeError):
                    is_cache_valid = False
                if is_cache_valid:
                    self.kernel.write_to_log(f"AI Co-pilot: CACHE HIT for preset '{preset_name}' (AI: {os.path.basename(str(active_master_ai_id))}).", "INFO")
                    self._process_and_publish_ai_suggestions(cached_suggestions, context_id)
                    return
                else:
                    self.kernel.write_to_log(f"AI Co-pilot: Corrupt cache detected for '{preset_name}'. Deleting and re-analyzing.", "WARN")
                    self.state_manager.delete(cache_key)
            self.kernel.write_to_log(f"AI Co-pilot: CACHE MISS for preset '{preset_name}' (AI: {os.path.basename(str(active_master_ai_id))}). Analyzing...", "WARN")
            metrics_for_context = self._get_metrics_for_context(context_id)
            history_summary = self._summarize_metrics(metrics_for_context)
            if history_summary:
                if not active_master_ai_id:
                    raise ConnectionError("No default AI for Text is configured in Settings for Co-pilot analysis.")
                analysis_prompt = self._create_analysis_prompt(history_summary)
                ai_manager = self.kernel.get_service("ai_provider_manager_service")
                self.kernel.write_to_log(f"AI Co-pilot: Sending prompt to default Text AI for analysis.", "INFO")
                ai_response = ai_manager.query_ai_by_task('text', analysis_prompt)
                if "error" in ai_response:
                    raise ConnectionError(f"AI Co-pilot analysis failed: {ai_response['error']}")
                raw_suggestions = ai_response.get("data", "[]")
                self.state_manager.set(cache_key, raw_suggestions)
                self.kernel.write_to_log(f"AI Co-pilot: New suggestions for '{preset_name}' saved to cache.", "INFO")
                self._process_and_publish_ai_suggestions(raw_suggestions, context_id)
        except subprocess.TimeoutExpired:
            error_msg = f"AI Worker process for model '{os.path.basename(str(active_master_ai_id))}' timed out. The model may be too large for your hardware, or you can increase the timeout in settings."
            self.kernel.write_to_log(error_msg, "CRITICAL")
        except Exception as e:
            self.kernel.write_to_log(f"AI Co-pilot analysis thread encountered an error: {e}", "ERROR")
            traceback.print_exc()
        finally:
            if self.event_bus:
                self.event_bus.publish("AI_ANALYSIS_FINISHED", {})
    def invalidate_suggestion_cache(self, preset_name: str):
        if not self.preset_manager or not self.state_manager: return
        try:
            preset_data = self.preset_manager.get_preset_data(preset_name)
            if not preset_data: return
            active_master_ai_id = self.loc.get_setting("ai_model_for_text", "default_ai")
            logical_structure = {
                'nodes': [{k: v for k, v in node.items() if k not in ['x', 'y']} for node in preset_data.get('nodes', [])],
                'connections': preset_data.get('connections', [])
            }
            workflow_str = json.dumps(logical_structure, sort_keys=True) + str(active_master_ai_id)
            workflow_hash = hashlib.md5(workflow_str.encode('utf-8')).hexdigest()
            cache_key = f"ai_suggestion::{preset_name}::{workflow_hash}"
            self.state_manager.delete(cache_key)
            self.kernel.write_to_log(f"AI suggestion cache invalidated for preset '{preset_name}'.", "INFO")
        except Exception as e:
            self.kernel.write_to_log(f"Failed to invalidate suggestion cache for '{preset_name}': {e}", "WARN")
    def _suggestion_publisher(self, message, level, context=None):
        if level in ["WARN", "ERROR", "CRITICAL", "MINOR"]:
            if context is None: context = {}
            suggestion_text = re.sub(r'\s*\[\w+\]\s*->\s*', '', message)
            event_payload = {
                "preset_name": context.get("preset_name", "N/A"),
                "node_id": context.get("node_id", "N/A"),
                "node_name": context.get("node_name", "N/A"),
                "suggestion_text": suggestion_text,
                "severity": level
            }
            if event_payload["node_id"] != "N/A":
                if self.event_bus:
                    self.event_bus.publish("OPTIMIZATION_SUGGESTION_FOUND", event_payload)
    def _get_metrics_for_context(self, target_context_id: str) -> list:
        try:
            history_file_path = os.path.join(self.kernel.data_path, "metrics_history.jsonl")
            with open(history_file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            relevant_metrics = []
            for line in lines:
                try:
                    log_entry = json.loads(line)
                    metric = log_entry.get("metrics", {})
                    if metric.get('workflow_context_id') == target_context_id:
                        relevant_metrics.append(metric)
                except json.JSONDecodeError:
                    continue
            return relevant_metrics
        except FileNotFoundError:
            return []
    def _summarize_metrics(self, metrics: list) -> str:
        if not metrics:
            return "The workflow execution completed successfully with no metrics recorded. Please confirm this is expected."
        MAX_METRICS_TO_SUMMARIZE = 50
        if len(metrics) > MAX_METRICS_TO_SUMMARIZE:
            self.kernel.write_to_log(f"Metrics history is too long ({len(metrics)} entries). Truncating to the last {MAX_METRICS_TO_SUMMARIZE} for AI analysis.", "WARN")
            metrics = metrics[-MAX_METRICS_TO_SUMMARIZE:]
        execution_sequence = " -> ".join([f"{m.get('node_name', '?')} (ID: {m.get('node_id')})" for m in metrics])
        error_nodes = [
            f"- Node '{m.get('node_name')}' (ID: {m.get('node_id')}) FAILED."
            for m in metrics if m.get('status') == 'ERROR'
        ]
        slow_nodes = [
            f"- Node '{m.get('node_name')}' (ID: {m.get('node_id')}) was slow, taking {m.get('execution_time_ms', 0):.0f} ms."
            for m in metrics if m.get('execution_time_ms', 0) > 2000
        ]
        summary_parts = [f"Execution Sequence: {execution_sequence}"]
        if error_nodes:
            summary_parts.append("\nErrors Detected:")
            summary_parts.extend(error_nodes)
        if slow_nodes:
            summary_parts.append("\nPerformance Issues:")
            summary_parts.extend(slow_nodes)
        if not error_nodes and not slow_nodes:
            summary_parts.append("\nAnalysis: All nodes executed successfully without any obvious errors or performance delays.")
        total_nodes = len(metrics)
        summary_parts.append(f"\nSummary: {total_nodes} nodes executed. {len(error_nodes)} failed, {len(slow_nodes)} were slow.")
        return "\n".join(summary_parts)
    def _create_analysis_prompt(self, summary_text: str) -> str:
        return self.loc.get(
            'ai_copilot_prompt',
            fallback="Please analyze the following text: {summary_text}",
            summary_text=summary_text
        )
    def _process_and_publish_ai_suggestions(self, raw_data, context_id):
        if not self.state_manager: return
        open_tabs = self.state_manager.get("open_tabs", [])
        open_tab_ids = {tab.get('tab_id') for tab in open_tabs}
        if context_id not in open_tab_ids:
            return
        suggestions = []
        try:
            json_matches = re.findall(r'\{[\s\S]*?\}', raw_data)
            if not json_matches:
                self.kernel.write_to_log(f"AI Co-pilot could not find any valid JSON object in the response: {raw_data}", "WARN")
                return
            for match_str in json_matches:
                try:
                    suggestion_obj = json.loads(match_str)
                    suggestions.append(suggestion_obj)
                except json.JSONDecodeError:
                    self.kernel.write_to_log(f"AI Co-pilot found a malformed JSON object, skipping: {match_str}", "DEBUG")
                    continue
            if not suggestions:
                self.kernel.write_to_log(f"AI Co-pilot found JSON-like blocks but failed to parse any of them as valid suggestions.", "WARN")
                return
            self.kernel.write_to_log(f"AI Co-pilot successfully parsed {len(suggestions)} new suggestions from the master AI.", "SUCCESS")
            for suggestion in suggestions:
                if all(k in suggestion for k in ['node_name', 'node_id', 'suggestion']):
                    preset_name_from_state = self.state_manager.get(f"tab_preset_map::{context_id}", "N/A")
                    context = {
                        "preset_name": preset_name_from_state,
                        "node_id": suggestion.get('node_id'),
                        "node_name": suggestion['node_name']
                    }
                    self._suggestion_publisher(suggestion['suggestion'], "WARN", context)
                else:
                    self.kernel.write_to_log(f"AI Co-pilot skipped a suggestion object due to missing keys: {suggestion}", "WARN")
        except Exception as e:
             self.kernel.write_to_log(f"A critical error occurred in _process_and_publish_ai_suggestions: {e}", "ERROR")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\ai_architect_service\ai_architect_service.py
# JUMLAH BARIS : 100
#######################################################################

```py
import json
import os
import re
from ..base_service import BaseService
try:
    from llama_cpp import Llama
    LLAMA_CPP_AVAILABLE = True
except ImportError:
    LLAMA_CPP_AVAILABLE = False
class AiArchitectService(BaseService):
    """
    [MODIFIKASI] Menambah ukuran context window untuk model lokal.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.module_manager = self.kernel.get_service("module_manager_service")
        self.ai_manager = self.kernel.get_service("ai_provider_manager_service")
        self.kernel.write_to_log("Service 'AiArchitectService' initialized.", "DEBUG")
    def _get_available_tools_prompt(self):
        if not self.module_manager:
            return "No tools available."
        tools = []
        for mod_id, mod_data in self.module_manager.loaded_modules.items():
            manifest = mod_data.get("manifest", {})
            if manifest.get("type") not in ["LOGIC", "ACTION", "CONTROL_FLOW"]:
                continue
            if "ui_provider" in manifest.get("permissions", []):
                continue
            tool_info = f"- module_id: {mod_id}\n  name: {manifest.get('name')}\n  description: {manifest.get('description')}"
            tools.append(tool_info)
        return "\n".join(tools)
    def generate_workflow_from_prompt(self, user_prompt: str):
        if not self.ai_manager:
            raise ConnectionError("AIProviderManagerService is not available.")
        available_tools = self._get_available_tools_prompt()
        system_prompt = f"""
You are an expert Flowork workflow architect. Your task is to design a workflow based on the user's request.
You have the following modules (tools) available to you:
--- AVAILABLE TOOLS ---
{available_tools}
--- END OF TOOLS ---
Based on the user's request, you must return ONLY a valid JSON object.
The JSON object must have two keys: "nodes" and "connections".
- The "nodes" array should contain objects, each with a unique "id" (use a placeholder like "node_1", "node_2"), "name", "module_id" (from the tool list), and initial x/y coordinates.
- The "connections" array should contain objects connecting the nodes using their placeholder IDs in the "from" and "to" fields.
- The first node should ALWAYS be the "set_variable_module" with the name "START".
Example of a valid response for a simple request:
{{
  "nodes": [
    {{
      "id": "node_1",
      "name": "START",
      "module_id": "set_variable_module",
      "x": 100,
      "y": 100
    }},
    {{
      "id": "node_2",
      "name": "Tampilkan Popup Sederhana",
      "module_id": "debug_popup_module",
      "x": 300,
      "y": 100
    }}
  ],
  "connections": [
    {{
      "from": "node_1",
      "to": "node_2"
    }}
  ]
}}
Now, design a workflow for the following user request. Remember to only use the tools provided and return ONLY the JSON object.
"""
        self.kernel.write_to_log("AI Architect is consulting the default Text AI...", "INFO")
        full_prompt = f"{system_prompt}\n\nUSER REQUEST: \"{user_prompt}\""
        response = self.ai_manager.query_ai_by_task('text', full_prompt)
        if "error" in response:
            raise ConnectionError(f"AI Architect failed: {response['error']}")
        response_text = response.get("data", "{}").strip()
        try:
            json_match = re.search(r'\{[\s\S]*\}', response_text)
            if not json_match:
                raise ValueError("No valid JSON object found in the AI's response.")
            json_string = json_match.group(0)
            workflow_graph = json.loads(json_string)
            if "nodes" not in workflow_graph or "connections" not in workflow_graph:
                raise ValueError("AI response is missing 'nodes' or 'connections' key.")
            self.kernel.write_to_log("AI Architect successfully generated a workflow graph.", "SUCCESS")
            return workflow_graph
        except (json.JSONDecodeError, ValueError) as e:
            self.kernel.write_to_log(f"AI Architect failed to parse the LLM response: {e}\nRaw response: {response_text}", "ERROR")
            raise ValueError(f"The AI returned an invalid workflow structure. Raw Response: {response_text}. Error: {e}")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\ai_provider_manager_service\ai_provider_manager_service.py
# JUMLAH BARIS : 346
#######################################################################

```py
import os
import json
import importlib.util
import subprocess
import sys
import importlib.metadata
import tempfile
import zipfile
import shutil
import traceback
import time
import hashlib # (ADDED) For hash checking
from ..base_service import BaseService
from flowork_kernel.utils.file_helper import sanitize_filename
try:
    import torch
    from diffusers import StableDiffusionXLPipeline, AutoencoderKL
    DIFFUSERS_AVAILABLE = True
except ImportError:
    DIFFUSERS_AVAILABLE = False
try:
    importlib.metadata.version('llama-cpp-python')
    LLAMA_CPP_AVAILABLE = True
except importlib.metadata.PackageNotFoundError:
    LLAMA_CPP_AVAILABLE = False
class AIProviderManagerService(BaseService):
    """
    (REMASTERED V5) Can now differentiate between local GGUF models and local HF/Diffusers models.
    It intelligently routes execution to the appropriate worker or internal handler.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.providers_path = os.path.join(self.kernel.project_root_path, "ai_providers")
        os.makedirs(self.providers_path, exist_ok=True)
        self.loaded_providers = {}
        self.local_models = {}
        self.hf_pipelines = {}
        self.image_output_dir = os.path.join(self.kernel.data_path, "generated_images_by_service")
        os.makedirs(self.image_output_dir, exist_ok=True)
        self.discover_and_load_endpoints()
    def query_ai_by_task(self, task_type: str, prompt: str, endpoint_id: str = None, **kwargs) -> dict:
        if endpoint_id:
            target_endpoint_id = endpoint_id
            self.kernel.write_to_log(f"AI Query by Task: Using specified endpoint '{target_endpoint_id}' for task '{task_type}'", "DEBUG") # English Log
        else:
            setting_key = f"ai_model_for_{task_type}"
            target_endpoint_id = self.loc.get_setting(setting_key) or self.loc.get_setting("ai_model_for_other")
            self.kernel.write_to_log(f"AI Query by Task: Using default endpoint '{target_endpoint_id}' for task '{task_type}'", "DEBUG") # English Log
        if not target_endpoint_id:
            return {"error": f"No default or specified AI model is configured for task type '{task_type}'."}
        if target_endpoint_id in self.loaded_providers:
            provider = self.get_provider(target_endpoint_id)
            if provider:
                is_ready, msg = provider.is_ready()
                if is_ready:
                    return provider.generate_response(prompt, **kwargs)
                else:
                    return {"error": f"Provider '{target_endpoint_id}' for task '{task_type}' is not ready: {msg}"}
            else:
                 return {"error": f"Provider '{target_endpoint_id}' not found although it is in loaded_providers list."}
        elif target_endpoint_id.startswith("(Local Model)"):
            model_info = self.local_models.get(target_endpoint_id)
            if not model_info:
                return {"error": f"Local model '{target_endpoint_id}' not found in the manager's index."}
            model_type = model_info.get('type')
            if model_type == 'gguf':
                if not LLAMA_CPP_AVAILABLE:
                    return {"error": "Library 'llama-cpp-python' is required to use local GGUF models."}
                model_full_path = model_info.get('full_path')
                if not model_full_path or not os.path.exists(model_full_path):
                    return {"error": f"Local model file not found at path: {model_full_path}"}
                try:
                    worker_path = os.path.join(self.kernel.project_root_path, "flowork_kernel", "workers", "ai_worker.py")
                    gpu_layers_setting = self.loc.get_setting("ai_gpu_layers", 40)
                    command = [sys.executable, worker_path, model_full_path, str(gpu_layers_setting)]
                    self.kernel.write_to_log(f"Delegating GGUF task to isolated AI worker for model '{os.path.basename(model_full_path)}'...", "INFO") # English Log
                    timeout_seconds = self.loc.get_setting("ai_worker_timeout_seconds", 300)
                    process = subprocess.run(command, input=prompt, capture_output=True, text=True, encoding='utf-8', errors='replace', timeout=timeout_seconds)
                    if process.returncode == 0:
                        return {"type": "text", "data": process.stdout}
                    else:
                        return {"type": "text", "data": f"ERROR: AI Worker process failed: {process.stderr}"}
                except Exception as e:
                    self.kernel.write_to_log(f"Error calling local GGUF worker: {e}", "CRITICAL") # English Log
                    return {"error": str(e)}
            elif model_type == 'hf_image_single_file':
                return self._run_single_file_image_model(model_info, prompt, **kwargs)
            else:
                return {"error": f"Unsupported local model type '{model_type}' for endpoint '{target_endpoint_id}'."}
        else:
            return {"error": f"Unsupported or unknown AI endpoint type for task '{task_type}': {target_endpoint_id}"}
    def _run_single_file_image_model(self, model_info, prompt, **kwargs):
        if not DIFFUSERS_AVAILABLE:
            return {"error": "Libraries 'diffusers', 'torch', 'Pillow' are required."}
        model_folder_name = model_info.get('name')
        try:
            pipeline = self.hf_pipelines.get(model_folder_name)
            if not pipeline:
                self.kernel.write_to_log(f"Loading HF pipeline for '{model_folder_name}' for the first time...", "INFO")
                model_path = model_info.get('full_path')
                device = "cuda" if torch.cuda.is_available() else "cpu"
                torch_dtype = torch.float16 if device == "cuda" else torch.float32
                vae_path = os.path.join(self.kernel.project_root_path, "ai_models", "vae", "sdxl-vae-fp16-fix")
                if not os.path.isdir(vae_path):
                     raise FileNotFoundError("VAE folder 'sdxl-vae-fp16-fix' not found in 'ai_models/vae'. This is crucial for quality.")
                vae = AutoencoderKL.from_pretrained(vae_path, torch_dtype=torch_dtype).to(device)
                safetensor_files = [f for f in os.listdir(model_path) if f.endswith(".safetensors")]
                if not safetensor_files:
                    raise FileNotFoundError(f"No .safetensors file found in '{model_path}'")
                full_model_path = os.path.join(model_path, safetensor_files[0])
                pipeline = StableDiffusionXLPipeline.from_single_file(
                    full_model_path,
                    vae=vae,
                    torch_dtype=torch_dtype,
                    variant="fp16" if device == "cuda" else "fp32"
                ).to(device)
                if device == "cuda":
                    pipeline.enable_model_cpu_offload()
                self.hf_pipelines[model_folder_name] = pipeline
            self.kernel.write_to_log(f"Generating image with '{model_folder_name}'...", "INFO")
            generation_params = {
                "prompt": prompt,
                "negative_prompt": kwargs.get('negative_prompt', 'blurry, worst quality, low quality'),
                "width": int(kwargs.get('width', 1024)),
                "height": int(kwargs.get('height', 1024)),
                "guidance_scale": float(kwargs.get('guidance_scale', 7.5)),
                "num_inference_steps": int(kwargs.get('num_inference_steps', 30))
            }
            image = pipeline(**generation_params).images[0]
            sanitized_prefix = sanitize_filename(prompt[:25])
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            filename = f"{sanitized_prefix}_{timestamp}.png"
            output_path = os.path.join(self.image_output_dir, filename)
            image.save(output_path)
            self.kernel.write_to_log(f"Image saved to: {output_path}", "SUCCESS")
            return {"type": "image", "data": output_path}
        except Exception as e:
            self.kernel.write_to_log(f"Error during local image generation: {e}\n{traceback.format_exc()}", "CRITICAL")
            return {"error": str(e)}
    def _calculate_requirements_hash(self, file_path):
        sha256_hash = hashlib.sha256()
        try:
            with open(file_path, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            return sha256_hash.hexdigest()
        except IOError:
            return None
    def _install_dependencies(self, provider_dir, provider_name):
        requirements_path = os.path.join(provider_dir, 'requirements.txt')
        if not os.path.exists(requirements_path):
            return True # Success, nothing to install
        vendor_path = os.path.join(provider_dir, 'vendor')
        hash_file_path = os.path.join(provider_dir, '.vendor_hash')
        current_hash = self._calculate_requirements_hash(requirements_path)
        if os.path.isdir(vendor_path) and os.path.exists(hash_file_path):
            try:
                with open(hash_file_path, 'r') as f:
                    saved_hash = f.read().strip()
                if saved_hash == current_hash:
                    return True
            except IOError:
                pass
        self.kernel.write_to_log(f"AIProvider '{provider_name}' has local dependencies. Installing into its 'vendor' folder...", "INFO") # English Log
        if os.path.isdir(vendor_path):
            shutil.rmtree(vendor_path, ignore_errors=True)
        try:
            python_exe = sys.executable
            command = [
                python_exe, "-m", "pip", "install", "--target", vendor_path,
                "-r", requirements_path, "--no-user", "--disable-pip-version-check"
            ]
            creation_flags = 0
            if sys.platform == "win32":
                creation_flags = subprocess.CREATE_NO_WINDOW
            subprocess.run(command, check=True, capture_output=True, creationflags=creation_flags)
            with open(hash_file_path, 'w') as f:
                f.write(current_hash)
            self.kernel.write_to_log(f"Successfully installed local dependencies for '{provider_name}'.", "SUCCESS") # English Log
            return True
        except subprocess.CalledProcessError as e:
            self.kernel.write_to_log(f"FAILED to install local dependencies for '{provider_name}'. Pip Error: {e.stderr.decode('utf-8', 'ignore')}", "CRITICAL") # English Log
            return False
        except Exception as e:
            self.kernel.write_to_log(f"An unexpected error occurred during local dependency installation for '{provider_name}': {e}", "CRITICAL") # English Log
            return False
    def discover_and_load_endpoints(self):
        self.kernel.write_to_log("--- STARTING AI ENDPOINT DISCOVERY (V5 - Type Aware) ---", "WARN") # English Log
        self.loaded_providers.clear()
        self.local_models.clear()
        self.hf_pipelines.clear()
        self.kernel.write_to_log(f"Scanning for AI Providers in: {self.providers_path}", "DEBUG") # English Log
        if self.providers_path not in sys.path:
            sys.path.insert(0, self.providers_path)
        for root, dirs, files in os.walk(self.providers_path):
            if 'manifest.json' in files:
                provider_dir = root
                provider_id = os.path.basename(provider_dir)
                category_name = os.path.basename(os.path.dirname(provider_dir))
                if provider_dir == self.providers_path or "__pycache__" in provider_dir:
                    continue
                try:
                    manifest_path = os.path.join(provider_dir, "manifest.json")
                    with open(manifest_path, 'r', encoding='utf-8') as f: manifest = json.load(f)
                    provider_name = manifest.get('name', provider_id)
                    entry_point = manifest.get('entry_point')
                    if not entry_point or '.' not in entry_point: continue
                    self.kernel.write_to_log(f"AIProviderManager: Checking dependencies for '{provider_name}'...", "DEBUG")
                    if not self._install_dependencies(provider_dir, provider_name): continue
                    vendor_path = os.path.join(provider_dir, 'vendor')
                    is_path_added = False
                    if os.path.isdir(vendor_path):
                        sys.path.insert(0, vendor_path)
                        is_path_added = True
                    try:
                        module_filename, class_name = entry_point.split('.')
                        module_path = os.path.join(provider_dir, f"{module_filename}.py")
                        if not os.path.exists(module_path): continue
                        full_module_name = f"ai_providers.{category_name}.{provider_id}.{module_filename}"
                        spec = importlib.util.spec_from_file_location(full_module_name, module_path)
                        module_lib = importlib.util.module_from_spec(spec)
                        sys.modules[full_module_name] = module_lib
                        spec.loader.exec_module(module_lib)
                        ProviderClass = getattr(module_lib, class_name)
                        self.loaded_providers[provider_id] = ProviderClass(self.kernel, manifest)
                        self.kernel.write_to_log(f"  -> AI Provider '{provider_name}' loaded.", "SUCCESS") # English Log
                    finally:
                        if is_path_added:
                            try:
                                sys.path.remove(vendor_path)
                            except ValueError:
                                pass
                except Exception as e:
                    self.kernel.write_to_log(f"  -> CRITICAL FAILURE loading provider '{provider_id}'. Error: {e}", "ERROR") # English Log
        ai_models_base_path = os.path.join(self.kernel.project_root_path, "ai_models")
        self.kernel.write_to_log(f"Scanning for Local AI Models in: {ai_models_base_path}", "DEBUG") # English Log
        if os.path.isdir(ai_models_base_path):
            for category in os.listdir(ai_models_base_path):
                category_path = os.path.join(ai_models_base_path, category)
                if not os.path.isdir(category_path): continue
                self.kernel.write_to_log(f"  -> Scanning category: '{category}'", "DETAIL") # English Log
                for item_name in os.listdir(category_path):
                    item_path = os.path.join(category_path, item_name)
                    model_id = f"(Local Model) {item_name}"
                    if os.path.isdir(item_path):
                        files_in_dir = os.listdir(item_path)
                        gguf_files = [f for f in files_in_dir if f.lower().endswith(".gguf")]
                        safetensor_files = [f for f in files_in_dir if f.lower().endswith(".safetensors")]
                        if gguf_files:
                            self.local_models[model_id] = {"full_path": os.path.join(item_path, gguf_files[0]), "type": 'gguf', "name": item_name}
                            self.kernel.write_to_log(f"    -> Found Local GGUF Model (in Folder): '{item_name}'", "SUCCESS") # English Log
                        elif safetensor_files and category == 'image':
                            self.local_models[model_id] = {"full_path": item_path, "type": 'hf_image_single_file', "name": item_name}
                            self.kernel.write_to_log(f"    -> Found Local Single-File Image Model (Folder): '{item_name}'", "SUCCESS") # English Log
                        else:
                            self.kernel.write_to_log(f"    -> Found generic local model folder (unsupported type): '{item_name}'", "WARN") # English Log
                    elif item_name.lower().endswith(".gguf"):
                        self.local_models[model_id] = {"full_path": item_path, "type": 'gguf', "name": item_name}
                        self.kernel.write_to_log(f"    -> Found Local GGUF Model (File): '{item_name}'", "SUCCESS") # English Log
        self.kernel.write_to_log(f"--- AI ENDPOINT DISCOVERY FINISHED ---", "WARN") # English Log
        self.kernel.write_to_log(f"Total endpoints available: {len(self.loaded_providers) + len(self.local_models)}", "SUCCESS") # English Log
    def get_provider(self, provider_id: str):
        return self.loaded_providers.get(provider_id)
    def get_available_providers(self) -> dict:
        provider_names = {}
        for provider_id, provider_instance in self.loaded_providers.items():
            provider_names[provider_id] = provider_instance.get_provider_name()
        for model_id, model_data in self.local_models.items():
            display_name = f"{model_data.get('name')} ({model_data.get('type', 'local').upper()})"
            provider_names[model_id] = display_name
        return provider_names
    def get_default_provider(self):
        loc = self.kernel.get_service("localization_manager")
        if loc:
            saved_provider_id = loc.get_setting("ai_center_master_provider")
            if saved_provider_id and saved_provider_id in self.loaded_providers:
                return self.loaded_providers[saved_provider_id]
        if self.loaded_providers:
            first_provider_key = next(iter(self.loaded_providers))
            first_provider = self.loaded_providers[first_provider_key]
            self.kernel.write_to_log(f"AI Manager: No master provider set. Falling back to first available: {first_provider.get_provider_name()}", "WARN") # English Log
            return first_provider
        return None
    def install_component(self, zip_filepath: str) -> (bool, str):
        with tempfile.TemporaryDirectory() as temp_dir:
            try:
                with zipfile.ZipFile(zip_filepath, 'r') as zip_ref:
                    zip_ref.extractall(temp_dir)
                component_root_path = None
                if os.path.exists(os.path.join(temp_dir, 'manifest.json')):
                    component_root_path = temp_dir
                else:
                    dir_items = [d for d in os.listdir(temp_dir) if os.path.isdir(os.path.join(temp_dir, d))]
                    if len(dir_items) == 1:
                        potential_path = os.path.join(temp_dir, dir_items[0])
                        if os.path.exists(os.path.join(potential_path, 'manifest.json')):
                            component_root_path = potential_path
                if not component_root_path:
                    return False, "manifest.json not found in the root of the zip archive or in a single subdirectory."
                with open(os.path.join(component_root_path, 'manifest.json'), 'r', encoding='utf-8') as f:
                    manifest = json.load(f)
                required_tier = manifest.get('tier', 'free')
                if not self.kernel.is_tier_sufficient(required_tier):
                    error_msg = f"Installation failed. This AI Provider requires a '{required_tier.capitalize()}' license."
                    return False, error_msg
                component_id = manifest.get('id')
                if not component_id:
                    return False, "Component 'id' is missing from manifest.json."
                component_category = manifest.get('category', 'specialized')
                self.kernel.write_to_log(f"Installing '{component_id}' to category '{component_category}' based on manifest.", "INFO") # English Log
                category_path = os.path.join(self.providers_path, component_category)
                os.makedirs(category_path, exist_ok=True)
                final_path = os.path.join(category_path, component_id)
                if os.path.exists(final_path):
                    return False, f"AI Provider '{component_id}' is already installed."
                shutil.move(component_root_path, final_path)
                return True, f"AI Provider '{manifest.get('name', component_id)}' installed successfully."
            except Exception as e:
                return False, f"An error occurred during AI Provider installation: {e}"
    def _find_component_path(self, component_id: str) -> str | None:
        for category_name in os.listdir(self.providers_path):
            category_path = os.path.join(self.providers_path, category_name)
            if os.path.isdir(category_path):
                potential_path = os.path.join(category_path, component_id)
                if os.path.isdir(potential_path):
                    return potential_path
        return None
    def uninstall_component(self, component_id: str) -> (bool, str):
        component_path = self._find_component_path(component_id)
        if not component_path:
            return False, f"Path for AI Provider '{component_id}' not found in any category."
        try:
            shutil.rmtree(component_path)
            if component_id in self.loaded_providers:
                del self.loaded_providers[component_id]
            return True, f"AI Provider '{component_id}' uninstalled successfully."
        except Exception as e:
            return False, f"Could not delete AI Provider folder: {e}"
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\ai_training_service\ai_training_service.py
# JUMLAH BARIS : 119
#######################################################################

```py
import os
import threading
import uuid
from ..base_service import BaseService
import sys # (DITAMBAHKAN)
import tempfile # (DITAMBAHKAN)
try:
    from transformers import AutoTokenizer, AutoModelForCausalLM, Trainer, TrainingArguments, TextDataset, DataCollatorForLanguageModeling
    TRANSFORMERS_AVAILABLE = True
except ImportError:
    TRANSFORMERS_AVAILABLE = False
class AITrainingService(BaseService):
    """
    Manages the AI model fine-tuning process.
    [UPGRADED] Can now continue fine-tuning an existing model if the provided model name already exists.
    [FIXED] Redirects stdout/stderr during training to prevent crashes in GUI mode.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.logger = self.kernel.write_to_log
        if not TRANSFORMERS_AVAILABLE:
            self.logger("AITrainingService: CRITICAL - 'transformers' library not found. Fine-tuning will not be available.", "CRITICAL")
        self.dataset_manager = self.kernel.get_service("dataset_manager_service")
        self.training_jobs = {}
        self.job_lock = threading.Lock()
    def start_fine_tuning_job(self, base_model_id: str, dataset_name: str, new_model_name: str, training_args: dict):
        if not TRANSFORMERS_AVAILABLE:
            return {"error": "Transformers library is not installed."}
        if self.job_lock.locked():
            return {"error": "Another training job is already in progress. Please wait for it to complete."}
        self.job_lock.acquire()
        job_id = f"ft-{uuid.uuid4()}"
        self.training_jobs[job_id] = { "status": "QUEUED", "progress": 0, "message": "Job has been queued.", "base_model": base_model_id, "dataset": dataset_name, "new_model_name": new_model_name }
        thread = threading.Thread( target=self._training_worker, args=(job_id, base_model_id, dataset_name, new_model_name, training_args), daemon=True )
        thread.start()
        self.logger(f"Started fine-tuning job {job_id} for model '{new_model_name}'.", "INFO")
        return {"job_id": job_id}
    def get_job_status(self, job_id: str):
        return self.training_jobs.get(job_id, {"error": "Job not found."})
    def _training_worker(self, job_id, base_model_id, dataset_name, new_model_name, training_args):
        """The core worker function that runs the fine-tuning process."""
        original_stdout = sys.stdout
        original_stderr = sys.stderr
        temp_log_path = os.path.join(tempfile.gettempdir(), f"flowork-train-{job_id}.log")
        try:
            with open(temp_log_path, 'w', encoding='utf-8') as log_file:
                sys.stdout = log_file
                sys.stderr = log_file
                self.training_jobs[job_id]["status"] = "PREPARING"
                self.training_jobs[job_id]["message"] = "Preparing dataset and paths..."
                output_dir = os.path.join(self.kernel.project_root_path, "ai_models", "text", new_model_name)
                model_to_load_path = ""
                if os.path.isdir(output_dir):
                    self.logger(f"Continue training existing model: '{new_model_name}'", "WARN")
                    model_to_load_path = output_dir
                else:
                    self.logger(f"Starting new training from base model: '{base_model_id}'", "INFO")
                    model_to_load_path = os.path.join(self.kernel.project_root_path, "ai_models", "text", base_model_id)
                if not os.path.isdir(model_to_load_path):
                    raise FileNotFoundError(f"Base model directory not found: {model_to_load_path}")
                dataset_data = self.dataset_manager.get_dataset_data(dataset_name)
                if not dataset_data:
                    raise ValueError(f"Dataset '{dataset_name}' is empty or not found.")
                temp_folder = os.path.join(self.kernel.data_path, "temp_training_files")
                hf_cache_dir = os.path.join(self.kernel.data_path, "hf_cache")
                os.makedirs(temp_folder, exist_ok=True)
                os.makedirs(hf_cache_dir, exist_ok=True)
                os.environ['TRANSFORMERS_CACHE'] = hf_cache_dir
                temp_file_path = os.path.join(temp_folder, f"temp_train_{job_id}.txt")
                with open(temp_file_path, 'w', encoding='utf-8') as f:
                    for item in dataset_data:
                        f.write(f"{item['prompt']}\n{item['response']}\n")
                self.training_jobs[job_id]["message"] = "Loading base model and tokenizer..."
                tokenizer = AutoTokenizer.from_pretrained(model_to_load_path)
                model = AutoModelForCausalLM.from_pretrained(model_to_load_path)
                train_dataset = TextDataset( tokenizer=tokenizer, file_path=temp_file_path, block_size=128 )
                data_collator = DataCollatorForLanguageModeling( tokenizer=tokenizer, mlm=False )
                training_arguments = TrainingArguments(
                    output_dir=output_dir,
                    num_train_epochs=training_args.get('epochs', 1),
                    per_device_train_batch_size=training_args.get('batch_size', 4),
                    save_steps=10_000,
                    save_total_limit=2,
                    logging_steps=100,
                )
                self.training_jobs[job_id]["status"] = "TRAINING"
                self.training_jobs[job_id]["message"] = "Fine-tuning in progress..."
                trainer = Trainer( model=model, args=training_arguments, data_collator=data_collator, train_dataset=train_dataset )
                trainer.train()
                self.training_jobs[job_id]["message"] = "Saving final model..."
                trainer.save_model(output_dir)
                self.training_jobs[job_id]["status"] = "COMPLETED"
                self.training_jobs[job_id]["message"] = f"Fine-tuning complete. Model '{new_model_name}' saved/updated."
                self.logger(f"Job {job_id} completed successfully.", "SUCCESS")
        except Exception as e:
            error_msg = f"Training job {job_id} failed: {e}"
            self.logger(error_msg, "CRITICAL")
            self.training_jobs[job_id]["status"] = "FAILED"
            self.training_jobs[job_id]["message"] = str(e)
        finally:
            sys.stdout = original_stdout
            sys.stderr = original_stderr
            if os.path.exists(temp_log_path):
                with open(temp_log_path, 'r', encoding='utf-8') as f:
                    training_log_content = f.read()
                if self.training_jobs[job_id]["status"] == "FAILED":
                     self.logger(f"--- Full Training Log for Failed Job {job_id} ---\n{training_log_content}\n--- End of Log ---", "DETAIL")
                os.remove(temp_log_path)
            if 'temp_file_path' in locals() and os.path.exists(temp_file_path):
                os.remove(temp_file_path)
            self.job_lock.release()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\api_server_service.py
# JUMLAH BARIS : 274
#######################################################################

```py
import threading
import json
import uuid
import time
import os
import re
import importlib
import inspect
from urllib.parse import urlparse, unquote
from fastapi import FastAPI, Request, Depends, HTTPException, APIRouter, WebSocket
from starlette.websockets import WebSocketDisconnect
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.security import APIKeyHeader
import uvicorn
from ..base_service import BaseService
from flowork_kernel.exceptions import PermissionDeniedError
from .routes import (
    agent_routes, component_routes, dataset_routes, execution_routes,
    license_routes, model_routes, preset_routes, prompt_routes,
    settings_routes, system_routes, training_routes, trigger_routes,
    ui_state_routes, variable_routes,
    ui_routes
)
from .connection_manager import ConnectionManager
class ApiServerService(BaseService, threading.Thread):
    def __init__(self, kernel, service_id: str):
        BaseService.__init__(self, kernel, service_id)
        threading.Thread.__init__(self, daemon=True)
        self.app = FastAPI(title="Flowork API", version="1.0")
        self.app.service_instance = self
        self.server = None
        self.connection_manager = ConnectionManager()
        self._setup_error_handlers()
        self._setup_webhook_route()
        self._setup_websocket_route()
        self._setup_static_files()
        self.job_statuses = {}
        self.job_statuses_lock = threading.Lock()
        self.kernel.write_to_log("Service 'ApiServerService' initialized.", "DEBUG")
        self.core_component_ids = None
        self.loc = None
        self.variable_manager = None
        self.preset_manager = None
        self.state_manager = None
        self.trigger_manager = None
        self.scheduler_manager = None
        self.module_manager_service = None
        self.plugin_manager_service = None
        self.widget_manager_service = None
        self.trigger_manager_service = None
        self.ai_provider_manager_service = None
        self.addon_service = None
        self.db_service = None
        self.dataset_manager_service = None
        self.training_service = None
        self.converter_service = None
        self.agent_manager = None
        self.agent_executor = None
        self.prompt_manager_service = None
        self.diagnostics_service = None
    def _setup_error_handlers(self):
        @self.app.exception_handler(PermissionDeniedError)
        async def permission_denied_exception_handler(request: Request, exc: PermissionDeniedError):
            return JSONResponse(
                status_code=403,
                content={"error": f"Permission Denied: {exc}"},
            )
        @self.app.exception_handler(Exception)
        async def generic_exception_handler(request: Request, exc: Exception):
            self.kernel.write_to_log(f"Unhandled API Error: {exc}", "CRITICAL")
            return JSONResponse(
                status_code=500,
                content={"error": "An internal server error occurred.", "detail": str(exc)},
            )
    def _setup_webhook_route(self):
        @self.app.post("/webhook/{preset_name}", tags=["Webhooks"])
        async def trigger_webhook(preset_name: str, payload: dict):
            self.kernel.write_to_log(f"Webhook received for preset '{preset_name}'. Triggering execution...", "INFO")
            job_id = self.trigger_workflow_by_api(preset_name, payload)
            if job_id:
                return JSONResponse(
                    status_code=202,
                    content={"status": "accepted", "message": f"Workflow for preset '{preset_name}' has been queued.", "job_id": job_id}
                )
            else:
                raise HTTPException(status_code=404, detail=f"Preset '{preset_name}' not found.")
    def _setup_websocket_route(self):
        """
        ADDED: Defines the WebSocket endpoint for real-time connections.
        """
        @self.app.websocket("/ws/status")
        async def websocket_endpoint(websocket: WebSocket):
            await self.connection_manager.connect(websocket)
            try:
                while True:
                    await websocket.receive_text()
            except WebSocketDisconnect:
                self.connection_manager.disconnect(websocket)
    def _setup_static_files(self):
        """
        ADDED: Configures FastAPI to serve the web-based server manager.
        """
        server_ui_path = os.path.join(self.kernel.project_root_path, "server_ui")
        if not os.path.isdir(server_ui_path):
            self.kernel.write_to_log(f"Server Manager UI directory not found at {server_ui_path}", "WARN") # English Log
            return
        self.app.mount("/ui", StaticFiles(directory=server_ui_path), name="ui")
        @self.app.get("/", response_class=HTMLResponse, tags=["Server Manager"])
        async def serve_manager_ui():
            index_path = os.path.join(server_ui_path, "index.html")
            if os.path.exists(index_path):
                with open(index_path, 'r', encoding='utf-8') as f:
                    return HTMLResponse(content=f.read())
            raise HTTPException(status_code=404, detail="Server Manager index.html not found.")
    def start(self):
        self._load_dependencies()
        self._load_api_routes()
        self.core_component_ids = self._load_protected_component_ids()
        threading.Thread.start(self)
    def _safe_get_service(self, service_id):
        try:
            return self.kernel.get_service(service_id)
        except PermissionDeniedError:
            self.kernel.write_to_log(f"ApiServer dependency '{service_id}' unavailable due to license tier.", "WARN")
            return None
    def _load_dependencies(self):
        self.kernel.write_to_log("ApiServerService: Loading service dependencies...", "INFO")
        self.loc = self._safe_get_service("localization_manager")
        self.variable_manager = self._safe_get_service("variable_manager_service")
        self.preset_manager = self._safe_get_service("preset_manager_service")
        self.state_manager = self._safe_get_service("state_manager")
        self.trigger_manager = self._safe_get_service("trigger_manager_service")
        self.scheduler_manager = self._safe_get_service("scheduler_manager_service")
        self.module_manager_service = self._safe_get_service("module_manager_service")
        self.plugin_manager_service = self._safe_get_service("plugin_manager_service")
        self.widget_manager_service = self._safe_get_service("widget_manager_service")
        self.trigger_manager_service = self._safe_get_service("trigger_manager_service")
        self.ai_provider_manager_service = self._safe_get_service("ai_provider_manager_service")
        self.addon_service = self._safe_get_service("community_addon_service")
        self.db_service = self._safe_get_service("database_service")
        self.dataset_manager_service = self._safe_get_service("dataset_manager_service")
        self.training_service = self._safe_get_service("ai_training_service")
        self.converter_service = self._safe_get_service("model_converter_service")
        self.agent_manager = self._safe_get_service("agent_manager_service")
        self.agent_executor = self._safe_get_service("agent_executor_service")
        self.prompt_manager_service = self._safe_get_service("prompt_manager_service")
        self.diagnostics_service = self._safe_get_service("diagnostics_service")
        self.kernel.write_to_log("ApiServerService: All available service dependencies loaded.", "SUCCESS")
    def _load_api_routes(self):
        api_key_header = APIKeyHeader(name="X-API-Key", auto_error=True)
        def get_api_key(api_key: str = Depends(api_key_header)):
            expected_key = self.variable_manager.get_variable("FLOWORK_API_KEY")
            if not expected_key:
                 raise HTTPException(status_code=403, detail="API access is disabled. FLOWORK_API_KEY is not set.")
            if api_key == expected_key:
                return api_key
            else:
                raise HTTPException(status_code=401, detail="API Key is missing or invalid.")
        api_v1_router = APIRouter(prefix="/api/v1")
        protected_router = APIRouter(dependencies=[Depends(get_api_key)])
        self.kernel.write_to_log("ApiServer: Discovering and loading API routes...", "INFO")
        routers_to_protect = [
            agent_routes.router, component_routes.router, dataset_routes.router, execution_routes.router,
            license_routes.router, model_routes.router, preset_routes.router, prompt_routes.router,
            settings_routes.router, system_routes.router, training_routes.router, trigger_routes.router,
            ui_state_routes.router, variable_routes.router,
            ui_routes.router
        ]
        for router_instance in routers_to_protect:
            protected_router.include_router(router_instance)
            self.kernel.write_to_log(f"  -> Included protected router: {router_instance.tags[0] if router_instance.tags else 'Unnamed'}", "DEBUG")
        api_v1_router.include_router(system_routes.public_router)
        self.kernel.write_to_log("  -> Included public router: System Status", "DEBUG")
        api_v1_router.include_router(protected_router)
        self.app.include_router(api_v1_router)
        self.kernel.write_to_log("API route discovery complete.", "SUCCESS")
    def _load_protected_component_ids(self):
        protected_ids = set()
        config_path = os.path.join(self.kernel.data_path, "protected_components.txt")
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                protected_ids = {line.strip() for line in f if line.strip() and not line.startswith('#')}
            self.kernel.write_to_log(f"Loaded {len(protected_ids)} protected component IDs.", "INFO")
        except FileNotFoundError:
            self.kernel.write_to_log(f"Config 'protected_components.txt' not found. No components will be protected.", "WARN")
        except Exception as e:
            self.kernel.write_to_log(f"Could not load protected component IDs: {e}", "ERROR")
        return protected_ids
    def run(self):
        if not self.loc or not self.loc.get_setting('webhook_enabled', False):
            self.kernel.write_to_log("API server is disabled in settings.", "INFO")
            return
        host = "0.0.0.0"
        port = self.loc.get_setting('webhook_port', 8989)
        try:
            self.kernel.write_to_log(f"API server starting on http://{host}:{port}", "SUCCESS")
            config = uvicorn.Config(self.app, host=host, port=port, log_level="warning")
            self.server = uvicorn.Server(config)
            self.server.run()
        except Exception as e:
            self.kernel.write_to_log(f"An unexpected error occurred while starting the API server: {e}", "ERROR")
    def stop(self):
        if self.server and self.server.started:
            self.kernel.write_to_log("Stopping API server...", "INFO")
            self.server.should_exit = True
    def trigger_workflow_by_api(self, preset_name: str, initial_payload: dict = None) -> str | None:
        if not self.preset_manager:
            self.kernel.write_to_log(f"API Trigger failed: PresetManager service is not available.", "ERROR")
            return None
        preset_data = self.preset_manager.get_preset_data(preset_name)
        if not preset_data:
            self.kernel.write_to_log(f"API Trigger failed: preset '{preset_name}' not found or is empty.", "ERROR")
            return None
        job_id = str(uuid.uuid4())
        with self.job_statuses_lock:
            self.job_statuses[job_id] = {"type": "workflow", "status": "QUEUED", "preset_name": preset_name, "start_time": time.time()}
        self.kernel.write_to_log(f"Job '{job_id}' for preset '{preset_name}' has been queued.", "INFO")
        workflow_executor = self.kernel.get_service("workflow_executor_service")
        if workflow_executor:
            nodes = {node['id']: node for node in preset_data.get('nodes', [])}
            connections = {conn['id']: conn for conn in preset_data.get('connections', [])}
            workflow_executor.execute_workflow(
                nodes, connections, initial_payload,
                logger=self.kernel.write_to_log,
                status_updater=lambda *args: None,
                highlighter=lambda *args: None,
                ui_callback=lambda func, *args: func(*args) if callable(func) else None,
                workflow_context_id=job_id,
                job_status_updater=self.update_job_status
            )
            event_bus = self.kernel.get_service("event_bus")
            if event_bus and initial_payload and initial_payload.get("triggered_by") == "scheduler":
                rule_id = initial_payload.get("rule_id")
                if rule_id:
                    event_bus.publish("CRON_JOB_EXECUTED", {"rule_id": rule_id})
                    self.kernel.write_to_log(f"Published CRON_JOB_EXECUTED event for rule '{rule_id}'.", "DEBUG")
        else:
            self.kernel.write_to_log(f"Cannot trigger workflow '{preset_name}', WorkflowExecutor service is unavailable (likely due to license tier).", "ERROR")
        return job_id
    def trigger_scan_by_api(self, scanner_id: str = None) -> str | None:
        if not self.diagnostics_service:
            self.kernel.write_to_log("API Scan Trigger failed: DiagnosticsService not found.", "ERROR")
            return None
        job_id = f"scan_{uuid.uuid4()}"
        with self.job_statuses_lock:
            self.job_statuses[job_id] = {"type": "diagnostics_scan", "status": "QUEUED", "start_time": time.time(), "target": "ALL" if not scanner_id else scanner_id}
        scan_thread = threading.Thread(target=self._run_scan_worker, args=(job_id, scanner_id), daemon=True)
        scan_thread.start()
        return job_id
    def _run_scan_worker(self, job_id, scanner_id: str = None):
        self.update_job_status(job_id, {"status": "RUNNING"})
        try:
            result_data = self.diagnostics_service.start_scan_headless(job_id, target_scanner_id=scanner_id)
            self.update_job_status(job_id, {"status": "COMPLETED", "end_time": time.time(), "result": result_data})
        except Exception as e:
            self.kernel.write_to_log(f"Headless scan job '{job_id}' failed: {e}", "ERROR")
            self.update_job_status(job_id, {"status": "FAILED", "end_time": time.time(), "error": str(e)})
    def update_job_status(self, job_id: str, status_data: dict):
        with self.job_statuses_lock:
            if job_id not in self.job_statuses:
                self.job_statuses[job_id] = {}
            self.job_statuses[job_id].update(status_data)
    def get_job_status(self, job_id: str) -> dict | None:
        with self.job_statuses_lock:
            return self.job_statuses.get(job_id)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\connection_manager.py
# JUMLAH BARIS : 30
#######################################################################

```py
from typing import List
from fastapi import WebSocket
class ConnectionManager:
    """
    Manages active WebSocket connections for real-time client tracking.
    This acts as the 'switchboard operator' for the server.
    """
    def __init__(self):
        self.active_connections: List[WebSocket] = []
    async def connect(self, websocket: WebSocket):
        """Accepts a new client connection."""
        await websocket.accept()
        self.active_connections.append(websocket)
        print(f"[API Server] New client connected. Total connections: {len(self.active_connections)}") # English Log
    def disconnect(self, websocket: WebSocket):
        """Removes a client connection."""
        self.active_connections.remove(websocket)
        print(f"[API Server] Client disconnected. Total connections: {len(self.active_connections)}") # English Log
    @property
    def connection_count(self) -> int:
        """Returns the current number of active connections."""
        return len(self.active_connections)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\agent_routes.py
# JUMLAH BARIS : 84
#######################################################################

```py
from fastapi import APIRouter, HTTPException, Body, Request
from pydantic import BaseModel, Field
from typing import List, Optional
from uuid import UUID
class AgentRunRequest(BaseModel):
    objective: str
class AgentCreateOrUpdateRequest(BaseModel):
    id: Optional[UUID] = None
    name: str
    description: Optional[str] = ""
    brain_model_id: str
    tool_ids: List[str] = Field(default_factory=list)
    prompt_template: Optional[str] = ""
router = APIRouter(
    tags=["Agents"]
)
@router.get("/agents", response_model=List[dict])
async def handle_get_agents(request: Request):
    agent_manager = request.app.service_instance.agent_manager
    if not agent_manager:
        raise HTTPException(status_code=503, detail="AgentManagerService is not available.")
    return agent_manager.get_all_agents()
@router.get("/agents/{agent_id}", response_model=dict)
async def handle_get_agent_by_id(agent_id: str, request: Request):
    agent_manager = request.app.service_instance.agent_manager
    if not agent_manager:
        raise HTTPException(status_code=503, detail="AgentManagerService is not available.")
    agent = agent_manager.get_agent(agent_id)
    if agent:
        return agent
    else:
        raise HTTPException(status_code=404, detail=f"Agent with ID '{agent_id}' not found.")
@router.post("/agents", status_code=201, response_model=dict)
async def handle_post_agents(request: Request, agent_data: AgentCreateOrUpdateRequest):
    agent_manager = request.app.service_instance.agent_manager
    if not agent_manager:
        raise HTTPException(status_code=503, detail="AgentManagerService is not available.")
    result = agent_manager.save_agent(agent_data.model_dump())
    if "error" in result:
        raise HTTPException(status_code=400, detail=result["error"])
    return result
@router.delete("/agents/{agent_id}", status_code=204)
async def handle_delete_agent(agent_id: str, request: Request):
    agent_manager = request.app.service_instance.agent_manager
    if not agent_manager:
        raise HTTPException(status_code=503, detail="AgentManagerService is not available.")
    if not agent_manager.delete_agent(agent_id):
        raise HTTPException(status_code=404, detail="Agent not found.")
    return None # Return None for 204 No Content
@router.post("/agents/{agent_id}/run", status_code=202)
async def handle_run_agent(agent_id: str, request: Request, body: AgentRunRequest):
    agent_executor = request.app.service_instance.agent_executor
    if not agent_executor:
        raise HTTPException(status_code=503, detail="AgentExecutorService is not available.")
    result = agent_executor.run_agent(agent_id, body.objective)
    if "error" in result:
        raise HTTPException(status_code=409, detail=result["error"]) # 409 Conflict is suitable here
    return result
@router.get("/agents/run/{run_id}")
async def handle_get_agent_run_status(run_id: str, request: Request):
    agent_executor = request.app.service_instance.agent_executor
    if not agent_executor:
        raise HTTPException(status_code=503, detail="AgentExecutorService is not available.")
    status = agent_executor.get_run_status(run_id)
    if "error" in status:
        raise HTTPException(status_code=404, detail=status["error"])
    return status
@router.post("/agents/run/{run_id}/stop")
async def handle_stop_agent_run(run_id: str, request: Request):
    agent_executor = request.app.service_instance.agent_executor
    if not agent_executor:
        raise HTTPException(status_code=503, detail="AgentExecutorService is not available.")
    result = agent_executor.stop_agent_run(run_id)
    if "error" in result:
        raise HTTPException(status_code=404, detail=result["error"])
    return result
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\base_api_route.py
# JUMLAH BARIS : 9
#######################################################################

```py
from abc import ABC, abstractmethod
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\component_routes.py
# JUMLAH BARIS : 151
#######################################################################

```py
import os
from fastapi import APIRouter, HTTPException, Request, Body, UploadFile, File
from pydantic import BaseModel
from typing import List
import shutil
import tempfile
class ComponentStateUpdate(BaseModel):
    paused: bool
router = APIRouter(
    tags=["Components"]
)
def _get_manager_for_type(request: Request, resource_type: str):
    manager_map = {
        "modules": "module_manager_service",
        "plugins": "plugin_manager_service",
        "widgets": "widget_manager_service",
        "triggers": "trigger_manager_service",
        "ai_providers": "ai_provider_manager_service"
    }
    manager_name = manager_map.get(resource_type)
    if not manager_name:
        raise HTTPException(status_code=400, detail=f"Resource type '{resource_type}' is invalid.")
    service_instance = request.app.service_instance
    manager = getattr(service_instance, manager_name, None)
    if not manager:
        raise HTTPException(status_code=503, detail=f"{manager_name} service is unavailable.")
    return manager # MODIFIED: Simply return the manager instance.
@router.get("/{resource_type}", response_model=List[dict])
async def get_components(resource_type: str, request: Request):
    manager = _get_manager_for_type(request, resource_type)
    core_files = request.app.service_instance.core_component_ids
    items_attr_map = {
        "module_manager_service": "loaded_modules",
        "plugin_manager_service": "loaded_plugins",
        "widget_manager_service": "loaded_widgets",
        "trigger_manager_service": "loaded_triggers",
        "ai_provider_manager_service": "loaded_providers"
    }
    items_attr_name = items_attr_map.get(manager.service_id)
    if not items_attr_name:
        raise HTTPException(status_code=500, detail=f"Unknown items attribute for service '{manager.service_id}'")
    items = getattr(manager, items_attr_name, {})
    response_data = []
    for item_id_loop, item_data in items.items():
        is_paused = False
        manifest = {}
        tier = 'N/A'
        if manager.service_id == "ai_provider_manager_service":
            if hasattr(item_data, 'get_manifest'):
                manifest = item_data.get_manifest()
            is_paused = False
            if hasattr(item_data, 'TIER'):
                tier = getattr(item_data, 'TIER', 'free').lower()
        else:
            manifest = item_data.get('manifest', {})
            is_paused = item_data.get('is_paused', False)
            tier = manifest.get('tier', 'free')
        is_core = item_id_loop in core_files
        response_data.append({
            "id": item_id_loop,
            "name": manifest.get('name', item_id_loop),
            "version": manifest.get('version', 'N/A'),
            "is_paused": is_paused,
            "description": manifest.get('description', ''),
            "is_core": is_core,
            "tier": tier,
            "manifest": manifest
        })
    return response_data
@router.get("/{resource_type}/{item_id}", response_model=dict)
async def get_component_by_id(resource_type: str, item_id: str, request: Request):
    manager = _get_manager_for_type(request, resource_type)
    items_attr_map = {
        "module_manager_service": "loaded_modules",
        "plugin_manager_service": "loaded_plugins",
        "widget_manager_service": "loaded_widgets",
        "trigger_manager_service": "loaded_triggers",
        "ai_provider_manager_service": "loaded_providers"
    }
    items_attr_name = items_attr_map.get(manager.service_id)
    if not items_attr_name:
         raise HTTPException(status_code=500, detail=f"Unknown items attribute for service '{manager.service_id}'")
    items = getattr(manager, items_attr_name, {})
    if item_id in items:
        item_data = items[item_id]
        manifest = item_data.get('manifest', {}) if isinstance(item_data, dict) else (item_data.get_manifest() if hasattr(item_data, 'get_manifest') else {})
        response_data = {
            "id": item_id,
            "name": manifest.get('name', item_id),
            "version": manifest.get('version', 'N/A'),
            "is_paused": isinstance(item_data, dict) and item_data.get('is_paused', False),
            "description": manifest.get('description', ''),
            "manifest": manifest
        }
        return response_data
    else:
        raise HTTPException(status_code=404, detail=f"Component '{item_id}' not found in '{resource_type}'.")
@router.post("/{resource_type}/install", status_code=201)
async def install_component(resource_type: str, request: Request, file: UploadFile = File(...)):
    manager = _get_manager_for_type(request, resource_type)
    if not file.filename.endswith('.zip'):
        raise HTTPException(status_code=400, detail="Invalid file type. Only .zip files are allowed.")
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".zip") as tmp:
            shutil.copyfileobj(file.file, tmp)
            tmp_path = tmp.name
        success, message = manager.install_component(tmp_path)
        os.remove(tmp_path) # Clean up the temporary file
        if success:
            return {"status": "success", "message": message}
        else:
            raise HTTPException(status_code=400, detail=message)
    except Exception as e:
        request.app.service_instance.kernel.write_to_log(f"Error processing component install for {resource_type}: {e}", "CRITICAL") # English Log
        raise HTTPException(status_code=500, detail=f"Failed to process file upload: {e}")
@router.patch("/{resource_type}/{item_id}/state")
async def patch_component_state(resource_type: str, item_id: str, request: Request, body: ComponentStateUpdate):
    if item_id in request.app.service_instance.core_component_ids:
        raise HTTPException(status_code=403, detail="Core components cannot be disabled.")
    manager = _get_manager_for_type(request, resource_type)
    pause_method_name = f"set_{resource_type.rstrip('s')}_paused"
    pause_method = getattr(manager, pause_method_name, None)
    if not pause_method or not callable(pause_method):
        raise HTTPException(status_code=500, detail=f"State management method not found on {type(manager).__name__} for '{resource_type}'.")
    success = pause_method(item_id, body.paused)
    if success:
        action = "paused" if body.paused else "resumed"
        return {"status": "success", "message": f"{resource_type.capitalize()[:-1]} '{item_id}' has been {action}."}
    else:
        raise HTTPException(status_code=404, detail=f"{resource_type.capitalize()[:-1]} '{item_id}' not found.")
@router.delete("/{resource_type}/{item_id}", status_code=200)
async def delete_component(resource_type: str, item_id: str, request: Request):
    sanitized_id = os.path.basename(item_id)
    if sanitized_id != item_id:
        raise HTTPException(status_code=400, detail="Invalid component ID format.")
    if item_id in request.app.service_instance.core_component_ids:
        raise HTTPException(status_code=403, detail="Core components cannot be deleted.")
    manager = _get_manager_for_type(request, resource_type)
    success, message = manager.uninstall_component(item_id)
    if success:
        return {"status": "success", "message": message}
    else:
        raise HTTPException(status_code=404, detail=message)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\dataset_routes.py
# JUMLAH BARIS : 59
#######################################################################

```py
from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel
from typing import List, Dict, Any
class DatasetCreateRequest(BaseModel):
    name: str
class DatasetAddDataRequest(BaseModel):
    data: List[Dict[str, Any]]
router = APIRouter(
    tags=["Datasets"]
)
@router.get("/datasets", response_model=List[dict])
async def handle_get_datasets(request: Request):
    dataset_manager = request.app.service_instance.dataset_manager_service
    if not dataset_manager:
        raise HTTPException(status_code=503, detail="DatasetManagerService is not available.")
    return dataset_manager.list_datasets()
@router.post("/datasets", status_code=201)
async def handle_post_datasets(request: Request, body: DatasetCreateRequest):
    dataset_manager = request.app.service_instance.dataset_manager_service
    if not dataset_manager:
        raise HTTPException(status_code=503, detail="DatasetManagerService is not available.")
    success = dataset_manager.create_dataset(body.name)
    if success:
        return {"status": "success", "message": f"Dataset '{body.name}' created."}
    else:
        raise HTTPException(status_code=409, detail=f"Dataset '{body.name}' already exists or could not be created.")
@router.get("/datasets/{dataset_name}/data", response_model=List[dict])
async def handle_get_dataset_data(dataset_name: str, request: Request):
    dataset_manager = request.app.service_instance.dataset_manager_service
    if not dataset_manager:
        raise HTTPException(status_code=503, detail="DatasetManagerService is not available.")
    return dataset_manager.get_dataset_data(dataset_name)
@router.post("/datasets/{dataset_name}/data")
async def handle_post_dataset_data(dataset_name: str, request: Request, body: DatasetAddDataRequest):
    dataset_manager = request.app.service_instance.dataset_manager_service
    if not dataset_manager:
        raise HTTPException(status_code=503, detail="DatasetManagerService is not available.")
    success = dataset_manager.add_data_to_dataset(dataset_name, body.data)
    if success:
        return {"status": "success", "message": f"Added {len(body.data)} records to dataset '{dataset_name}'."}
    else:
        raise HTTPException(status_code=500, detail=f"Failed to add data to dataset '{dataset_name}'.")
@router.delete("/datasets/{dataset_name}", status_code=204)
async def handle_delete_dataset(dataset_name: str, request: Request):
    dataset_manager = request.app.service_instance.dataset_manager_service
    if not dataset_manager:
        raise HTTPException(status_code=503, detail="DatasetManagerService is not available.")
    success = dataset_manager.delete_dataset(dataset_name)
    if not success:
        raise HTTPException(status_code=404, detail=f"Dataset '{dataset_name}' not found.")
    return None # Return None for 204 No Content
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\execution_routes.py
# JUMLAH BARIS : 64
#######################################################################

```py
from fastapi import APIRouter, HTTPException, Request
from typing import Optional, Dict, Any
import time
router = APIRouter(
    tags=["Execution"]
)
@router.post("/workflow/execute/{preset_name}", status_code=202)
async def handle_workflow_execution(preset_name: str, request: Request, payload: Optional[Dict[str, Any]] = None):
    kernel = request.app.service_instance.kernel
    if not kernel.is_tier_sufficient('basic'):
        COOLDOWN_SECONDS = 300 # 5 minutes
        state_manager = request.app.service_instance.state_manager
        if state_manager:
            last_call_timestamp = state_manager.get("api_last_call_timestamp_free_tier", 0)
            current_time = time.time()
            if (current_time - last_call_timestamp) < COOLDOWN_SECONDS:
                remaining_time = int(COOLDOWN_SECONDS - (current_time - last_call_timestamp))
                error_message = f"API call limit for Free tier. Please wait {remaining_time} seconds."
                raise HTTPException(status_code=429, detail=error_message)
    try:
        initial_payload = payload if payload is not None else {"triggered_by": "api"}
        kernel.write_to_log(f"API call received to execute preset '{preset_name}'.", "INFO") # English Log
        if not kernel.is_tier_sufficient('basic'):
            state_manager = request.app.service_instance.state_manager
            if state_manager:
                state_manager.set("api_last_call_timestamp_free_tier", time.time())
        job_id = request.app.service_instance.trigger_workflow_by_api(preset_name, initial_payload)
        if job_id:
            return {"status": "accepted", "message": f"Workflow for preset '{preset_name}' has been queued.", "job_id": job_id}
        else:
            raise HTTPException(status_code=404, detail=f"Preset '{preset_name}' not found.")
    except Exception as e:
        kernel.write_to_log(f"Error handling API execution for '{preset_name}': {e}", "ERROR") # English Log
        raise HTTPException(status_code=500, detail=f"Internal Server Error: {e}")
@router.post("/diagnostics/execute/{scanner_id}", status_code=202)
@router.post("/diagnostics/execute", status_code=202)
async def handle_scan_execution(request: Request, scanner_id: Optional[str] = None):
    try:
        log_target = 'ALL' if not scanner_id else scanner_id
        request.app.service_instance.kernel.write_to_log(f"API call received to execute diagnostics scan for: {log_target}.", "INFO") # English Log
        job_id = request.app.service_instance.trigger_scan_by_api(scanner_id)
        if job_id:
            return {"status": "accepted", "message": f"System diagnostics scan for '{log_target}' has been queued.", "job_id": job_id}
        else:
            raise HTTPException(status_code=500, detail="Failed to start diagnostics scan.")
    except Exception as e:
        request.app.service_instance.kernel.write_to_log(f"Error handling API scan execution: {e}", "ERROR") # English Log
        raise HTTPException(status_code=500, detail=f"Internal Server Error: {e}")
@router.get("/workflow/status/{job_id}")
@router.get("/diagnostics/status/{job_id}")
async def handle_get_job_status(job_id: str, request: Request):
    status_data = request.app.service_instance.get_job_status(job_id)
    if status_data:
        return status_data
    else:
        raise HTTPException(status_code=404, detail=f"Job with ID '{job_id}' not found.")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\license_routes.py
# JUMLAH BARIS : 49
#######################################################################

```py
from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel
from typing import Dict, Any
class LicenseActivateRequest(BaseModel):
    license_content: Dict[str, Any]
class LicenseValidateRequest(BaseModel):
    license_key: str
    machine_id: str
router = APIRouter(
    tags=["License"]
)
@router.post("/license/activate")
async def handle_activate_license(request: Request, body: LicenseActivateRequest):
    license_manager = request.app.service_instance.kernel.get_service("license_manager_service")
    if not license_manager:
        raise HTTPException(status_code=503, detail="LicenseManager service is not available.")
    success, message = license_manager.activate_license_on_server(body.license_content)
    if success:
        return {"status": "success", "message": message}
    else:
        raise HTTPException(status_code=400, detail=message)
@router.post("/license/deactivate")
async def handle_deactivate_license(request: Request):
    license_manager = request.app.service_instance.kernel.get_service("license_manager_service")
    if not license_manager:
        raise HTTPException(status_code=503, detail="LicenseManager service is not available.")
    success, message = license_manager.deactivate_license_on_server()
    if success:
        return {"status": "success", "message": message}
    else:
        raise HTTPException(status_code=400, detail=message)
@router.post("/license/validate")
async def handle_validate_license(request: Request, body: LicenseValidateRequest):
    license_manager = request.app.service_instance.kernel.get_service("license_manager_service")
    if not license_manager:
        raise HTTPException(status_code=503, detail="LicenseManager service is not available.")
    success, message = license_manager.validate_local_license_online(body.license_key, body.machine_id)
    if success:
        return {"status": "success", "message": message}
    else:
        raise HTTPException(status_code=403, detail=message) # 403 Forbidden is more appropriate
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\model_routes.py
# JUMLAH BARIS : 104
#######################################################################

```py
from fastapi import APIRouter, HTTPException, Request, UploadFile, File, Form
from pydantic import BaseModel
from typing import List
import os
import shutil
import tempfile
class ModelConvertRequest(BaseModel):
    source_model_folder: str
    output_gguf_name: str
    quantize_method: str = "Q4_K_M"
class ModelRequantizeRequest(BaseModel):
    source_gguf_path: str
    output_gguf_name: str
    quantize_method: str = "Q4_K_M"
router = APIRouter(
    tags=["AI Models"]
)
@router.post("/models/convert", status_code=202)
async def handle_post_model_conversion(request: Request, body: ModelConvertRequest):
    converter_service = request.app.service_instance.converter_service
    if not converter_service:
        raise HTTPException(status_code=503, detail="ModelConverterService is not available.")
    result = converter_service.start_conversion_job(
        body.source_model_folder,
        body.output_gguf_name,
        body.quantize_method
    )
    if "error" in result:
        raise HTTPException(status_code=409, detail=result["error"])
    return result
@router.post("/models/requantize", status_code=202)
async def handle_post_model_requantize(request: Request, body: ModelRequantizeRequest):
    converter_service = request.app.service_instance.converter_service
    if not converter_service:
        raise HTTPException(status_code=503, detail="ModelConverterService is not available.")
    result = converter_service.start_requantize_job(
        body.source_gguf_path,
        body.output_gguf_name,
        body.quantize_method
    )
    if "error" in result:
        raise HTTPException(status_code=409, detail=result["error"])
    return result
@router.get("/models/convert/status/{job_id}")
async def handle_get_conversion_status(job_id: str, request: Request):
    converter_service = request.app.service_instance.converter_service
    if not converter_service:
        raise HTTPException(status_code=503, detail="ModelConverterService is not available.")
    status = converter_service.get_job_status(job_id)
    if "error" in status:
        raise HTTPException(status_code=404, detail=status["error"])
    return status
@router.post("/models/upload")
async def handle_model_upload(
    request: Request,
    description: str = Form(...),
    tier: str = Form(...),
    model_id: str = Form(...),
    file: UploadFile = File(...)
):
    addon_service = request.app.service_instance.addon_service
    if not addon_service:
        raise HTTPException(status_code=503, detail="CommunityAddonService is not available.")
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".gguf") as tmp_file:
            shutil.copyfileobj(file.file, tmp_file)
            temp_model_path = tmp_file.name
        success, message = addon_service.upload_model(temp_model_path, model_id, description, tier)
        os.remove(temp_model_path)
        if success:
            return {"status": "success", "message": message}
        else:
            raise HTTPException(status_code=500, detail=message)
    except Exception as e:
        request.app.service_instance.kernel.write_to_log(f"API Model Upload Error: {e}", "CRITICAL")
        raise HTTPException(status_code=500, detail=f"Failed to process model upload: {e}")
@router.get("/ai_models", response_model=List[dict])
async def handle_get_local_ai_models(request: Request):
    kernel = request.app.service_instance.kernel
    models_path = os.path.join(kernel.project_root_path, "ai_models")
    try:
        if not os.path.isdir(models_path):
            os.makedirs(models_path)
            return []
        gguf_files = [f for f in os.listdir(models_path) if f.endswith(".gguf")]
        response_data = []
        for filename in gguf_files:
            model_id = filename.replace('.gguf', '')
            response_data.append({
                "id": model_id, "name": model_id, "version": "N/A", "is_paused": False,
                "description": f"Local GGUF model file: {filename}", "is_core": False, "tier": "pro"
            })
        return response_data
    except Exception as e:
        kernel.write_to_log(f"Error listing local AI models: {e}", "ERROR")
        raise HTTPException(status_code=500, detail=f"Could not list local AI models: {e}")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\preset_routes.py
# JUMLAH BARIS : 87
#######################################################################

```py
from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel
from typing import List, Dict, Any
class PresetSaveRequest(BaseModel):
    name: str
    workflow_data: Dict[str, Any]
router = APIRouter(
    tags=["Presets"]
)
@router.get("/presets", response_model=List[dict])
async def handle_get_presets(request: Request):
    preset_manager = request.app.service_instance.preset_manager
    if not preset_manager:
        raise HTTPException(status_code=503, detail="PresetManager service is unavailable.")
    preset_list = preset_manager.get_preset_list()
    loc = request.app.service_instance.loc
    core_files = request.app.service_instance.core_component_ids
    response_data = []
    for name in preset_list:
        response_data.append({
            "id": name, "name": name, "version": "N/A", "is_paused": False,
            "description": loc.get('marketplace_preset_desc') if loc else 'Workflow Preset File',
            "is_core": name in core_files, "tier": "N/A"
        })
    return response_data
@router.get("/presets/{preset_name}", response_model=Dict[str, Any])
async def handle_get_preset_data(preset_name: str, request: Request):
    preset_manager = request.app.service_instance.preset_manager
    if not preset_manager:
        raise HTTPException(status_code=503, detail="PresetManager service is unavailable.")
    preset_data = preset_manager.get_preset_data(preset_name)
    if preset_data:
        return preset_data
    else:
        raise HTTPException(status_code=404, detail=f"Preset '{preset_name}' not found.")
@router.post("/presets", status_code=201)
async def handle_post_presets(request: Request, body: PresetSaveRequest):
    preset_manager = request.app.service_instance.preset_manager
    if not preset_manager:
        raise HTTPException(status_code=503, detail="PresetManager service is unavailable.")
    if preset_manager.save_preset(body.name, body.workflow_data):
        return {"status": "success", "message": f"Preset '{body.name}' created/updated."}
    else:
        raise HTTPException(status_code=500, detail=f"Failed to save preset '{body.name}'.")
@router.delete("/presets/{preset_name}", status_code=204)
async def handle_delete_preset(preset_name: str, request: Request):
    preset_manager = request.app.service_instance.preset_manager
    if not preset_manager:
        raise HTTPException(status_code=503, detail="PresetManager service is unavailable.")
    success = preset_manager.delete_preset(preset_name)
    if not success:
        raise HTTPException(status_code=404, detail=f"Preset '{preset_name}' not found or could not be deleted.")
    return None
@router.get("/presets/{preset_name}/versions", response_model=List[dict])
async def handle_get_preset_versions(preset_name: str, request: Request):
    preset_manager = request.app.service_instance.preset_manager
    if not preset_manager:
        raise HTTPException(status_code=503, detail="PresetManager service is unavailable.")
    return preset_manager.get_preset_versions(preset_name)
@router.get("/presets/{preset_name}/versions/{version_filename}", response_model=Dict[str, Any])
async def handle_get_preset_version_data(preset_name: str, version_filename: str, request: Request):
    preset_manager = request.app.service_instance.preset_manager
    if not preset_manager:
        raise HTTPException(status_code=503, detail="PresetManager service is unavailable.")
    version_data = preset_manager.load_preset_version(preset_name, version_filename)
    if version_data:
        return version_data
    else:
        raise HTTPException(status_code=404, detail=f"Version '{version_filename}' for preset '{preset_name}' not found.")
@router.delete("/presets/{preset_name}/versions/{version_filename}")
async def handle_delete_preset_version(preset_name: str, version_filename: str, request: Request):
    preset_manager = request.app.service_instance.preset_manager
    if not preset_manager:
        raise HTTPException(status_code=503, detail="PresetManager service is unavailable.")
    success = preset_manager.delete_preset_version(preset_name, version_filename)
    if success:
        return {"status": "success", "message": f"Version '{version_filename}' deleted."}
    else:
        raise HTTPException(status_code=404, detail=f"Could not delete version '{version_filename}'.")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\prompt_routes.py
# JUMLAH BARIS : 71
#######################################################################

```py
from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
class PromptData(BaseModel):
    name: str
    content: str
    id: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
router = APIRouter(
    tags=["Prompts"]
)
@router.get('/prompts', response_model=List[Dict[str, Any]])
async def get_all_prompts(request: Request):
    prompt_manager = request.app.service_instance.prompt_manager_service
    if not prompt_manager:
        raise HTTPException(status_code=503, detail="PromptManagerService is not available.")
    result = prompt_manager.get_all_prompts()
    if result is not None:
        return result
    raise HTTPException(status_code=500, detail="Service call to get all prompts failed.")
@router.post('/prompts', status_code=201)
async def create_prompt(request: Request, prompt_data: PromptData):
    prompt_manager = request.app.service_instance.prompt_manager_service
    if not prompt_manager:
        raise HTTPException(status_code=503, detail="PromptManagerService is not available.")
    result = prompt_manager.create_prompt(prompt_data.model_dump())
    if result and 'error' in result:
        raise HTTPException(status_code=400, detail=result['error'])
    if result:
        return result
    raise HTTPException(status_code=500, detail="Service call to create prompt failed.")
@router.get('/prompts/{prompt_id}')
async def get_prompt_by_id(prompt_id: str, request: Request):
    prompt_manager = request.app.service_instance.prompt_manager_service
    if not prompt_manager:
        raise HTTPException(status_code=503, detail="PromptManagerService is not available.")
    result = prompt_manager.get_prompt(prompt_id)
    if result:
        return result
    raise HTTPException(status_code=404, detail="Prompt not found or service call failed.")
@router.put('/prompts/{prompt_id}')
async def update_prompt(prompt_id: str, request: Request, prompt_data: PromptData):
    prompt_manager = request.app.service_instance.prompt_manager_service
    if not prompt_manager:
        raise HTTPException(status_code=503, detail="PromptManagerService is not available.")
    result = prompt_manager.update_prompt(prompt_id, prompt_data.model_dump())
    if result and 'error' in result:
        raise HTTPException(status_code=400, detail=result['error'])
    if result:
        return result
    raise HTTPException(status_code=500, detail="Service call to update prompt failed.")
@router.delete('/prompts/{prompt_id}')
async def delete_prompt(prompt_id: str, request: Request):
    prompt_manager = request.app.service_instance.prompt_manager_service
    if not prompt_manager:
        raise HTTPException(status_code=503, detail="PromptManagerService is not available.")
    result = prompt_manager.delete_prompt(prompt_id)
    if result and 'error' in result:
        raise HTTPException(status_code=404, detail=result['error'])
    if result:
        return result
    raise HTTPException(status_code=500, detail="Service call to delete prompt failed.")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\settings_routes.py
# JUMLAH BARIS : 28
#######################################################################

```py
from fastapi import APIRouter, HTTPException, Request
from typing import Dict, Any
router = APIRouter(
    tags=["Settings"]
)
@router.get("/settings", response_model=Dict[str, Any])
async def handle_get_settings(request: Request):
    loc = request.app.service_instance.loc
    if not loc:
        raise HTTPException(status_code=503, detail="LocalizationManager service is unavailable.")
    return loc._settings_cache
@router.patch("/settings")
async def handle_patch_settings(request: Request, settings_data: Dict[str, Any]):
    loc = request.app.service_instance.loc
    if not loc:
        raise HTTPException(status_code=503, detail="LocalizationManager service is unavailable.")
    current_settings = loc._settings_cache.copy()
    current_settings.update(settings_data)
    loc._save_settings(current_settings)
    return {"status": "success", "message": "Settings updated."}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\system_routes.py
# JUMLAH BARIS : 101
#######################################################################

```py
from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel
import time
import os
class AddonUploadRequest(BaseModel):
    comp_type: str
    component_id: str
    description: str
    tier: str
router = APIRouter()
public_router = APIRouter()
@public_router.get("/status", tags=["System"])
async def handle_get_status(request: Request):
    """
    Handles the public status check endpoint. This route does not require authentication.
    """
    kernel = request.app.service_instance.kernel
    api_key = None
    if kernel and hasattr(kernel, 'get_service'):
        variable_manager = kernel.get_service("variable_manager_service")
        if variable_manager:
            api_key = variable_manager.get_variable("FLOWORK_API_KEY")
    status_info = {
        "status": "ok",
        "version": kernel.APP_VERSION,
        "timestamp": time.time(),
        "api_key": api_key
    }
    return status_info
@public_router.get("/system/connections", tags=["System"])
async def get_connection_count(request: Request):
    """
    New public endpoint to get the number of active WebSocket connections.
    """
    connection_manager = request.app.service_instance.connection_manager
    return {"active_connections": connection_manager.connection_count}
@public_router.get("/system/log", tags=["System"])
async def get_server_log(request: Request):
    """
    ADDED: New public endpoint to get the latest content of the server log file.
    """
    log_file_path = os.path.join(request.app.service_instance.kernel.logs_path, "server.log")
    try:
        if os.path.exists(log_file_path):
            with open(log_file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                return {"log_content": "".join(lines[-100:])}
        return {"log_content": "Log file not found."}
    except Exception as e:
        return {"log_content": f"Error reading log file: {str(e)}"}
@router.post("/addons/upload", tags=["System"])
async def handle_addon_upload(request: Request, body: AddonUploadRequest):
    addon_service = request.app.service_instance.addon_service
    if not addon_service:
        raise HTTPException(status_code=503, detail="CommunityAddonService is not available.")
    try:
        success, result_message = addon_service.upload_component(
            body.comp_type,
            body.component_id,
            body.description,
            body.tier
        )
        if success:
            return {"status": "success", "message": result_message}
        else:
            raise HTTPException(status_code=500, detail=result_message)
    except Exception as e:
        request.app.service_instance.kernel.write_to_log(f"API Addon Upload Error: {e}", "ERROR")
        raise HTTPException(status_code=500, detail=str(e))
@router.post("/system/actions/hot_reload", tags=["System"])
async def handle_hot_reload(request: Request):
    try:
        request.app.service_instance.kernel.hot_reload_components()
        return {"status": "success", "message": "Hot reload process initiated."}
    except Exception as e:
        request.app.service_instance.kernel.write_to_log(f"Hot reload via API failed: {e}", "CRITICAL")
        raise HTTPException(status_code=500, detail=f"Internal server error during hot reload: {e}")
@router.post("/system/actions/restart", tags=["System"])
async def handle_restart(request: Request):
    """
    Handles the API request to trigger a restart event.
    """
    try:
        kernel = request.app.service_instance.kernel
        event_bus = kernel.get_service("event_bus")
        if event_bus and hasattr(kernel, 'root') and kernel.root:
            kernel.root.after(100, lambda: event_bus.publish("RESTART_APP", {}))
            return {"status": "accepted", "message": "Restart signal sent to the application."}
        else:
            raise HTTPException(status_code=503, detail="EventBus service or UI root is not available to process the restart signal.")
    except Exception as e:
        request.app.service_instance.kernel.write_to_log(f"Restart via API failed: {e}", "CRITICAL")
        raise HTTPException(status_code=500, detail=f"Internal server error during restart signal: {e}")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\training_routes.py
# JUMLAH BARIS : 42
#######################################################################

```py
from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel
from typing import Dict, Any
class TrainingStartRequest(BaseModel):
    base_model_id: str
    dataset_name: str
    new_model_name: str
    training_args: Dict[str, Any]
router = APIRouter(
    tags=["AI Training"]
)
@router.post("/training/start", status_code=202)
async def handle_start_training_job(request: Request, body: TrainingStartRequest):
    training_service = request.app.service_instance.training_service
    if not training_service:
        raise HTTPException(status_code=503, detail="AITrainingService is not available.")
    result = training_service.start_fine_tuning_job(
        body.base_model_id,
        body.dataset_name,
        body.new_model_name,
        body.training_args
    )
    if "error" in result:
        raise HTTPException(status_code=409, detail=result["error"])
    return result
@router.get("/training/status/{job_id}")
async def handle_get_training_job_status(job_id: str, request: Request):
    training_service = request.app.service_instance.training_service
    if not training_service:
        raise HTTPException(status_code=503, detail="AITrainingService is not available.")
    status = training_service.get_job_status(job_id)
    if "error" in status:
        raise HTTPException(status_code=404, detail=status["error"])
    return status
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\trigger_routes.py
# JUMLAH BARIS : 103
#######################################################################

```py
from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
class TriggerRule(BaseModel):
    name: str
    trigger_id: str
    preset_to_run: str
    is_enabled: bool = True
    config: Dict[str, Any] = {}
router = APIRouter(
    tags=["Triggers"]
)
@router.get("/triggers/definitions", response_model=List[dict])
async def handle_get_trigger_definitions(request: Request):
    trigger_manager = request.app.service_instance.trigger_manager
    if not trigger_manager:
        raise HTTPException(status_code=503, detail="TriggerManager service is unavailable.")
    definitions = [tdata['manifest'] for tid, tdata in trigger_manager.loaded_triggers.items()]
    return sorted(definitions, key=lambda x: x.get('name', ''))
@router.get("/triggers/rules", response_model=List[dict])
async def handle_get_trigger_rules(request: Request):
    state_manager = request.app.service_instance.state_manager
    if not state_manager:
        raise HTTPException(status_code=503, detail="StateManager service is unavailable.")
    all_rules = state_manager.get("trigger_rules", {})
    trigger_manager = request.app.service_instance.trigger_manager
    scheduler_manager = request.app.service_instance.scheduler_manager
    enriched_rules = []
    for rid, rdata in all_rules.items():
        enriched_data = rdata.copy()
        enriched_data['id'] = rid
        trigger_id = rdata.get('trigger_id')
        enriched_data['trigger_name'] = trigger_manager.loaded_triggers.get(trigger_id, {}).get('manifest', {}).get('name', trigger_id) if trigger_manager else trigger_id
        next_run = None
        if scheduler_manager and trigger_id == 'cron_trigger' and rdata.get('is_enabled'):
            try:
                next_run_time = scheduler_manager.get_next_run_time(rid)
                if next_run_time:
                    next_run = next_run_time.isoformat()
            except Exception as e:
                request.app.service_instance.kernel.write_to_log(f"A non-critical error occurred while fetching next_run_time for job '{rid}'. The UI will show '-'. Error: {e}", "WARN") # English Log
                next_run = None
        enriched_data['next_run_time'] = next_run
        enriched_rules.append(enriched_data)
    return enriched_rules
@router.get("/triggers/rules/{rule_id}", response_model=Dict[str, Any])
async def handle_get_trigger_rule_by_id(rule_id: str, request: Request):
    state_manager = request.app.service_instance.state_manager
    if not state_manager:
        raise HTTPException(status_code=503, detail="StateManager service is unavailable.")
    all_rules = state_manager.get("trigger_rules", {})
    rule_data = all_rules.get(rule_id)
    if rule_data:
        return rule_data
    raise HTTPException(status_code=404, detail=f"Rule with ID '{rule_id}' not found.")
@router.post("/triggers/rules", status_code=201)
async def handle_post_trigger_rule(request: Request, body: TriggerRule):
    state_manager = request.app.service_instance.state_manager
    if not state_manager:
        raise HTTPException(status_code=503, detail="StateManager service is unavailable.")
    new_rule_id = str(uuid.uuid4())
    all_rules = state_manager.get("trigger_rules", {})
    all_rules[new_rule_id] = body.model_dump()
    state_manager.set("trigger_rules", all_rules)
    return {"status": "success", "id": new_rule_id}
@router.put("/triggers/rules/{rule_id}")
async def handle_put_trigger_rule(rule_id: str, request: Request, body: TriggerRule):
    state_manager = request.app.service_instance.state_manager
    if not state_manager:
        raise HTTPException(status_code=503, detail="StateManager service is unavailable.")
    all_rules = state_manager.get("trigger_rules", {})
    if rule_id not in all_rules:
        raise HTTPException(status_code=404, detail=f"Rule with ID '{rule_id}' not found.")
    all_rules[rule_id] = body.model_dump()
    state_manager.set("trigger_rules", all_rules)
    return {"status": "success", "id": rule_id}
@router.delete("/triggers/rules/{rule_id}", status_code=204)
async def handle_delete_trigger_rule(rule_id: str, request: Request):
    state_manager = request.app.service_instance.state_manager
    if not state_manager:
        raise HTTPException(status_code=503, detail="StateManager service is unavailable.")
    all_rules = state_manager.get("trigger_rules", {})
    if rule_id in all_rules:
        del all_rules[rule_id]
        state_manager.set("trigger_rules", all_rules)
        return None
    else:
        raise HTTPException(status_code=404, detail=f"Rule with ID '{rule_id}' not found.")
@router.post("/triggers/actions/reload")
async def handle_reload_triggers(request: Request):
    trigger_manager = request.app.service_instance.trigger_manager
    if not trigger_manager:
        raise HTTPException(status_code=503, detail="TriggerManager service is unavailable.")
    trigger_manager.start_all_listeners()
    return {"status": "success", "message": "Trigger reload process initiated."}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\ui_routes.py
# JUMLAH BARIS : 76
#######################################################################

```py
from fastapi import APIRouter, HTTPException, Request
from typing import List, Dict, Any
from flowork_kernel.api_contract import BaseUIProvider
router = APIRouter(
    tags=["UI"]
)
@router.get("/ui/menubar", response_model=List[Dict[str, Any]])
async def get_menubar_structure(request: Request):
    """
    Endpoint to build and return the entire menubar structure dynamically.
    It gathers static menu items and dynamic items from UI provider plugins.
    """
    kernel = request.app.service_instance.kernel
    loc = kernel.get_service("localization_manager")
    main_menus = []
    file_menu = {
        "label": loc.get('menu_file', fallback="File"),
        "items": []
    }
    file_menu["items"].append({"label": "Login / Register", "command": {"type": "open_auth_dialog"}})
    file_menu["items"].append({"label": "Logout", "command": {"type": "user_logout"}})
    file_menu["items"].append({"type": "separator"})
    file_menu["items"].append({"label": loc.get('menu_save_workflow', fallback="Save Workflow"), "command": {"type": "trigger_action", "value": "save_workflow"}})
    file_menu["items"].append({"label": loc.get('menu_load_workflow', fallback="Load Workflow"), "command": {"type": "trigger_action", "value": "load_workflow"}})
    if kernel.is_monetization_active():
        file_menu["items"].append({"type": "separator"})
        file_menu["items"].append({"label": loc.get('menu_activate_license', fallback="Activate New License..."), "command": {"type": "activate_license"}})
        file_menu["items"].append({"label": loc.get('menu_deactivate_license', fallback="Deactivate This Computer"), "command": {"type": "deactivate_license"}})
    file_menu["items"].append({"type": "separator"})
    file_menu["items"].append({"label": loc.get('menu_exit', fallback="Exit"), "command": {"type": "exit_app"}})
    main_menus.append(file_menu)
    plugin_menus = {} # Dictionary to hold menus from plugins
    plugin_manager = kernel.get_service("plugin_manager_service")
    if plugin_manager:
        for plugin_id, plugin_data in plugin_manager.loaded_plugins.items():
            instance = plugin_manager.get_instance(plugin_id)
            if instance and isinstance(instance, BaseUIProvider) and not plugin_data.get("is_paused"):
                menu_items = instance.get_menu_items()
                if menu_items:
                    for item in menu_items:
                        parent_label = item.get('parent')
                        if parent_label not in plugin_menus:
                            plugin_menus[parent_label] = {"label": parent_label, "items": []}
                        if item.get('add_separator'):
                            plugin_menus[parent_label]["items"].append({"type": "separator"})
                        command_obj = {"type": "execute_lambda", "value": item.get('command')}
                        if "open_managed_tab" in str(item.get('command')):
                            tab_key_match = re.search(r"open_managed_tab\('([^']+)'\)", str(item.get('command')))
                            if tab_key_match:
                                command_obj = {"type": "open_tab", "value": tab_key_match.group(1)}
                        plugin_menus[parent_label]["items"].append({
                            "label": item.get('label'),
                            "command": command_obj
                        })
    main_menus.extend(plugin_menus.values())
    help_menu = {
        "label": loc.get('menu_help', fallback="Help"),
        "items": [
            {"label": "View Documentation", "command": {"type": "open_url", "value": "http://127.0.0.1:8000"}},
            {"type": "separator"},
            {"label": loc.get('menu_about', fallback="About Flowork"), "command": {"type": "show_about_dialog"}}
        ]
    }
    if not kernel.is_monetization_active():
        help_menu["items"].append({"type": "separator"})
        help_menu["items"].append({"label": "❤️Support This Project (Donate)❤️", "command": {"type": "open_url", "value": "https://donate.flowork.art/"}})
    main_menus.append(help_menu)
    return main_menus
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\ui_state_routes.py
# JUMLAH BARIS : 57
#######################################################################

```py
from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel
from typing import List, Dict, Any
class OpenTabRequest(BaseModel):
    tab_key: str
router = APIRouter(
    tags=["UI State"]
)
@router.get("/uistate/dashboards/{tab_id}", response_model=Dict[str, Any])
async def handle_get_dashboard_layout(tab_id: str, request: Request):
    state_manager = request.app.service_instance.state_manager
    if not state_manager:
        raise HTTPException(status_code=503, detail="StateManager service is unavailable.")
    layout_key = f"dashboard_layout_{tab_id}"
    layout_data = state_manager.get(layout_key, {})
    return layout_data
@router.post("/uistate/dashboards/{tab_id}")
async def handle_post_dashboard_layout(tab_id: str, request: Request, layout_data: Dict[str, Any]):
    state_manager = request.app.service_instance.state_manager
    if not state_manager:
        raise HTTPException(status_code=503, detail="StateManager service is unavailable.")
    layout_key = f"dashboard_layout_{tab_id}"
    state_manager.set(layout_key, layout_data)
    return {"status": "success", "message": f"Layout for dashboard '{tab_id}' saved."}
@router.get("/uistate/session/tabs", response_model=List[dict])
async def handle_get_session_tabs(request: Request):
    state_manager = request.app.service_instance.state_manager
    if not state_manager:
        raise HTTPException(status_code=503, detail="StateManager service is unavailable.")
    open_tabs = state_manager.get("open_tabs", [])
    return open_tabs
@router.post("/uistate/session/tabs")
async def handle_post_session_tabs(request: Request, tabs_data: List[Dict[str, Any]]):
    state_manager = request.app.service_instance.state_manager
    if not state_manager:
        raise HTTPException(status_code=503, detail="StateManager service is unavailable.")
    state_manager.set("open_tabs", tabs_data)
    return {"status": "success", "message": "Tab session saved."}
@router.post("/ui/actions/open_tab")
async def handle_ui_action_open_tab(request: Request, body: OpenTabRequest):
    kernel = request.app.service_instance.kernel
    tab_manager = kernel.get_service("tab_manager_service")
    if not tab_manager:
        raise HTTPException(status_code=503, detail="UI Tab Manager service is not available.")
    if hasattr(kernel, 'root') and kernel.root:
        kernel.root.after(0, tab_manager.open_managed_tab, body.tab_key)
        return {"status": "success", "message": f"Request to open tab '{body.tab_key}' sent to UI."}
    else:
        raise HTTPException(status_code=503, detail="UI is not ready to handle tab actions.")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\api_server_service\routes\variable_routes.py
# JUMLAH BARIS : 56
#######################################################################

```py
from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
class VariableUpdateRequest(BaseModel):
    value: Any
    is_secret: bool
    is_enabled: bool = True
    mode: Optional[str] = None
class VariableStatePatch(BaseModel):
    enabled: bool
router = APIRouter(
    tags=["Variables"]
)
@router.get("/variables", response_model=List[dict])
async def handle_get_variables(request: Request):
    variable_manager = request.app.service_instance.variable_manager
    if not variable_manager:
        raise HTTPException(status_code=503, detail="VariableManager service is unavailable.")
    return variable_manager.get_all_variables_for_api()
@router.put("/variables/{variable_name}")
async def handle_put_variables(variable_name: str, request: Request, body: VariableUpdateRequest):
    variable_manager = request.app.service_instance.variable_manager
    if not variable_manager:
        raise HTTPException(status_code=503, detail="VariableManager service is unavailable.")
    try:
        variable_manager.set_variable(variable_name, body.value, body.is_secret, body.is_enabled, mode=body.mode)
        return {"status": "success", "message": f"Variable '{variable_name}' saved."}
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
@router.patch("/variables/{variable_name}/state")
async def handle_patch_variable_state(variable_name: str, request: Request, body: VariableStatePatch):
    variable_manager = request.app.service_instance.variable_manager
    if not variable_manager:
        raise HTTPException(status_code=503, detail="VariableManager service is unavailable.")
    success = variable_manager.set_variable_enabled_state(variable_name, body.enabled)
    if success:
        action = "enabled" if body.enabled else "disabled"
        return {"status": "success", "message": f"Variable '{variable_name}' has been {action}."}
    else:
        raise HTTPException(status_code=404, detail=f"Variable '{variable_name}' not found.")
@router.delete("/variables/{variable_name}", status_code=204)
async def handle_delete_variables(variable_name: str, request: Request):
    variable_manager = request.app.service_instance.variable_manager
    if not variable_manager:
        raise HTTPException(status_code=503, detail="VariableManager service is unavailable.")
    if not variable_manager.delete_variable(variable_name):
        raise HTTPException(status_code=404, detail=f"Variable '{variable_name}' not found.")
    return None
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\auto_compiler_service\auto_compiler_service.py
# JUMLAH BARIS : 179
#######################################################################

```py
import os
import sys
import subprocess
import json
import hashlib
import time
import re
from ..base_service import BaseService
class AutoCompilerService(BaseService):
    """
    (REMASTERED V4) A powerful service that runs in development mode.
    It now dynamically assigns the correct compiled extension based on component type.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.component_dirs = [
            self.kernel.modules_path, self.kernel.plugins_path,
            self.kernel.widgets_path, self.kernel.triggers_path,
            self.kernel.ai_providers_path,
            os.path.join(self.kernel.project_root_path, 'scanners') # [PENAMBAHAN] Scanner sekarang ikut dipantau
        ]
        self.is_nuitka_available = self._check_nuitka()
    def _check_nuitka(self):
        """Checks if Nuitka is available in the environment."""
        try:
            self.logger("Nuitka compiler is available.", "SUCCESS") # English Log
            return True
        except ImportError:
            self.logger("Nuitka is not installed. Auto-compiler service will be disabled.", "WARN") # English Log
            return False
    def start(self):
        """
        The start method is a placeholder; the main logic is triggered by other services.
        """
        if self.is_nuitka_available:
            self.logger("AutoCompilerService is active and ready.", "SUCCESS") # English Log
        else:
            self.logger("AutoCompilerService is inactive due to missing Nuitka.", "WARN") # English Log
    def initial_scan(self):
        """
        Performs a full scan on startup to compile any changed or new components.
        """
        if not self.is_nuitka_available or not self.kernel.is_dev_mode:
            return
        self.logger("AutoCompiler: Performing initial scan for modules to compile...", "INFO") # English Log
        total_compiled = 0
        for base_dir in self.component_dirs:
            if not os.path.isdir(base_dir): continue
            for component_id in os.listdir(base_dir):
                component_path = os.path.join(base_dir, component_id)
                if os.path.isdir(component_path):
                    manifest_path = os.path.join(component_path, "manifest.json")
                    if os.path.exists(manifest_path) or base_dir.endswith('scanners'):
                        if self._compile_if_needed(component_path, component_id):
                            total_compiled += 1
        self.logger(f"AutoCompiler: Initial scan complete. Compiled {total_compiled} new/updated components.", "SUCCESS") # English Log
    def _get_target_extension(self, component_path: str) -> str:
        """
        [ADDED V2] Determines the correct compiled file extension based on the component's parent directory.
        """
        normalized_path = component_path.replace('\\', '/')
        if '/widgets/' in normalized_path:
            return ".widget.flowork"
        if '/modules/' in normalized_path:
            return ".module.flowork"
        if '/plugins/' in normalized_path:
            return ".plugin.flowork"
        if '/triggers/' in normalized_path:
            return ".trigger.flowork"
        if '/scanners/' in normalized_path: # [PENAMBAHAN] Aturan baru untuk scanner
            return ".scanner.flowork"
        return ".aola_flowork" # Fallback to the old extension
    def _compile_if_needed(self, component_path, component_id):
        """
        The core logic. Checks fingerprints and decides whether to compile a component.
        """
        fingerprint_path = os.path.join(component_path, "build_fingerprint.json")
        manifest_path = os.path.join(component_path, "manifest.json")
        entry_point_file = None
        if os.path.exists(manifest_path):
            try:
                with open(manifest_path, 'r', encoding='utf-8') as f:
                    manifest = json.load(f)
                entry_point = manifest.get("entry_point")
                if entry_point and '.' in entry_point:
                    module_filename, _ = entry_point.split('.', 1)
                    entry_point_file = f"{module_filename}.py"
            except Exception:
                return False
        elif os.path.basename(os.path.dirname(component_path)) == 'scanners':
            entry_point_file = f"{component_id}.py"
        if not entry_point_file: return False
        source_py_path = os.path.join(component_path, entry_point_file)
        if not os.path.exists(source_py_path):
            return False
        current_fingerprint = self._calculate_fingerprint(component_path, source_py_path)
        last_fingerprint = {}
        if os.path.exists(fingerprint_path):
            try:
                with open(fingerprint_path, 'r', encoding='utf-8') as f:
                    last_fingerprint = json.load(f)
            except (IOError, json.JSONDecodeError):
                last_fingerprint = {}
        if current_fingerprint.get("source_hash") == last_fingerprint.get("source_hash"):
            return False
        self.logger(f"'{component_id}' has changed. Recompiling...", "WARN") # English Log
        target_extension = self._get_target_extension(component_path)
        if self._run_nuitka_compilation(source_py_path, component_id, target_extension):
            with open(fingerprint_path, 'w', encoding='utf-8') as f:
                json.dump(current_fingerprint, f, indent=4)
            self.logger(f"Successfully compiled '{component_id}' to '{target_extension}' and updated its fingerprint.", "SUCCESS") # English Log
            return True
        return False
    def _calculate_fingerprint(self, component_path, source_py_path):
        """Calculates a hash of the source .py file and its manifest."""
        source_hash = hashlib.sha256()
        try:
            with open(source_py_path, 'rb') as f:
                source_hash.update(f.read())
            manifest_path = os.path.join(component_path, "manifest.json")
            if os.path.exists(manifest_path):
                with open(manifest_path, 'rb') as f:
                    manifest_hash = hashlib.sha256(f.read()).hexdigest()
            else:
                manifest_hash = None
            return {
                "source_hash": source_hash.hexdigest(),
                "manifest_hash": manifest_hash,
                "timestamp": time.time()
            }
        except IOError:
            return {}
    def _run_nuitka_compilation(self, source_py_path, component_id, target_extension):
        """
        Executes the Nuitka compilation process via a subprocess.
        """
        output_filename = os.path.splitext(os.path.basename(source_py_path))[0]
        output_dir = os.path.dirname(source_py_path)
        command = [
            sys.executable,
            "-m", "nuitka",
            "--module",
            "--output-dir=" + output_dir,
            "--remove-output",
            "--windows-console-mode=disable",
            "--lto=yes",
            "--python-flag=-OO",
            source_py_path
        ]
        try:
            subprocess.run(command, check=True, capture_output=True, text=True, cwd=self.kernel.project_root_path)
            compiled_ext = ".pyd" if sys.platform == "win32" else ".so"
            generated_file = None
            for file in os.listdir(output_dir):
                if file.startswith(output_filename) and file.endswith(compiled_ext):
                    generated_file = os.path.join(output_dir, file)
                    break
            target_file = os.path.join(output_dir, f"{output_filename}{target_extension}")
            if os.path.exists(target_file):
                os.remove(target_file)
            if generated_file and os.path.exists(generated_file):
                os.rename(generated_file, target_file)
                return True
            else:
                self.logger(f"Nuitka did not produce the expected output file in '{output_dir}' for '{component_id}'", "ERROR") # English Log
                return False
        except subprocess.CalledProcessError as e:
            self.logger(f"Nuitka compilation FAILED for '{component_id}'.", "CRITICAL") # English Log
            self.logger(f"Nuitka STDOUT: {e.stdout}", "DEBUG") # English Log
            self.logger(f"Nuitka STDERR: {e.stderr}", "DEBUG") # English Log
            return False
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\behavior_manager_service\behavior_handlers.py
# JUMLAH BARIS : 111
#######################################################################

```py
import time
import random
from flowork_kernel.api_contract import LoopConfig
from queue import Queue
import threading
import json
class BaseBehaviorHandler:
    """Base class for all behavior handlers."""
    def __init__(self, kernel, module_id):
        self.kernel = kernel
        self.module_id = module_id
        self.loc = self.kernel.get_service("localization_manager")
        self.state_manager = self.kernel.get_service("state_manager")
        self.workflow_executor = self.kernel.get_service("workflow_executor_service")
    def wrap(self, execute_func):
        raise NotImplementedError("Each handler must implement the 'wrap' method.")
class LoopHandler(BaseBehaviorHandler):
    """Handles the looping behavior for a node."""
    def wrap(self, execute_func):
        def loop_wrapper(payload, config, status_updater, ui_callback, mode, node_info, highlight):
            enable_loop = config.get('enable_loop', False)
            if not enable_loop:
                return execute_func(payload, config, status_updater, ui_callback, mode, node_info, highlight)
            current_node_id = node_info.get('id')
            workflow_context_id = self.workflow_executor.get_current_context_id()
            loop_state_key = f"loop_progress::{workflow_context_id}::{current_node_id}"
            start_iteration = self.state_manager.get(loop_state_key, 0)
            node_name_for_log = node_info.get('name', '[Unnamed]')
            self.kernel.write_to_log(self.loc.get('exec_loading_loop_state', node_name=node_name_for_log, context_id=workflow_context_id, start_iter=start_iteration), "DEBUG")
            loop_config = LoopConfig.from_dict(config)
            loop_count = start_iteration
            last_payload = payload
            while True:
                if self.workflow_executor._stop_event.is_set():
                    self.kernel.write_to_log(self.loc.get('exec_loop_stopped', node_name=node_name_for_log), "WARN")
                    break
                self.workflow_executor._pause_event.wait()
                if loop_config.loop_type == LoopConfig.LOOP_TYPE_COUNT:
                    if loop_count >= loop_config.iterations:
                        self.kernel.write_to_log(self.loc.get('exec_loop_count_finished', node_name=node_name_for_log, iterations=loop_count), "INFO")
                        break
                    status_updater(f"Loop {loop_count + 1}/{loop_config.iterations}", "INFO")
                execution_result = execute_func(last_payload, config, status_updater, ui_callback, mode, node_info, highlight)
                if isinstance(execution_result, Exception):
                    self.kernel.write_to_log(f"Error during loop iteration {loop_count + 1} for '{node_name_for_log}': {execution_result}", "ERROR")
                    last_payload = execution_result
                    break
                if isinstance(execution_result, dict) and "payload" in execution_result:
                    last_payload = execution_result.get("payload", last_payload)
                else:
                    last_payload = execution_result
                loop_count += 1
                if mode == 'EXECUTE':
                    self.state_manager.set(loop_state_key, loop_count)
                if loop_config.enable_sleep and mode == 'EXECUTE':
                    sleep_duration = 0
                    if loop_config.sleep_type == "static":
                        sleep_duration = loop_config.static_duration
                    elif loop_config.sleep_type == "random_range":
                        sleep_duration = random.randint(loop_config.random_min, loop_config.random_max)
                    if sleep_duration > 0:
                        highlight('sleeping_node', current_node_id)
                        time.sleep(sleep_duration)
            if mode == 'EXECUTE':
                self.state_manager.delete(loop_state_key)
            return last_payload
        return loop_wrapper
class RetryHandler(BaseBehaviorHandler):
    """Handles the retry behavior for a node."""
    def wrap(self, execute_func):
        def retry_wrapper(payload, config, status_updater, ui_callback, mode, node_info, highlight):
            retry_attempts = config.get('retry_attempts', 0)
            retry_delay = config.get('retry_delay_seconds', 5)
            node_name_for_log = node_info.get('name', '[Unnamed]')
            last_exception = None
            for attempt in range(retry_attempts + 1):
                if self.workflow_executor._stop_event.is_set():
                    break
                if attempt > 0:
                    self.kernel.write_to_log(self.loc.get('exec_node_retrying_error', node_name=node_name_for_log, delay=retry_delay, attempt=attempt, total_attempts=retry_attempts), "WARN")
                    status_updater(f"Retry {attempt}/{retry_attempts}", "WARN")
                    time.sleep(retry_delay)
                result_queue = Queue()
                timeout_seconds = config.get('timeout_seconds', 0)
                def execution_target():
                    try:
                        res = execute_func(payload, config, status_updater, ui_callback, mode, node_info, highlight)
                        result_queue.put(res)
                    except Exception as e:
                        result_queue.put(e)
                exec_thread = threading.Thread(target=execution_target, daemon=True)
                exec_thread.start()
                try:
                    timeout = timeout_seconds if timeout_seconds > 0 else None
                    result = result_queue.get(timeout=timeout)
                except queue.Empty:
                    result = TimeoutError(self.loc.get('exec_node_timeout_error', node_name=node_name_for_log, seconds=timeout_seconds))
                if not isinstance(result, Exception):
                    return result # Success
                last_exception = result
            self.kernel.write_to_log(f"Node '{node_name_for_log}' failed after {retry_attempts} retries.", "ERROR")
            return last_exception
        return retry_wrapper
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\behavior_manager_service\behavior_manager_service.py
# JUMLAH BARIS : 47
#######################################################################

```py
from ..base_service import BaseService
from .behavior_handlers import RetryHandler, LoopHandler
class BehaviorManagerService(BaseService):
    """
    Service that is dedicated to managing and applying 'behaviors'
    (like retry, loop) to a module's execution function, based on its manifest.
    This is an implementation of the Decorator Pattern.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.module_manager = self.kernel.get_service("module_manager_service")
        self.registered_behaviors = {
            "retry": RetryHandler,
            "loop": LoopHandler
        }
        self.kernel.write_to_log("Service 'BehaviorManager' initialized successfully.", "DEBUG")
    def wrap_execution(self, module_id, original_execute_func):
        """
        Wraps the original execution function with handlers based on the module's manifest.
        Args:
            module_id (str): The ID of the module to be executed.
            original_execute_func (callable): The original function that performs the execution.
        Returns:
            callable: The final, wrapped execution function.
        """
        manifest = self.module_manager.get_manifest(module_id)
        if not manifest:
            return original_execute_func
        behaviors_to_apply = manifest.get("behaviors", [])
        wrapped_func = original_execute_func
        if "retry" in behaviors_to_apply:
            retry_handler = self.registered_behaviors["retry"](self.kernel, module_id)
            wrapped_func = retry_handler.wrap(wrapped_func)
            self.kernel.write_to_log(f"BehaviorManager: Wrapping '{module_id}' with RetryHandler.", "DEBUG")
        if "loop" in behaviors_to_apply:
            loop_handler = self.registered_behaviors["loop"](self.kernel, module_id)
            wrapped_func = loop_handler.wrap(wrapped_func)
            self.kernel.write_to_log(f"BehaviorManager: Wrapping '{module_id}' with LoopHandler.", "DEBUG")
        return wrapped_func
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\community_addon_service\community_addon_service.py
# JUMLAH BARIS : 141
#######################################################################

```py
import os
import tempfile
import zipfile
import shutil
import base64
import requests
import json
import uuid
from datetime import datetime, timedelta
from ..base_service import BaseService
import hashlib
from flowork_kernel.api_client import ApiClient
class CommunityAddonService(BaseService):
    """
    (REMASTERED V3) Handles all interactions with the community addon repository.
    This version now EXCLUDES the 'vendor' directory during the packaging process
    to create lightweight, efficient uploads.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.logger = self.kernel.write_to_log
        self.api_client = ApiClient(kernel=self.kernel)
        self.core_component_ids = self._load_core_component_ids()
    def _load_core_component_ids(self):
        core_ids = set()
        manifest_path = os.path.join(self.kernel.project_root_path, "core_integrity.json")
        try:
            with open(manifest_path, 'r', encoding='utf-8') as f:
                manifest_data = json.load(f)
            for path in manifest_data.keys():
                parts = path.split('/')
                if len(parts) > 1 and parts[0] in ['modules', 'plugins', 'widgets', 'triggers', 'ai_providers']:
                    core_ids.add(parts[1])
            self.logger(f"CommunityAddonService loaded {len(core_ids)} core component IDs for protection.", "INFO")
        except Exception as e:
            self.logger(f"CommunityAddonService could not load core component IDs: {e}", "WARN")
        return core_ids
    def upload_component(self, comp_type, component_id, description, tier):
        self.logger(f"CommunityAddonService: Starting upload for {comp_type} '{component_id}' via Supabase...", "INFO")
        if component_id in self.core_component_ids:
            return False, self.loc.get('api_core_component_upload_error')
        if not self.kernel.current_user or not self.kernel.current_user.get('session_token'):
            return False, "You must be logged in to upload a component."
        manager_map = {
            "modules": "module_manager_service", "plugins": "module_manager_service",
            "widgets": "widget_manager_service", "triggers": "trigger_manager_service",
            "ai_providers": "ai_provider_manager_service", "presets": "preset_manager_service"
        }
        manager_service_name = manager_map.get(comp_type)
        if not manager_service_name: return False, f"Could not find a manager for component type '{comp_type}'."
        manager = self.kernel.get_service(manager_service_name)
        if not manager: return False, f"Manager service '{manager_service_name}' not found."
        component_path = None
        manifest_data = None
        if comp_type == 'presets':
            component_path = os.path.join(self.kernel.data_path, "presets", f"{component_id}.json")
            manifest_data = {"id": component_id, "name": component_id, "description": description, "version": "1.0", "tier": tier}
        else:
            component_dirs = {
                'modules': self.kernel.modules_path, 'plugins': self.kernel.plugins_path,
                'widgets': self.kernel.widgets_path, 'triggers': self.kernel.triggers_path,
                'ai_providers': self.kernel.ai_providers_path
            }
            base_path = component_dirs.get(comp_type)
            if base_path:
                potential_path = os.path.join(base_path, component_id)
                if os.path.exists(potential_path):
                    component_path = potential_path
                    manifest_file = os.path.join(component_path, 'manifest.json')
                    if os.path.exists(manifest_file):
                        with open(manifest_file, 'r', encoding='utf-8') as f:
                            manifest_data = json.load(f)
        if not component_path or not os.path.exists(component_path) or not manifest_data:
            return False, f"Component path or manifest not found for: {component_id}"
        diagnostics_plugin = self.kernel.get_service("module_manager_service").get_instance("system_diagnostics_plugin")
        if not diagnostics_plugin: return False, "System Diagnostics plugin not found, cannot perform pre-flight scan."
        scan_successful, scan_report = diagnostics_plugin.scan_single_component_and_get_status(component_path)
        if not scan_successful: return False, f"Pre-upload scan failed:\n{scan_report}"
        self.logger(f"Pre-flight scan passed. Packaging and delegating to Supabase function...", "INFO")
        with tempfile.TemporaryDirectory() as temp_dir:
            zip_filename = f"{component_id}.zip"
            zip_path = os.path.join(temp_dir, zip_filename)
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                if os.path.isdir(component_path):
                    for root, dirs, files in os.walk(component_path):
                        if 'vendor' in dirs:
                            dirs.remove('vendor')
                            self.logger(f"Packaging: Skipping 'vendor' directory inside '{os.path.basename(root)}'.", "DEBUG")
                        for file in files:
                            file_full_path = os.path.join(root, file)
                            arcname = os.path.relpath(file_full_path, component_path)
                            zipf.write(file_full_path, arcname)
                else:
                    zipf.write(component_path, os.path.basename(component_path))
            try:
                upload_endpoint = f"{self.api_client.supabase_url.rstrip('/')}/functions/v1/upload-addon"
                session_token = self.kernel.current_user.get('session_token')
                headers = {
                    'Authorization': f'Bearer {session_token}',
                    'apikey': self.api_client.supabase_key,
                }
                form_data = {
                    "comp_type": comp_type,
                    "component_id": component_id,
                    "description": description,
                    "tier": tier,
                    "manifest_data": json.dumps(manifest_data)
                }
                with open(zip_path, 'rb') as f:
                    files = {'file': (zip_filename, f, 'application/zip')}
                    response = requests.post(upload_endpoint, data=form_data, files=files, headers=headers, timeout=120)
                response.raise_for_status()
                response_json = response.json()
                self.logger(f"Supabase function response: {response_json.get('message')}", "SUCCESS")
                return True, response_json.get('message', "Upload successful!")
            except requests.exceptions.HTTPError as e:
                error_detail = "Unknown server error."
                try:
                    error_detail = e.response.json().get("error", e.response.text)
                except json.JSONDecodeError:
                    error_detail = e.response.text
                if e.response.status_code == 409:
                    self.logger(f"Duplicate component upload detected by server for '{component_id}'.", "WARN")
                    return False, self.loc.get('marketplace_upload_duplicate_error', fallback=f"This component '{component_id}' already exists in the repository.")
                self.logger(f"HTTP error connecting to Supabase function: {e}", "ERROR")
                return False, f"Server error: {error_detail}"
            except Exception as e:
                error_message = f"An unexpected error occurred during upload delegation."
                self.logger(f"Full unexpected error: {e}", "ERROR")
                return False, error_message
    def upload_model(self, model_filepath: str, model_id: str, description: str, tier: str):
        self.logger("Model upload function is not yet refactored for Supabase.", "WARN")
        return False, "Model upload functionality is not yet migrated to the new system."
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\database_service\database_service.py
# JUMLAH BARIS : 63
#######################################################################

```py
import sqlite3
import os
from contextlib import contextmanager
from ..base_service import BaseService
class DatabaseService(BaseService):
    """
    (REPAIRED - FINAL VERSION) Manages the database connection lifecycle.
    This version uses a context manager to ensure a fresh, safe connection
    is provided for every transaction, preventing cross-thread and state issues.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.db_path = os.path.join(self.kernel.data_path, 'flowork_data.db')
        self._initialize_database()
    def _initialize_database(self):
        """Ensures the database file and initial tables exist."""
        try:
            with self.get_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                CREATE TABLE IF NOT EXISTS prompt_templates (
                    id TEXT PRIMARY KEY,
                    name TEXT NOT NULL UNIQUE,
                    content TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
                ''')
                conn.commit()
            self.logger("DatabaseService: Database and tables initialized successfully.", "SUCCESS")
        except Exception as e:
            self.logger(f"CRITICAL FAILURE during DatabaseService initialization: {e}", "CRITICAL")
    @contextmanager
    def get_connection(self):
        """
        Provides a database connection as a context manager,
        ensuring it is always closed and transactions are handled safely.
        """
        conn = None
        try:
            conn = sqlite3.connect(self.db_path)
            conn.row_factory = self._dict_factory
            yield conn
        except Exception as e:
            self.logger(f"Database connection error: {e}", "ERROR")
            raise
        finally:
            if conn:
                conn.close()
    def _dict_factory(self, cursor, row):
        """Helper to return query results as dictionaries."""
        d = {}
        for idx, col in enumerate(cursor.description):
            d[col[0]] = row[idx]
        return d
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\dataset_manager_service\dataset_manager_service.py
# JUMLAH BARIS : 62
#######################################################################

```py
import os
import threading
import json
from ..base_service import BaseService
class DatasetManagerService(BaseService):
    """
    (REFACTORED) Manages CRUD operations for fine-tuning datasets.
    This service was previously misnamed as DatabaseService.
    """
    DB_NAME = "datasets.json"
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.db_path = os.path.join(self.kernel.data_path, self.DB_NAME)
        self.lock = threading.Lock()
    def _read_db(self):
        with self.lock:
            if not os.path.exists(self.db_path):
                return {}
            try:
                with open(self.db_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except (json.JSONDecodeError, IOError):
                return {}
    def _write_db(self, data):
        with self.lock:
            with open(self.db_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=4)
    def list_datasets(self):
        db = self._read_db()
        return [{"name": name} for name in db.keys()]
    def get_dataset_data(self, dataset_name: str):
        db = self._read_db()
        return db.get(dataset_name, [])
    def create_dataset(self, name: str):
        db = self._read_db()
        if name in db:
            return False  # Already exists
        db[name] = []
        self._write_db(db)
        return True
    def add_data_to_dataset(self, dataset_name: str, data_list: list):
        db = self._read_db()
        if dataset_name not in db:
            return False # Dataset does not exist
        db[dataset_name].extend(data_list)
        self._write_db(db)
        return True
    def delete_dataset(self, name: str):
        db = self._read_db()
        if name in db:
            del db[name]
            self._write_db(db)
            return True # Deletion successful
        return False # Dataset not found
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\diagnostics_service\diagnostics_service.py
# JUMLAH BARIS : 87
#######################################################################

```py
import os
import re
import importlib
import inspect
import sys
import time
from ..base_service import BaseService
from scanners.base_scanner import BaseScanner
class DiagnosticsService(BaseService):
    """
    A dedicated service to discover and run all system diagnostic scanners.
    This service centralizes the logic previously held by the system_diagnostics_plugin.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.logger(f"Service '{self.service_id}' initialized.", "DEBUG")
    def _discover_scanners(self):
        """Helper to discover all available scanner classes from the new top-level directory."""
        all_scanners = []
        scanners_dir = os.path.join(self.kernel.project_root_path, 'scanners')
        if os.path.isdir(scanners_dir):
            if scanners_dir not in sys.path:
                sys.path.insert(0, scanners_dir)
            for entry in os.scandir(scanners_dir):
                if entry.name.endswith('.py') and not entry.name.startswith('__'):
                    module_name = entry.name[:-3]
                    try:
                        module = importlib.import_module(module_name)
                        for name, obj in inspect.getmembers(module, inspect.isclass):
                            if issubclass(obj, BaseScanner) and obj is not BaseScanner:
                                all_scanners.append(obj)
                    except Exception as e:
                        self.logger(f"DiagnosticsService: Failed to import scanner from '{entry.name}': {e}", "ERROR")
        return all_scanners
    def start_scan_headless(self, scan_id: str, target_scanner_id: str = None) -> dict:
        """
        Runs all or a specific scanner module synchronously and returns a dictionary with the results.
        This is designed to be called by an API endpoint.
        """
        log_target = 'ALL' if not target_scanner_id else target_scanner_id.upper()
        self.logger(f"API-DIAG: Starting Headless Scan for ID: {scan_id} (Target: {log_target})", "INFO")
        report_lines = []
        def headless_report_handler(message, level, context=None):
            report_lines.append(f"[{level}] {message}")
        summaries = []
        all_scanners = self._discover_scanners()
        if not all_scanners:
            headless_report_handler("No scanner modules found.", "ERROR")
        scanners_to_run = []
        if target_scanner_id:
            found = False
            for scanner_class in all_scanners:
                class_id = re.sub(r'([a-z0-9])([A-Z])', r'\1_\2', scanner_class.__name__.replace("Core", "")).lower()
                class_id = class_id.replace("_scan", "")
                if class_id == target_scanner_id:
                    scanners_to_run.append(scanner_class)
                    found = True
                    break
            if not found:
                headless_report_handler(f"Scanner with ID '{target_scanner_id}' not found.", "ERROR")
        else:
            scanners_to_run = all_scanners
        for scanner_class in scanners_to_run:
            try:
                scanner_instance = scanner_class(self.kernel, headless_report_handler)
                summary = scanner_instance.run_scan()
                summaries.append(summary)
            except Exception as e:
                summary = f"FATAL ERROR while running {scanner_class.__name__}: {e}"
                summaries.append(summary)
                headless_report_handler(summary, "ERROR")
        full_report_str = "\n".join(report_lines)
        final_summary = "\n".join(summaries)
        result_data = {
            "scan_id": scan_id, "status": "completed", "timestamp": time.time(),
            "summary": final_summary, "full_log": full_report_str
        }
        self.logger(f"API-DIAG: Scan {scan_id} complete. Returning results.", "SUCCESS")
        return result_data
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\documentation_service\documentation_service.py
# JUMLAH BARIS : 80
#######################################################################

```py
import os
import subprocess
import threading
from ..base_service import BaseService
import platform
import signal
class DocumentationService(BaseService):
    """
    A service that automatically runs 'mkdocs serve' in the background
    during development to provide live documentation.
    (FIXED V2) Now uses robust process management to ensure the mkdocs
    child process is terminated when the main application exits, even if
    the console window is closed abruptly.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.process = None
        self.dev_mode = self.kernel.is_dev_mode
        if not self.dev_mode:
            self.logger("DocumentationService: 'devmode.on' not found. Documentation server will not be started.", "INFO")
    def start(self):
        """Starts the mkdocs serve process in a background thread if in dev mode."""
        if not self.dev_mode:
            return
        project_root = self.kernel.project_root_path
        if not os.path.exists(os.path.join(project_root, 'mkdocs.yml')):
            self.logger("DocumentationService: mkdocs.yml not found. Skipping server start.", "WARN")
            return
        thread = threading.Thread(target=self._run_mkdocs_serve, daemon=True)
        thread.start()
    def _run_mkdocs_serve(self):
        """The actual worker that runs the subprocess with improved termination handling."""
        self.logger("DocumentationService: Starting 'mkdocs serve' in the background...", "INFO")
        command = ['poetry', 'run', 'mkdocs', 'serve']
        creation_flags = 0
        if platform.system() == "Windows":
            creation_flags = subprocess.CREATE_NEW_PROCESS_GROUP | subprocess.CREATE_NO_WINDOW
        try:
            self.process = subprocess.Popen(
                command,
                cwd=self.kernel.project_root_path,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8',
                creationflags=creation_flags # (DIPERBAIKI) Terapkan flag di sini
            )
            self.logger(f"DocumentationService: 'mkdocs serve' is running with PID: {self.process.pid}", "SUCCESS")
        except FileNotFoundError:
            self.logger("DocumentationService: 'poetry' command not found. Make sure you are in a Poetry environment.", "CRITICAL")
        except Exception as e:
            self.logger(f"DocumentationService: Failed to start 'mkdocs serve': {e}", "CRITICAL")
    def stop(self):
        """
        (DIPERBAIKI) Stops the mkdocs serve process more forcefully to prevent zombie processes.
        """
        if self.process and self.process.poll() is None:
            self.logger(f"DocumentationService: Stopping 'mkdocs serve' process (PID: {self.process.pid})...", "INFO")
            try:
                if platform.system() == "Windows":
                    self.process.send_signal(signal.CTRL_BREAK_EVENT)
                else:
                    os.killpg(os.getpgid(self.process.pid), signal.SIGTERM)
                self.process.wait(timeout=3)
                self.logger("DocumentationService: Process terminated gracefully.", "SUCCESS")
            except (ProcessLookupError, PermissionError):
                 self.logger("DocumentationService: Process was already gone before it could be stopped.", "INFO")
            except subprocess.TimeoutExpired:
                self.logger("DocumentationService: Process did not terminate in time, forcing kill.", "WARN")
                self.process.kill() # Cara paling sadis
            except Exception as e:
                self.logger(f"DocumentationService: An unexpected error occurred during shutdown: {e}", "ERROR")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\event_bus_service\event_bus_service.py
# JUMLAH BARIS : 50
#######################################################################

```py
import json
import threading
from typing import Dict, Any, Callable
from ..base_service import BaseService
class EventBusService(BaseService):
    """
    Service that provides a centralized message bus for different parts of the application
    to communicate without being directly coupled.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self._subscribers: Dict[str, Dict[str, Callable]] = {}
        self.kernel.write_to_log("Service 'EventBus' initialized.", "DEBUG")
    def publish(self, event_name: str, event_data: Dict[str, Any], publisher_id: str = "SYSTEM"):
        """
        Publishes an event to all registered subscribers.
        Args:
            event_name (str): The name of the event to publish.
            event_data (Dict[str, Any]): The data payload to send with the event.
            publisher_id (str): The ID of the module or service publishing the event.
        """
        self.kernel.write_to_log(f"EVENT PUBLISHED: Name='{event_name}', Publisher='{publisher_id}'", "INFO")
        self.kernel.write_to_log(f"EVENT DATA: {json.dumps(event_data, indent=2)}", "DETAIL")
        if event_name in self._subscribers:
            for subscriber_id, callback in list(self._subscribers[event_name].items()):
                self.kernel.write_to_log(f"EventBus: Notifying subscriber '{subscriber_id}' for event '{event_name}'...", "DEBUG")
                try:
                    threading.Thread(target=callback, args=(event_data,)).start()
                except Exception as e:
                    self.kernel.write_to_log(f"Error executing subscriber '{subscriber_id}' for event '{event_name}': {e}", "ERROR")
    def subscribe(self, event_name: str, subscriber_id: str, callback: Callable):
        """
        Subscribes a component to a specific event.
        Args:
            event_name (str): The name of the event to subscribe to.
            subscriber_id (str): A unique ID for the subscriber to prevent duplicates.
            callback (Callable): The function to call when the event is published.
        """
        if event_name not in self._subscribers:
            self._subscribers[event_name] = {}
        self._subscribers[event_name][subscriber_id] = callback
        self.kernel.write_to_log(f"SUBSCRIBE: Component '{subscriber_id}' successfully subscribed to event '{event_name}'.", "INFO")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\integrity_checker_service\integrity_checker_service.py
# JUMLAH BARIS : 66
#######################################################################

```py
import os
import json
import hashlib
from ..base_service import BaseService
class IntegrityCheckerService(BaseService):
    """
    Implements the "Benteng Baja" (Steel Fortress) strategy.
    [V3] Now performs a two-layer check. It loads the core manifest and
    also loads the addon manifest if it exists, merging them for a full system verification.
    [V4] Now respects dev mode from the Kernel.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.core_manifest_path = os.path.join(self.kernel.project_root_path, "core_integrity.json")
        self.addon_manifest_path = os.path.join(self.kernel.project_root_path, "addon_integrity.json")
    def _calculate_sha256(self, file_path):
        """Calculates the SHA-256 hash of a file."""
        sha256_hash = hashlib.sha256()
        try:
            with open(file_path, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            return sha256_hash.hexdigest()
        except FileNotFoundError:
            return None
    def verify_core_files(self):
        """
        [MODIFIED] The main verification method now loads both core and addon manifests.
        It verifies that all files listed in both manifests exist and are unchanged.
        It will be SKIPPED if the kernel is in dev mode.
        """
        if self.kernel.is_dev_mode:
            self.kernel.write_to_log("Benteng Baja: DEVELOPMENT MODE ACTIVE. Skipping all file integrity checks.", "WARN") # English Log
            return
        self.kernel.write_to_log("Benteng Baja: Verifying file integrity (Two-Layer Check)...", "INFO") # English Log
        full_integrity_manifest = {}
        if not os.path.exists(self.core_manifest_path):
            raise RuntimeError("Benteng Baja FAILED: Core integrity manifest 'core_integrity.json' not found. Application cannot run securely.")
        with open(self.core_manifest_path, 'r', encoding='utf-8') as f:
            core_manifest = json.load(f)
            full_integrity_manifest.update(core_manifest)
            self.kernel.write_to_log(f"Benteng Baja: Loaded {len(core_manifest)} core engine file hashes.", "DEBUG") # English Log
        if os.path.exists(self.addon_manifest_path):
            try:
                 with open(self.addon_manifest_path, 'r', encoding='utf-8') as f:
                    addon_manifest = json.load(f)
                    full_integrity_manifest.update(addon_manifest)
                    self.kernel.write_to_log(f"Benteng Baja: Loaded {len(addon_manifest)} addon file hashes.", "DEBUG") # English Log
            except Exception as e:
                self.kernel.write_to_log(f"Benteng Baja: Could not load addon_integrity.json: {e}", "WARN") # English Log
        for rel_path, expected_hash in full_integrity_manifest.items():
            full_path = os.path.join(self.kernel.project_root_path, rel_path.replace("/", os.sep))
            current_hash = self._calculate_sha256(full_path)
            if current_hash is None:
                raise RuntimeError(f"Integrity Check Failed: Core file '{rel_path}' is missing from disk but listed in the manifest.")
            if current_hash != expected_hash:
                raise RuntimeError(f"Integrity Check Failed: Core file '{rel_path}' has been modified or is corrupt.")
        self.kernel.write_to_log(f"Benteng Baja: All {len(full_integrity_manifest)} registered files passed integrity check.", "SUCCESS") # English Log
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\license_manager_service\license_manager_service.py
# JUMLAH BARIS : 263
#######################################################################

```py
import os
import json
import base64
import uuid
import platform
import hashlib
import time
import datetime
import requests
import shutil
from tkinter import messagebox
from ..base_service import BaseService
from flowork_kernel.exceptions import SignatureVerificationError
from flowork_kernel.api_client import ApiClient
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from flowork_kernel.kernel import Kernel
try:
    from cryptography.hazmat.primitives import hashes as crypto_hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import padding
    from cryptography.exceptions import InvalidSignature
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False
class LicenseManagerService(BaseService):
    LICENSE_PUBLIC_KEY_PEM_STRING = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAysqZG2+F82W0TgLHmF3Y
0GRPEZvXvmndTY84N/wA1ljt+JxMBVsmcVTkv8f1TrmFRD19IDzl2Yzb2lgqEbEy
GFxHhudC28leDsVEIp8B+oYWVm8Mh242YKYK8r5DAvr9CPQivnIjZ4BWgKKddMTd
harVxLF2CoSoTs00xWKd6VlXfoW9wdBvoDVifL+hCMepgLLdQQE4HbamPDJ3bpra
pCgcAD5urmVoJEUJdjd+Iic27RBK7jD1dWDO2MASMh/0IyXyM8i7RDymQ88gZier
U0OdWzeCWGyl4EquvR8lj5GNz4vg2f+oEY7h9AIC1f4ARtoihc+apSntqz7nAqa/
sQIDAQAB
-----END PUBLIC KEY-----"""
    REMOTE_CONFIG_PUBLIC_KEY_PEM_STRING = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAysqZG2+F82W0TgLHmF3Y
0GRPEZvXvmndTY84N/wA1ljt+JxMBVsmcVTkv8f1TrmFRD19IDzl2Yzb2lgqEbEy
GFxHhudC28leDsVEIp8B+oYWVm8Mh242YKYK8r5DAvr9CPQivnIjZ4BWgKKddMTd
harVxLF2CoSoTs00xWKd6VlXfoW9wdBvoDVifL+hCMepgLLdQQE4HbamPDJ3bpra
pCgcAD5urmVoJEUJdjd+Iic27RBK7jD1dWDO2MASMh/0IyXyM8i7RDymQ88gZier
U0OdWzeCWGyl4EquvR8lj5GNz4vg2f+oEY7h9AIC1f4ARtoihc+apSntqz7nAqa/
sQIDAQAB
-----END PUBLIC KEY-----"""
    LICENSE_FILE_NAME = "license.seal"
    REMOTE_TIER_CONFIG_URL = "https://raw.githubusercontent.com/FLOWORK-gif/ASSET/refs/heads/main/flowork_tier_config.json"
    REMOTE_TIER_SIGNATURE_URL = "https://raw.githubusercontent.com/FLOWORK-gif/ASSET/refs/heads/main/flowork_tier_config.sig"
    def __init__(self, kernel: 'Kernel', service_id: str):
        super().__init__(kernel, service_id)
        self.logger = self.kernel.write_to_log
        self.license_public_key = None
        self.config_public_key = None
        self.license_data = {}
        self.is_local_license_valid = False
        self.server_error = None
        self.remote_permission_rules = None
        self.api_client = ApiClient(kernel=self.kernel)
        self._load_public_keys()
    def _fetch_remote_tier_config(self):
        try:
            self.logger("LicenseManager: Fetching remote tier configuration and signature...", "INFO")
            config_response = requests.get(self.REMOTE_TIER_CONFIG_URL, timeout=10)
            config_response.raise_for_status()
            config_content_bytes = config_response.content
            sig_response = requests.get(self.REMOTE_TIER_SIGNATURE_URL, timeout=10)
            sig_response.raise_for_status()
            signature_b64 = sig_response.text.strip()
            if not self.config_public_key:
                raise SignatureVerificationError("Config public key is not loaded. Cannot verify remote config.")
            signature_bytes = base64.b64decode(signature_b64)
            self.config_public_key.verify(signature_bytes, config_content_bytes, padding.PKCS1v15(), crypto_hashes.SHA256())
            self.remote_permission_rules = json.loads(config_content_bytes)
            self.logger("LicenseManager: Remote tier configuration loaded and signature VERIFIED successfully.", "SUCCESS")
            return True
        except Exception as e:
            self.logger(f"LicenseManager: CRITICAL: Could not fetch or verify remote config: {e}. Defaulting to SECURE mode (Monetization ON).", "CRITICAL")
            self.remote_permission_rules = {"monetization_active": True}
            return False
    def verify_license_on_startup(self):
        self.logger("LicenseManager: Starting license verification process V6 (Expiry Aware)...", "INFO")
        self._fetch_remote_tier_config()
        monetization_is_active = self.remote_permission_rules and self.remote_permission_rules.get("monetization_active", True)
        if not monetization_is_active:
            override_tier = self.remote_permission_rules.get("default_tier_override", "architect")
            self.kernel.is_premium = True
            self.kernel.license_tier = override_tier
            self.logger(f"Monetization is INACTIVE. Granting full access with tier: '{override_tier}'.", "WARN")
            return
        self.logger("Monetization is ACTIVE. Verifying user's tier...", "INFO")
        if self.kernel.current_user:
            user_tier = self.kernel.current_user.get('tier', 'free')
            expires_at_str = self.kernel.current_user.get('license_expires_at')
            is_expired = False
            if expires_at_str:
                try:
                    expiry_date = datetime.datetime.fromisoformat(expires_at_str.replace('Z', '+00:00'))
                    if datetime.datetime.now(datetime.timezone.utc) > expiry_date:
                        is_expired = True
                        self.logger(f"User {self.kernel.current_user.get('email')}'s license has EXPIRED on {expiry_date}.", "WARN")
                except Exception as e:
                    self.logger(f"Could not parse license expiry date '{expires_at_str}': {e}", "ERROR")
            if is_expired:
                user_tier = 'free'
            self.kernel.license_tier = user_tier
            self.kernel.is_premium = self.kernel.TIER_HIERARCHY.get(user_tier, 0) > 0
            self.logger(f"User is logged in. Tier confirmed as '{user_tier.upper()}'.", "SUCCESS")
            return
        local_data = self._verify_local_license_file()
        if local_data:
            self.logger("Local license file found and signature is valid. Now verifying activation status with server...", "INFO")
            license_key = local_data.get('license_key')
            machine_id = self._get_machine_id()
            if not license_key:
                self.logger("Local license is invalid (missing license_key). Deleting file.", "ERROR")
                os.remove(self._get_license_file_path())
                self.is_local_license_valid = False
            else:
                is_valid_on_server, server_message = self.validate_local_license_online(license_key, machine_id)
                if is_valid_on_server:
                    self.is_local_license_valid = True
                    self.license_data = local_data
                    self.kernel.license_tier = local_data.get('tier', 'free')
                    self.kernel.is_premium = self.kernel.TIER_HIERARCHY.get(self.kernel.license_tier, 0) > 0
                    self.logger(f"Server confirmed license activation. Tier set to '{self.kernel.license_tier.upper()}'.", "SUCCESS")
                else:
                    self.logger(f"Server rejected local license. Reason: {server_message}. Deleting local license file.", "WARN")
                    os.remove(self._get_license_file_path())
                    self.is_local_license_valid = False
                    self.kernel.is_premium = False
                    self.kernel.license_tier = "free"
        else:
            self.is_local_license_valid = False
            self.kernel.is_premium = False
            self.kernel.license_tier = "free"
            self.logger("No logged-in user and no valid local license. App will run in free mode.", "WARN")
    def _load_public_keys(self):
        if not CRYPTO_AVAILABLE:
            self.logger("Cryptography library not found. Security features will be disabled.", "CRITICAL")
            return
        try:
            pem_data = self.LICENSE_PUBLIC_KEY_PEM_STRING.strip().encode('utf-8')
            self.license_public_key = serialization.load_pem_public_key(pem_data)
            self.logger("Public key for license verification loaded successfully.", "SUCCESS")
        except Exception as e:
            self.license_public_key = None
            self.logger(f"Failed to load license public key: {e}. License verification will fail.", "ERROR")
        try:
            pem_data = self.REMOTE_CONFIG_PUBLIC_KEY_PEM_STRING.strip().encode('utf-8')
            self.config_public_key = serialization.load_pem_public_key(pem_data)
            self.logger("Public key for remote config verification loaded successfully.", "SUCCESS")
        except Exception as e:
            self.config_public_key = None
            self.logger(f"Failed to load remote config public key: {e}. Remote config verification will fail.", "ERROR")
    def _get_machine_id(self) -> str:
        try:
            mac = ':'.join(['{:02x}'.format((uuid.getnode() >> i) & 0xff) for i in range(0, 8 * 6, 8)][::-1])
            machine_id = hashlib.sha256(mac.encode()).hexdigest()
            self.logger(f"Generated Machine ID: {machine_id[:12]}...", "DEBUG")
            return machine_id
        except Exception as e:
            self.logger(f"Could not generate machine ID: {e}. Using a fallback ID.", "WARN")
            return hashlib.sha256("fallback_flowork_synapse_id".encode()).hexdigest()
    def _get_license_file_path(self):
        return os.path.join(self.kernel.data_path, self.LICENSE_FILE_NAME)
    def _verify_local_license_file(self):
        if not self.license_public_key: return None
        license_path = self._get_license_file_path()
        if not os.path.exists(license_path): return None
        try:
            with open(license_path, 'r', encoding='utf-8') as f: content = json.load(f)
            data_to_verify = content.get('data'); signature_b64 = content.get('signature')
            if not data_to_verify or not signature_b64: return None
            data_bytes = json.dumps(data_to_verify, separators=(',', ':')).encode('utf-8')
            signature_bytes = base64.b64decode(signature_b64)
            self.license_public_key.verify(signature_bytes, data_bytes, padding.PKCS1v15(), crypto_hashes.SHA256())
            return data_to_verify
        except Exception as e:
            self.logger(f"CRITICAL: License file tampered with or invalid. Deleting it. Error: {e}", "CRITICAL")
            try: os.remove(license_path)
            except OSError: pass
            return None
    def validate_local_license_online(self, license_key: str, machine_id: str) -> (bool, str):
        self.logger(f"Validating license key '{license_key[:8]}...' for machine '{machine_id[:8]}...' with Supabase.", "INFO")
        function_url = f"{self.api_client.supabase_url}/functions/v1/validate-license-activation"
        headers = self.api_client._get_supabase_headers()
        payload = {"license_key": license_key, "machine_id": machine_id}
        try:
            response = requests.post(function_url, headers=headers, json=payload, timeout=20)
            if response.status_code == 200:
                return True, "License is valid for this machine."
            else:
                error_msg = response.json().get("error", "Unknown validation error.")
                return False, error_msg
        except requests.exceptions.RequestException as e:
            return False, f"Could not connect to validation server: {e}"
        except Exception as e:
            return False, f"An unexpected error occurred during validation: {e}"
    def activate_license_on_server(self, full_license_content: dict):
        if not self.kernel.current_user or not self.kernel.current_user.get('session_token'):
            return False, "You must be logged in to activate a new license."
        self.logger("Attempting to activate license via Supabase Edge Function...", "INFO")
        function_url = f"{self.api_client.supabase_url}/functions/v1/activate-license"
        session_token = self.kernel.current_user.get('session_token')
        headers = {
            'Authorization': f'Bearer {session_token}',
            'apikey': self.api_client.supabase_key,
            'Content-Type': 'application/json'
        }
        payload = {
            "license_content": full_license_content,
            "machine_id": self._get_machine_id()
        }
        try:
            response = requests.post(function_url, headers=headers, json=payload, timeout=20)
            if response.status_code != 200:
                error_msg = response.json().get("error", "Unknown activation error from server.")
                raise Exception(error_msg)
            with open(self._get_license_file_path(), 'w', encoding='utf-8') as f:
                json.dump(full_license_content, f, indent=4)
            self.logger("License activated on Supabase and file saved locally.", "SUCCESS")
            success_refresh, user_data = self.api_client.get_user_profile_by_token(session_token)
            if success_refresh:
                self.kernel.current_user = user_data
                self.verify_license_on_startup()
            return True, "License activated successfully. Please restart the application."
        except Exception as e:
            self.logger(f"Supabase function call for activation failed: {e}", "ERROR")
            return False, f"Could not activate license on server: {e}"
    def deactivate_license_on_server(self):
        if not self.kernel.current_user or not self.kernel.current_user.get('session_token'):
            return False, "You must be logged in to deactivate a license."
        function_url = f"{self.api_client.supabase_url}/functions/v1/deactivate-license"
        session_token = self.kernel.current_user.get('session_token')
        headers = {
            'Authorization': f'Bearer {session_token}',
            'apikey': self.api_client.supabase_key
        }
        try:
            response = requests.post(function_url, headers=headers, timeout=20)
            if response.status_code != 200:
                raise Exception(response.json().get("error", "Unknown deactivation error from server."))
            local_license_path = self._get_license_file_path()
            if os.path.exists(local_license_path):
                os.remove(local_license_path)
            self.logger("Deactivation success, updating kernel state immediately.", "INFO")
            self.kernel.license_tier = "free"
            self.kernel.is_premium = False
            if self.kernel.current_user:
                self.kernel.current_user['tier'] = 'free'
            event_bus = self.kernel.get_service("event_bus")
            if event_bus:
                event_bus.publish("REQUEST_CLEANUP_AND_EXIT", {"reason": "deactivation"})
            return True, "License deactivated successfully. The application will now close."
        except Exception as e:
            self.logger(f"Supabase function call for deactivation failed: {e}", "ERROR")
            return False, f"An error occurred during deactivation: {e}"
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\localization_manager_service\localization_manager_service.py
# JUMLAH BARIS : 163
#######################################################################

```py
import os
import json
from ..base_service import BaseService
class LocalizationManagerService(BaseService):
    """
    Manages all multilingual application text from a centralized source and standalone modules.
    This service is critical and must be loaded early in the kernel's lifecycle.
    [FIXED] Now correctly scans the 'triggers' directory for localization files.
    [FIXED V2] Now correctly scans ALL component directories including plugins and ai_providers.
    """
    SETTINGS_FILE = "settings.json"
    SETTINGS_DIR_NAME = "data"
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.locales_path = self.kernel.locales_path
        self.settings_dir = self.kernel.data_path
        self.settings_file_path = os.path.join(self.settings_dir, self.SETTINGS_FILE)
        self.languages = {}
        self.current_lang = "en"
        self._settings_cache = {}
        self.language_map = {
            "en": "English",
            "id": "Bahasa Indonesia"
        }
        os.makedirs(self.locales_path, exist_ok=True)
        os.makedirs(self.settings_dir, exist_ok=True)
        self.kernel.write_to_log("Service 'LocalizationManager' initialized.", "DEBUG") # English Log
        self.load_base_languages()
        self._load_settings()
    def get_available_languages_display(self):
        return [self.language_map[lang_code] for lang_code in self.languages.keys() if lang_code in self.language_map]
    def get_current_language_code(self):
        return self.current_lang
    def load_base_languages(self):
        self.kernel.write_to_log("LocalizationManager: Loading base languages...", "DEBUG") # English Log
        for filename in os.listdir(self.locales_path):
            if filename.endswith(".json"):
                lang_id = os.path.splitext(filename)[0]
                filepath = os.path.join(self.locales_path, filename)
                try:
                    with open(filepath, 'r', encoding='utf-8') as f:
                        if lang_id not in self.languages:
                            self.languages[lang_id] = {}
                        self.languages[lang_id].update(json.load(f))
                except Exception as e:
                    self.kernel.write_to_log(f"Failed to load base language '{lang_id}': {e}", "ERROR") # English Log
        if "en" not in self.languages:
            self.kernel.write_to_log("Warning: Base language file 'en.json' not found. Creating emergency entry.", "WARN") # English Log
            self.languages["en"] = {"app_title": "Flowork (Fallback)"}
    def load_all_languages(self):
        self.kernel.write_to_log("LocalizationManager: Starting language scan and merge...", "INFO") # English Log
        self.languages.clear()
        self.load_base_languages()
        module_manager = self.kernel.get_service("module_manager_service")
        plugin_manager = self.kernel.get_service("plugin_manager_service")
        widget_manager = self.kernel.get_service("widget_manager_service")
        trigger_manager = self.kernel.get_service("trigger_manager_service")
        ai_provider_manager = self.kernel.get_service("ai_provider_manager_service")
        items_to_scan = {}
        if module_manager: items_to_scan.update(module_manager.loaded_modules)
        if plugin_manager: items_to_scan.update(plugin_manager.loaded_plugins)
        if widget_manager: items_to_scan.update(widget_manager.loaded_widgets)
        if trigger_manager: items_to_scan.update(trigger_manager.loaded_triggers)
        if ai_provider_manager:
            for provider_id, provider_instance in ai_provider_manager.loaded_providers.items():
                if hasattr(provider_instance, 'manifest') and 'path' in provider_instance.manifest:
                     items_to_scan[provider_id] = {'path': provider_instance.manifest['path']}
        for item_id, item_data in items_to_scan.items():
            if isinstance(item_data, dict) and item_data.get('is_paused', False):
                continue
            component_path = item_data.get('path') if isinstance(item_data, dict) else None
            if not component_path:
                continue
            module_locales_path = os.path.join(component_path, 'locales')
            if os.path.isdir(module_locales_path):
                for filename in os.listdir(module_locales_path):
                    if filename.endswith(".json"):
                        lang_id = os.path.splitext(filename)[0]
                        filepath = os.path.join(module_locales_path, filename)
                        try:
                            with open(filepath, 'r', encoding='utf-8') as f:
                                item_lang_data = json.load(f)
                                if lang_id not in self.languages:
                                    self.languages[lang_id] = {}
                                self.languages[lang_id].update(item_lang_data)
                        except Exception as e:
                            self.kernel.write_to_log(f"Failed to merge language '{lang_id}' from '{item_id}': {e}", "ERROR") # English Log
        self.kernel.write_to_log("LocalizationManager: Language merge complete.", "INFO") # English Log
    def set_language(self, lang_id):
        if lang_id in self.languages:
            self.current_lang = lang_id
            self.save_setting("language", lang_id)
            self.kernel.write_to_log(f"LocalizationManager: Language set to '{lang_id}'.", "INFO") # English Log
            return True
        self.kernel.write_to_log(f"LocalizationManager: Language '{lang_id}' not found.", "WARN") # English Log
        return False
    def get(self, key, fallback=None, **kwargs):
        stripped_key = key.strip()
        lang_data = self.languages.get(self.current_lang)
        if lang_data and stripped_key in lang_data:
            text = lang_data[stripped_key]
            return text.format(**kwargs) if kwargs else text
        lang_data_en = self.languages.get("en")
        if lang_data_en and stripped_key in lang_data_en:
            return lang_data_en[stripped_key].format(**kwargs) if kwargs else lang_data_en[stripped_key]
        if fallback is not None:
            if isinstance(fallback, str):
                return fallback.format(**kwargs) if kwargs else fallback
            return fallback
        return f"[{key}]"
    def _load_settings(self):
        try:
            current_settings = {}
            if os.path.exists(self.settings_file_path):
                with open(self.settings_file_path, 'r', encoding='utf-8') as f:
                    current_settings = json.load(f)
            defaults = {
                "language": "id", "theme": "flowork_default", "webhook_enabled": False,
                "webhook_port": 8989, "global_error_handler_enabled": False,
                "global_error_workflow_preset": "", "premium_license_active": False,
                "premium_expiry_date": None, "premium_user_email": None,
                "last_run_time": None, "notifications_enabled": True,
                "notifications_duration_seconds": 5, "notifications_position": "bottom_right",
                "license_seal": None
            }
            settings_changed = False
            for key, value in defaults.items():
                if key not in current_settings:
                    current_settings[key] = value
                    settings_changed = True
            if settings_changed:
                with open(self.settings_file_path, 'w', encoding='utf-8') as f:
                    json.dump(current_settings, f, indent=4)
            self._settings_cache = current_settings
            loaded_lang = self._settings_cache.get("language", "id")
            if loaded_lang in self.languages:
                self.current_lang = loaded_lang
            else:
                self.current_lang = "id"
        except Exception as e:
            self.kernel.write_to_log(f"LocalizationManager: Failed to load settings: {e}", "ERROR") # English Log
            self._settings_cache = {}
    def _save_settings(self, settings_to_save):
        try:
            with open(self.settings_file_path, 'w', encoding='utf-8') as f:
                json.dump(settings_to_save, f, indent=4)
            self._settings_cache = settings_to_save
        except Exception as e:
            self.kernel.write_to_log(f"LocalizationManager: Failed to save settings: {e}", "ERROR") # English Log
    def save_setting(self, key, value):
        current_settings = self._settings_cache.copy()
        current_settings[key] = value
        self._save_settings(current_settings)
    def get_setting(self, key, default=None):
        return self._settings_cache.get(key, default)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\model_converter_service\model_converter_service.py
# JUMLAH BARIS : 139
#######################################################################

```py
import os
import threading
import uuid
import subprocess
import sys
from ..base_service import BaseService
class ModelConverterService(BaseService):
    """
    Manages the conversion of fine-tuned models to the GGUF format.
    [FIXED V2] Uses subprocess.run to prevent hangs from stdout pipe buffer overflow.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.logger = self.kernel.write_to_log
        self.conversion_jobs = {}
        self.job_lock = threading.Lock()
        self.llama_cpp_path = os.path.join(self.kernel.project_root_path, "vendor", "llama.cpp")
        self.is_ready = self._check_dependencies()
        if not self.is_ready:
            self.logger("ModelConverterService is NOT READY. Dependencies are missing. Please check the logs.", "CRITICAL")
        else:
            self.logger("ModelConverterService is ready. All dependencies found.", "SUCCESS")
    def _check_dependencies(self):
        self.logger("ModelConverterService: Checking for llama.cpp dependencies...", "INFO")
        convert_script_path = os.path.join(self.llama_cpp_path, "convert_hf_to_gguf.py")
        quantize_executable_path = os.path.join(self.llama_cpp_path, "build", "bin", "Release", "llama-quantize")
        if sys.platform == "win32" and not os.path.exists(quantize_executable_path):
            quantize_executable_path += ".exe"
        all_found = True
        if not os.path.exists(convert_script_path):
            self.logger(f"Dependency check FAILED: 'convert_hf_to_gguf.py' not found at '{convert_script_path}'.", "ERROR")
            all_found = False
        if not os.path.exists(quantize_executable_path):
            self.logger(f"Dependency check FAILED: 'llama-quantize' executable not found at '{quantize_executable_path}'. Make sure llama.cpp is compiled successfully.", "ERROR")
            all_found = False
        return all_found
    def start_requantize_job(self, source_gguf_path: str, output_gguf_name: str, quantize_method: str = "Q4_K_M"):
        if not self.is_ready:
            return {"error": "ModelConverterService is not ready. Check logs for llama.cpp dependencies."}
        if self.job_lock.locked():
            return {"error": "Another conversion or quantization job is already in progress."}
        job_id = f"requantize-{uuid.uuid4()}"
        self.conversion_jobs[job_id] = {
            "status": "QUEUED", "progress": 0, "message": "Re-quantization job has been queued.",
            "source_model": source_gguf_path, "output_name": output_gguf_name, "log": []
        }
        thread = threading.Thread(target=self._requantize_worker, args=(job_id, source_gguf_path, output_gguf_name, quantize_method), daemon=True)
        thread.start()
        self.logger(f"Started re-quantization job {job_id} for model '{os.path.basename(source_gguf_path)}'.", "INFO")
        return {"job_id": job_id}
    def start_conversion_job(self, source_model_folder: str, output_gguf_name: str, quantize_method: str = "Q4_K_M"):
        if not self.is_ready:
            return {"error": "ModelConverterService is not ready. Check application logs for details on missing dependencies (llama.cpp)."}
        if self.job_lock.locked():
            return {"error": "Another conversion job is already in progress. Please wait."}
        job_id = f"convert-{uuid.uuid4()}"
        self.conversion_jobs[job_id] = {
            "status": "QUEUED", "progress": 0, "message": "Job has been queued.",
            "source_model": source_model_folder, "output_name": output_gguf_name, "log": []
        }
        thread = threading.Thread(target=self._conversion_worker, args=(job_id, source_model_folder, output_gguf_name, quantize_method), daemon=True)
        thread.start()
        self.logger(f"Started model conversion job {job_id} for model '{source_model_folder}'.", "INFO")
        return {"job_id": job_id}
    def get_job_status(self, job_id: str):
        return self.conversion_jobs.get(job_id, {"error": "Job not found."})
    def _log_job_update(self, job_id, message, level="INFO"):
        self.logger(f"Job {job_id}: {message}", level)
        if job_id in self.conversion_jobs:
            self.conversion_jobs[job_id]['message'] = message
            self.conversion_jobs[job_id]['log'].append(message)
    def _run_subprocess(self, job_id, command):
        """ (MODIFIKASI) Uses subprocess.run to prevent hangs from pipe buffer overflow. """
        self.logger(f"Executing command for job {job_id}: {' '.join(command)}", "DETAIL")
        process = subprocess.run(command, capture_output=True, text=True, encoding='utf-8', errors='replace')
        for line in process.stdout.splitlines():
            self._log_job_update(job_id, line, "DETAIL")
        if process.returncode != 0:
            self.logger(f"Subprocess for job {job_id} failed with stderr:\n{process.stderr}", "ERROR")
            raise subprocess.CalledProcessError(process.returncode, command, output=process.stdout, stderr=process.stderr)
    def _requantize_worker(self, job_id, source_gguf_path, output_gguf_name, quantize_method):
        self.job_lock.acquire()
        try:
            output_folder = os.path.dirname(source_gguf_path)
            final_gguf_path = os.path.join(output_folder, f"{output_gguf_name}.gguf")
            quantize_executable = os.path.join(self.llama_cpp_path, "build", "bin", "Release", "llama-quantize")
            if sys.platform == "win32" and not os.path.exists(quantize_executable):
                quantize_executable += ".exe"
            command_quantize = [quantize_executable, source_gguf_path, final_gguf_path, quantize_method]
            self.conversion_jobs[job_id]["status"] = "RUNNING"
            self._log_job_update(job_id, f"Quantizing model to {quantize_method}...")
            self._run_subprocess(job_id, command_quantize)
            self.conversion_jobs[job_id]["status"] = "COMPLETED"
            self._log_job_update(job_id, f"Quantization complete! Model saved to {final_gguf_path}", "SUCCESS")
        except Exception as e:
            self.conversion_jobs[job_id]["status"] = "FAILED"
            self._log_job_update(job_id, f"Quantization failed: {e}", "CRITICAL")
        finally:
            self.job_lock.release()
    def _conversion_worker(self, job_id, source_model_folder, output_gguf_name, quantize_method):
        self.job_lock.acquire()
        fp16_gguf_path = os.path.join(self.kernel.data_path, f"temp_fp16_{job_id}.gguf")
        try:
            source_model_path = os.path.join(self.kernel.project_root_path, "ai_models", "text", source_model_folder)
            output_folder = os.path.join(self.kernel.project_root_path, "ai_models")
            os.makedirs(output_folder, exist_ok=True)
            convert_script = os.path.join(self.llama_cpp_path, "convert_hf_to_gguf.py")
            if not os.path.exists(convert_script):
                raise FileNotFoundError("FATAL: llama.cpp convert_hf_to_gguf.py script not found.")
            command_convert = [sys.executable, convert_script, source_model_path, "--outfile", fp16_gguf_path, "--outtype", "f16"]
            self.conversion_jobs[job_id]["status"] = "RUNNING"
            self._log_job_update(job_id, "Step 1/2: Converting model to FP16 GGUF format...")
            self._run_subprocess(job_id, command_convert)
            quantize_executable = os.path.join(self.llama_cpp_path, "build", "bin", "Release", "llama-quantize")
            if sys.platform == "win32" and not os.path.exists(quantize_executable):
                quantize_executable += ".exe"
            if not os.path.exists(quantize_executable):
                raise FileNotFoundError("FATAL: llama.cpp quantize executable not found. Make sure you have compiled llama.cpp.")
            final_gguf_path = os.path.join(output_folder, f"{output_gguf_name}.gguf")
            command_quantize = [quantize_executable, fp16_gguf_path, final_gguf_path, quantize_method]
            self._log_job_update(job_id, f"Step 2/2: Quantizing model to {quantize_method}...")
            self._run_subprocess(job_id, command_quantize)
            self.conversion_jobs[job_id]["status"] = "COMPLETED"
            self._log_job_update(job_id, f"Conversion complete! Model saved to {final_gguf_path}", "SUCCESS")
        except Exception as e:
            self.conversion_jobs[job_id]["status"] = "FAILED"
            self._log_job_update(job_id, f"Conversion failed: {e}", "CRITICAL")
        finally:
            if os.path.exists(fp16_gguf_path):
                os.remove(fp16_gguf_path)
            self.job_lock.release()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\module_manager_service\module_manager_service.py
# JUMLAH BARIS : 288
#######################################################################

```py
import os
import json
import importlib.util
import subprocess
import sys
import traceback
from flowork_kernel.api_contract import BaseModule
from importlib.machinery import ExtensionFileLoader
from ..base_service import BaseService
import zipfile
import tempfile
import shutil
from flowork_kernel.exceptions import PermissionDeniedError
import hashlib
class ModuleManagerService(BaseService):
    """
    (REMASTERED V6) Manages modules and now supports hybrid loading of source (.py)
    and compiled (.module.flowork) files.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.modules_dir = self.kernel.modules_path
        self.loaded_modules = {}
        self.instance_cache = {}
        self.paused_status_file = os.path.join(self.kernel.data_path, 'paused_modules.json')
        self._manual_approval_callbacks = {}
        self.logger("Service 'ModuleManager' initialized.", "DEBUG") # English Log
    def discover_and_load_modules(self):
        self.logger("ModuleManager: Starting discovery and loading...", "INFO") # English Log
        auto_compiler = self.kernel.get_service("auto_compiler_service")
        if auto_compiler and self.kernel.is_dev_mode:
            auto_compiler.initial_scan()
        self.loaded_modules.clear()
        self.instance_cache.clear()
        paused_ids = self._load_paused_status()
        if not os.path.exists(self.modules_dir):
            self.logger(f"Modules directory not found at {self.modules_dir}, skipping.", "WARN") # English Log
            return
        for item_id in os.listdir(self.modules_dir):
            item_dir = os.path.join(self.modules_dir, item_id)
            if os.path.isdir(item_dir) and item_id != '__pycache__':
                manifest_path = os.path.join(item_dir, "manifest.json")
                if not os.path.exists(manifest_path): continue
                try:
                    with open(manifest_path, 'r', encoding='utf-8') as f:
                        manifest = json.load(f)
                    if manifest.get("type") not in ["ACTION", "LOGIC", "CONTROL_FLOW"]:
                        continue
                    self._install_dependencies_locally(item_dir, manifest.get('name', item_id))
                    is_paused = item_id in paused_ids
                    module_data = {
                        "manifest": manifest, "path": item_dir,
                        "installed_as": "module", "is_paused": is_paused,
                        "permissions": manifest.get("permissions", []),
                        "tier": manifest.get('tier', 'free').lower()
                    }
                    self.loaded_modules[item_id] = module_data
                except Exception as e:
                    self.logger(f"   ! Failed to process manifest for module '{item_id}': {e}", "WARN") # English Log
        var_manager = self.kernel.get_service("variable_manager_service")
        if var_manager:
            var_manager.autodiscover_and_sync_variables()
        self.logger(f"ModuleManager: Discovery complete. Found {len(self.loaded_modules)} modules.", "INFO") # English Log
    def get_instance(self, module_id):
        if module_id in self.instance_cache:
            return self.instance_cache[module_id]
        if module_id not in self.loaded_modules:
            self.logger(f"Attempted to get instance for unknown module_id: {module_id}", "ERROR") # English Log
            return None
        module_data = self.loaded_modules[module_id]
        if module_data.get("is_paused", False):
            return None
        self.logger(f"Just-In-Time Load: Instantiating '{module_id}' for the first time.", "DEBUG") # English Log
        vendor_path = os.path.join(module_data["path"], 'vendor')
        is_path_added = False
        try:
            if os.path.isdir(vendor_path):
                if vendor_path not in sys.path:
                    sys.path.insert(0, vendor_path)
                    is_path_added = True
            manifest = module_data["manifest"]
            entry_point = manifest.get("entry_point")
            if not entry_point: raise ValueError(f"'entry_point' not found for '{module_id}'.")
            module_filename, class_name = entry_point.split('.')
            source_file_path = os.path.join(module_data["path"], f"{module_filename}.py")
            native_file_path = os.path.join(module_data["path"], f"{module_filename}.module.flowork")
            path_to_load = None
            is_native_module = False
            if os.path.exists(native_file_path):
                path_to_load = native_file_path
                is_native_module = True
                self.logger(f"  -> Found compiled native file for module '{module_id}'. Prioritizing it.", "DEBUG") # English Log
            elif os.path.exists(source_file_path):
                path_to_load = source_file_path
            if not path_to_load:
                 raise FileNotFoundError(f"Entry point file not found for '{module_id}'.")
            safe_module_id = module_id.replace('-', '_')
            parent_package_name = f"modules.{safe_module_id}"
            if is_native_module:
                module_full_name = f"{parent_package_name}.{module_filename}"
                loader = ExtensionFileLoader(module_full_name, path_to_load)
                spec = importlib.util.spec_from_loader(loader.name, loader)
            else:
                module_full_name = f"{parent_package_name}.{module_filename}"
                spec = importlib.util.spec_from_file_location(module_full_name, path_to_load)
            if spec is None: raise ImportError(f"Could not create module spec from {path_to_load}")
            module_lib = importlib.util.module_from_spec(spec)
            if parent_package_name not in sys.modules:
                if "modules" not in sys.modules:
                    spec_base = importlib.util.spec_from_loader("modules", loader=None, is_package=True)
                    module_base = importlib.util.module_from_spec(spec_base)
                    sys.modules["modules"] = module_base
                spec_parent = importlib.util.spec_from_loader(parent_package_name, loader=None, is_package=True)
                module_parent = importlib.util.module_from_spec(spec_parent)
                module_parent.__path__ = [module_data["path"]]
                sys.modules[parent_package_name] = module_parent
            sys.modules[module_full_name] = module_lib
            spec.loader.exec_module(module_lib)
            ProcessorClass = getattr(module_lib, class_name)
            services_to_inject = {}
            requested_services = manifest.get("requires_services", [])
            for service_alias in requested_services:
                if service_alias == "loc": services_to_inject['loc'] = self.kernel.get_service("localization_manager")
                elif service_alias == "logger": services_to_inject['logger'] = self.kernel.write_to_log
                elif service_alias == "kernel": services_to_inject['kernel'] = self.kernel
                else:
                    service_instance = self.kernel.get_service(service_alias)
                    if service_instance: services_to_inject[service_alias] = service_instance
            module_instance = ProcessorClass(module_id, services_to_inject)
            if hasattr(module_instance, 'on_load'):
                module_instance.on_load()
            self.instance_cache[module_id] = module_instance
            self.loaded_modules[module_id]['instance'] = module_instance
            return module_instance
        except PermissionDeniedError as e:
            self.logger(f"Skipping instantiation of '{module_id}' due to insufficient permissions: {e}", "WARN") # English Log
            return None
        except Exception as e:
            self.logger(f"CRITICAL FAILURE during Just-In-Time instantiation of '{module_id}': {e}", "CRITICAL") # English Log
            self.logger(traceback.format_exc(), "DEBUG")
            return None
        finally:
            if is_path_added:
                try:
                    sys.path.remove(vendor_path)
                except ValueError:
                    pass
    def _calculate_requirements_hash(self, file_path):
        sha256_hash = hashlib.sha256()
        try:
            with open(file_path, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            return sha256_hash.hexdigest()
        except IOError:
            return None
    def _install_dependencies_locally(self, component_path, component_name):
        requirements_path = os.path.join(component_path, 'requirements.txt')
        if not os.path.exists(requirements_path):
            return True
        vendor_path = os.path.join(component_path, 'vendor')
        hash_file_path = os.path.join(component_path, '.vendor_hash')
        current_hash = self._calculate_requirements_hash(requirements_path)
        if os.path.isdir(vendor_path) and os.path.exists(hash_file_path):
            try:
                with open(hash_file_path, 'r') as f:
                    saved_hash = f.read().strip()
                if saved_hash == current_hash:
                    return True
            except IOError:
                pass
        self.logger(f"'{component_name}' has outdated or missing local dependencies. Installing...", "INFO") # English Log
        if os.path.isdir(vendor_path):
            shutil.rmtree(vendor_path, ignore_errors=True)
        try:
            python_exe = sys.executable
            command = [
                python_exe, "-m", "pip", "install", "--target", vendor_path,
                "-r", requirements_path, "--no-user", "--disable-pip-version-check"
            ]
            creation_flags = 0
            if sys.platform == "win32":
                creation_flags = subprocess.CREATE_NO_WINDOW
            subprocess.run(command, check=True, capture_output=True, creationflags=creation_flags)
            with open(hash_file_path, 'w') as f:
                f.write(current_hash)
            return True
        except Exception as e:
            self.logger(f"FAILED to install local dependencies for '{component_name}': {e}", "CRITICAL") # English Log
            return False
    def get_manifest(self, module_id):
        return self.loaded_modules.get(module_id, {}).get("manifest")
    def get_module_permissions(self, module_id):
        return self.loaded_modules.get(module_id, {}).get("permissions", [])
    def get_module_tier(self, module_id):
        return self.loaded_modules.get(module_id, {}).get("tier", "free")
    def _load_paused_status(self):
        if os.path.exists(self.paused_status_file):
            try:
                with open(self.paused_status_file, 'r') as f: return json.load(f)
            except (json.JSONDecodeError, IOError): return []
        return []
    def _save_paused_status(self):
        paused_ids = [mid for mid, data in self.loaded_modules.items() if data.get("is_paused")]
        try:
            with open(self.paused_status_file, 'w') as f: json.dump(paused_ids, f, indent=4)
        except IOError as e:
            self.kernel.write_to_log(f"Failed to save paused status: {e}", "ERROR") # English Log
    def set_module_paused(self, module_id, is_paused):
        if module_id in self.loaded_modules:
            instance = self.instance_cache.get(module_id)
            if is_paused and instance:
                if hasattr(instance, 'on_unload'):
                    instance.on_unload()
                del self.instance_cache[module_id]
            self.loaded_modules[module_id]["is_paused"] = is_paused
            self._save_paused_status()
            return True
        return False
    def register_approval_callback(self, module_id, callback):
        self._manual_approval_callbacks[module_id] = callback
    def notify_approval_response(self, module_id: str, result: str):
        if module_id in self._manual_approval_callbacks:
            callback = self._manual_approval_callbacks.pop(module_id)
            if callable(callback):
                threading.Thread(target=callback, args=(result,)).start()
        else:
            self.logger(f"Received approval response for an unknown or timed-out module: '{module_id}'.", "WARN") # English Log
    def install_component(self, zip_filepath: str) -> (bool, str):
        with tempfile.TemporaryDirectory() as temp_dir:
            try:
                with zipfile.ZipFile(zip_filepath, 'r') as zip_ref:
                    zip_ref.extractall(temp_dir)
                component_root_path = None
                if os.path.exists(os.path.join(temp_dir, 'manifest.json')):
                    component_root_path = temp_dir
                else:
                    dir_items = [d for d in os.listdir(temp_dir) if os.path.isdir(os.path.join(temp_dir, d))]
                    if len(dir_items) == 1:
                        potential_path = os.path.join(temp_dir, dir_items[0])
                        if os.path.exists(os.path.join(potential_path, 'manifest.json')):
                            component_root_path = potential_path
                if not component_root_path:
                    return False, "manifest.json not found in the root of the zip archive or in a single subdirectory."
                with open(os.path.join(component_root_path, 'manifest.json'), 'r', encoding='utf-8') as f:
                    manifest = json.load(f)
                required_tier = manifest.get('tier', 'free')
                if not self.kernel.is_tier_sufficient(required_tier):
                    error_msg = f"Installation failed. This component requires a '{required_tier.capitalize()}' license or higher. Your current tier is '{self.kernel.license_tier.capitalize()}'."
                    self.kernel.write_to_log(error_msg, "ERROR") # English Log
                    return False, error_msg
                component_id = manifest.get('id')
                if not component_id:
                    return False, "Component 'id' is missing from manifest.json."
                final_path = os.path.join(self.modules_dir, component_id)
                if os.path.exists(final_path):
                    return False, f"Component '{component_id}' is already installed."
                shutil.move(component_root_path, final_path)
                self.kernel.write_to_log(f"Component '{component_id}' installed successfully to '{self.modules_dir}'.", "SUCCESS") # English Log
                return True, f"Component '{manifest.get('name', component_id)}' installed successfully."
            except Exception as e:
                self.kernel.write_to_log(f"Installation failed: {e}", "ERROR") # English Log
                return False, f"An error occurred during installation: {e}"
    def uninstall_component(self, component_id: str) -> (bool, str):
        if component_id not in self.loaded_modules:
            return False, f"Component '{component_id}' is not currently loaded or does not exist."
        component_data = self.loaded_modules[component_id]
        component_path = component_data.get('path')
        if not component_path or not os.path.isdir(component_path):
            return False, f"Path for component '{component_id}' not found or is invalid."
        try:
            shutil.rmtree(component_path)
            del self.loaded_modules[component_id]
            if component_id in self.instance_cache:
                del self.instance_cache[component_id]
            self.kernel.write_to_log(f"Component '{component_id}' folder deleted successfully.", "SUCCESS") # English Log
            return True, f"Component '{component_id}' uninstalled. A restart is required to fully clear it."
        except Exception as e:
            self.kernel.write_to_log(f"Failed to delete component folder '{component_path}': {e}", "ERROR") # English Log
            return False, f"Could not delete component folder: {e}"
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\permission_manager_service\permission_manager_service.py
# JUMLAH BARIS : 70
#######################################################################

```py
import os
import json
import base64
from ..base_service import BaseService
from flowork_kernel.exceptions import PermissionDeniedError
import hashlib
class PermissionManagerService(BaseService):
    """
    The central gatekeeper for all capability-based permissions.
    [REFACTORED V3] Now receives its rules from the LicenseManagerService at startup.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.permission_rules = {} # (MODIFIKASI) Starts empty
        self.is_compromised = False # (MODIFIKASI) Will be set if rules are not loaded
        self.capability_display_map = {
            "web_scraping_advanced": "Advanced Web Scraping (Selenium)",
            "time_travel_debugger": "Time-Travel Debugger",
            "screen_recorder": "Screen Recorder",
            "unlimited_api": "Unlimited API & Webhooks",
            "preset_versioning": "Preset Version Management",
            "ai_provider_access": "AI Provider Access (Gemini, etc)",
            "ai_local_models": "Run Local AI Models (GGUF, etc)",
            "ai_copilot": "AI Co-pilot Analysis",
            "marketplace_upload": "Upload to Marketplace",
            "video_processing": "Advanced Video Processing",
            "ai_architect": "AI Architect (Workflow Generator)",
            "core_compiler": "Core Workflow Compiler",
            "module_generator": "Module Generator"
        }
    def load_rules_from_source(self, rules_dict):
        """Loads the permission rules provided by an external source (like LicenseManager)."""
        if rules_dict and 'capabilities' in rules_dict:
            self.permission_rules = rules_dict['capabilities']
            self.is_compromised = False
            self.logger(f"PermissionManager: Loaded {len(self.permission_rules)} capability rules from source.", "SUCCESS") # English Log
        else:
            self.permission_rules = {}
            self.is_compromised = True
            self.logger("PermissionManager: Received empty or invalid rules. Entering secure mode.", "CRITICAL") # English Log
    def check_permission(self, capability: str, is_system_call: bool = False) -> bool:
        """
        Checks if the current user has the required tier for a specific capability.
        """
        if is_system_call:
            return True
        if self.is_compromised:
            error_msg = self.loc.get('permission_denied_secure_mode', fallback="Access Denied due to secure mode. Please check license file signature.")
            raise PermissionDeniedError(error_msg)
        required_tier = self.permission_rules.get(capability)
        if not required_tier:
            return True
        user_tier = self.kernel.license_tier
        if not self.kernel.is_tier_sufficient(required_tier):
            capability_name = self.capability_display_map.get(capability, capability.replace('_', ' ').title())
            error_msg = self.loc.get('permission_denied_detailed',
                                     fallback="Access Denied. The '{capability}' feature requires a '{required_tier}' license, but your current tier is '{user_tier}'.",
                                     capability=capability_name,
                                     required_tier=required_tier.capitalize(),
                                     user_tier=user_tier.capitalize())
            raise PermissionDeniedError(error_msg)
        return True
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\plugin_manager_service\plugin_manager_service.py
# JUMLAH BARIS : 235
#######################################################################

```py
import os
import json
import importlib.util
import subprocess
import sys
import traceback
from flowork_kernel.api_contract import BaseUIProvider, BaseModule
from importlib.machinery import ExtensionFileLoader
from ..base_service import BaseService
import zipfile
import tempfile
import shutil
import hashlib
from flowork_kernel.exceptions import PermissionDeniedError
class PluginManagerService(BaseService):
    """
    Manages the discovery, loading, and access to all plugins (UI Providers, Services).
    (MODIFIED) Now supports hybrid loading of source (.py) and compiled (.plugin.flowork) files.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.plugins_dir = self.kernel.plugins_path
        self.system_plugins_dir = self.kernel.system_plugins_path
        self.loaded_plugins = {}
        self.instance_cache = {}
        self.paused_status_file = os.path.join(self.kernel.data_path, 'paused_plugins.json')
        self.logger(f"Service 'PluginManagerService' initialized.", "DEBUG") # English Log
    def discover_and_load_plugins(self):
        self.logger("PluginManager: Starting discovery and loading...", "INFO") # English Log
        auto_compiler = self.kernel.get_service("auto_compiler_service")
        if auto_compiler and self.kernel.is_dev_mode:
            auto_compiler.initial_scan()
        self.loaded_plugins.clear()
        self.instance_cache.clear()
        paused_ids = self._load_paused_status()
        paths_to_scan = [
            (self.plugins_dir, "plugin")
        ]
        for base_path, base_type in paths_to_scan:
            if not os.path.exists(base_path): continue
            for item_id in os.listdir(base_path):
                item_dir = os.path.join(base_path, item_id)
                if os.path.isdir(item_dir) and item_id != '__pycache__':
                    manifest_path = os.path.join(item_dir, "manifest.json")
                    if not os.path.exists(manifest_path): continue
                    self.logger(f"[MATA-MATA] PluginManager: Found potential plugin '{item_id}'. Reading manifest...", "DEBUG") # English Log
                    try:
                        with open(manifest_path, 'r', encoding='utf-8') as f:
                            manifest = json.load(f)
                        if manifest.get("type") not in ["PLUGIN", "SERVICE"]:
                            continue
                        self.logger(f"[MATA-MATA] PluginManager: Manifest for '{item_id}' is valid. Type: {manifest.get('type')}", "INFO") # English Log
                        self._install_dependencies_locally(item_dir, manifest.get('name', item_id))
                        is_paused = item_id in paused_ids
                        is_ui_provider = "ui_provider" in manifest.get("permissions", [])
                        is_service_plugin = manifest.get("is_service", False)
                        module_data = {
                            "manifest": manifest, "path": item_dir,
                            "installed_as": base_type, "is_paused": is_paused,
                            "permissions": manifest.get("permissions", []),
                            "tier": manifest.get('tier', 'free').lower()
                        }
                        self.loaded_plugins[item_id] = module_data
                        if not is_paused and (is_ui_provider or is_service_plugin):
                            self.logger(f"[MATA-MATA] Eager Load: Attempting to instantiate critical plugin '{item_id}' now.", "WARN") # English Log
                            self.get_instance(item_id)
                    except Exception as e:
                        self.logger(f"   ! Failed to process manifest for plugin '{item_id}': {e}", "WARN") # English Log
        self.logger(f"PluginManager: Discovery complete. Found {len(self.loaded_plugins)} plugins.", "INFO") # English Log
    def get_instance(self, plugin_id):
        self.logger(f"[MATA-MATA] get_instance called for plugin_id: '{plugin_id}'", "DEBUG") # English Log
        if plugin_id in self.instance_cache:
            return self.instance_cache[plugin_id]
        if plugin_id not in self.loaded_plugins:
            self.logger(f"Attempted to get instance for unknown plugin_id: {plugin_id}", "ERROR") # English Log
            return None
        plugin_data = self.loaded_plugins[plugin_id]
        if plugin_data.get("is_paused", False):
            return None
        self.logger(f"Just-In-Time Load: Instantiating plugin '{plugin_id}' for the first time.", "DEBUG") # English Log
        vendor_path = os.path.join(plugin_data["path"], 'vendor')
        is_path_added = False
        try:
            if os.path.isdir(vendor_path):
                if vendor_path not in sys.path:
                    sys.path.insert(0, vendor_path)
                    is_path_added = True
            manifest = plugin_data["manifest"]
            entry_point = manifest.get("entry_point")
            if not entry_point: raise ValueError(f"'entry_point' not found for '{plugin_id}'.")
            module_filename, class_name = entry_point.split('.')
            source_file_path = os.path.join(plugin_data["path"], f"{module_filename}.py")
            native_file_path = os.path.join(plugin_data["path"], f"{module_filename}.plugin.flowork")
            path_to_load = None
            is_native_module = False
            if os.path.exists(native_file_path):
                path_to_load = native_file_path
                is_native_module = True
                self.logger(f"  -> Found compiled native file for plugin '{plugin_id}'. Prioritizing it.", "DEBUG") # English Log
            elif os.path.exists(source_file_path):
                path_to_load = source_file_path
            if not path_to_load:
                 raise FileNotFoundError(f"Entry point file not found for '{plugin_id}'.")
            safe_plugin_id = plugin_id.replace('-', '_')
            base_folder = os.path.basename(os.path.dirname(plugin_data["path"]))
            parent_package_name = f"{base_folder}.{safe_plugin_id}"
            if is_native_module:
                module_full_name = f"{parent_package_name}.{module_filename}"
                loader = ExtensionFileLoader(module_full_name, path_to_load)
                spec = importlib.util.spec_from_loader(loader.name, loader)
            else:
                module_full_name = f"{parent_package_name}.{module_filename}"
                spec = importlib.util.spec_from_file_location(module_full_name, path_to_load)
            if spec is None: raise ImportError(f"Could not create module spec from {path_to_load}")
            module_lib = importlib.util.module_from_spec(spec)
            if parent_package_name not in sys.modules:
                if base_folder not in sys.modules:
                    spec_base = importlib.util.spec_from_loader(base_folder, loader=None, is_package=True)
                    module_base = importlib.util.module_from_spec(spec_base)
                    sys.modules[base_folder] = module_base
                spec_parent = importlib.util.spec_from_loader(parent_package_name, loader=None, is_package=True)
                module_parent = importlib.util.module_from_spec(spec_parent)
                module_parent.__path__ = [plugin_data["path"]]
                sys.modules[parent_package_name] = module_parent
            sys.modules[module_full_name] = module_lib
            self.logger(f"[MATA-MATA] Executing module '{module_full_name}' for plugin '{plugin_id}'...", "DEBUG") # English Log
            spec.loader.exec_module(module_lib)
            self.logger(f"[MATA-MATA] Module execution successful for '{plugin_id}'.", "SUCCESS") # English Log
            ProcessorClass = getattr(module_lib, class_name)
            services_to_inject = {}
            requested_services = manifest.get("requires_services", [])
            for service_alias in requested_services:
                if service_alias == "loc": services_to_inject['loc'] = self.kernel.get_service("localization_manager")
                elif service_alias == "logger": services_to_inject['logger'] = self.kernel.write_to_log
                elif service_alias == "kernel": services_to_inject['kernel'] = self.kernel
                else:
                    service_instance = self.kernel.get_service(service_alias)
                    if service_instance: services_to_inject[service_alias] = service_instance
            self.logger(f"[MATA-MATA] Initializing class '{class_name}' for plugin '{plugin_id}'...", "DEBUG") # English Log
            plugin_instance = ProcessorClass(plugin_id, services_to_inject)
            self.logger(f"[MATA-MATA] Class initialization successful for '{plugin_id}'.", "SUCCESS") # English Log
            if hasattr(plugin_instance, 'on_load'):
                plugin_instance.on_load()
            self.instance_cache[plugin_id] = plugin_instance
            self.loaded_plugins[plugin_id]['instance'] = plugin_instance
            return plugin_instance
        except PermissionDeniedError as e:
            self.logger(f"Skipping instantiation of plugin '{plugin_id}' due to insufficient permissions: {e}", "WARN") # English Log
            return None
        except Exception as e:
            self.logger(f"CRITICAL FAILURE during Just-In-Time instantiation of plugin '{plugin_id}': {e}", "CRITICAL") # English Log
            self.logger(traceback.format_exc(), "DEBUG")
            return None
        finally:
            if is_path_added:
                try:
                    sys.path.remove(vendor_path)
                except ValueError:
                    pass
    def _calculate_requirements_hash(self, file_path):
        sha256_hash = hashlib.sha256()
        try:
            with open(file_path, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            return sha256_hash.hexdigest()
        except IOError:
            return None
    def _install_dependencies_locally(self, component_path, component_name):
        requirements_path = os.path.join(component_path, 'requirements.txt')
        if not os.path.exists(requirements_path):
            return True
        vendor_path = os.path.join(component_path, 'vendor')
        hash_file_path = os.path.join(component_path, '.vendor_hash')
        current_hash = self._calculate_requirements_hash(requirements_path)
        if os.path.isdir(vendor_path) and os.path.exists(hash_file_path):
            try:
                with open(hash_file_path, 'r') as f:
                    saved_hash = f.read().strip()
                if saved_hash == current_hash:
                    return True
            except IOError:
                pass
        self.logger(f"Plugin '{component_name}' has outdated or missing local dependencies. Installing...", "INFO") # English Log
        if os.path.isdir(vendor_path):
            shutil.rmtree(vendor_path, ignore_errors=True)
        try:
            python_exe = sys.executable
            command = [
                python_exe, "-m", "pip", "install", "--target", vendor_path,
                "-r", requirements_path, "--no-user", "--disable-pip-version-check"
            ]
            creation_flags = 0
            if sys.platform == "win32":
                creation_flags = subprocess.CREATE_NO_WINDOW
            subprocess.run(command, check=True, capture_output=True, creationflags=creation_flags)
            with open(hash_file_path, 'w') as f:
                f.write(current_hash)
            return True
        except Exception as e:
            self.logger(f"FAILED to install local dependencies for plugin '{component_name}': {e}", "CRITICAL") # English Log
            return False
    def get_manifest(self, plugin_id):
        return self.loaded_plugins.get(plugin_id, {}).get("manifest")
    def _load_paused_status(self):
        if os.path.exists(self.paused_status_file):
            try:
                with open(self.paused_status_file, 'r') as f: return json.load(f)
            except (json.JSONDecodeError, IOError): return []
        return []
    def _save_paused_status(self):
        paused_ids = [pid for pid, data in self.loaded_plugins.items() if data.get("is_paused")]
        try:
            with open(self.paused_status_file, 'w') as f: json.dump(paused_ids, f, indent=4)
        except IOError as e:
            self.kernel.write_to_log(f"Failed to save plugin paused status: {e}", "ERROR") # English Log
    def set_plugin_paused(self, plugin_id, is_paused):
        if plugin_id in self.loaded_plugins:
            instance = self.instance_cache.get(plugin_id)
            if is_paused and instance:
                if hasattr(instance, 'on_unload'):
                    instance.on_unload()
                del self.instance_cache[plugin_id]
            self.loaded_plugins[plugin_id]["is_paused"] = is_paused
            self._save_paused_status()
            return True
        return False
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\prompt_manager_service\prompt_manager_service.py
# JUMLAH BARIS : 106
#######################################################################

```py
import uuid
import sqlite3
from ..base_service import BaseService
class PromptManagerService(BaseService):
    """
    Manages the lifecycle (CRUD) of prompt templates in the database.
    This is a standard class-based service for reliability.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.logger("PromptManagerService Initialized.", "SUCCESS")
    def _get_db_connection(self):
        """Helper to get the DB service and connection just-in-time."""
        db_service = self.kernel.get_service("database_service")
        if not db_service:
            self.logger("PromptManagerService CRITICAL: DatabaseService is not available.", "CRITICAL")
            return None
        return db_service.get_connection()
    def get_all_prompts(self):
        """Fetches a list of all prompt templates."""
        try:
            with self._get_db_connection() as db_conn:
                if not db_conn: return []
                cursor = db_conn.cursor()
                cursor.execute("SELECT id, name FROM prompt_templates ORDER BY name ASC")
                return cursor.fetchall()
        except Exception as e:
            self.logger(f"PromptManagerService(get_all_prompts): Error - {e}", "ERROR")
            return []
    def get_prompt(self, prompt_id: str):
        """Fetches a single prompt by its ID."""
        try:
            with self._get_db_connection() as db_conn:
                if not db_conn: return None
                cursor = db_conn.cursor()
                cursor.execute("SELECT * FROM prompt_templates WHERE id = ?", (prompt_id,))
                return cursor.fetchone()
        except Exception as e:
            self.logger(f"PromptManagerService(get_prompt): Error - {e}", "ERROR")
            return None
    def create_prompt(self, prompt_data: dict):
        """Creates a new prompt template."""
        name = prompt_data.get('name')
        content = prompt_data.get('content')
        if not name or not content:
            return {'error': 'Name and content are required'}
        new_id = str(uuid.uuid4())
        try:
            with self._get_db_connection() as db_conn:
                if not db_conn: return {'error': 'DatabaseService not available'}
                cursor = db_conn.cursor()
                cursor.execute("INSERT INTO prompt_templates (id, name, content) VALUES (?, ?, ?)", (new_id, name, content))
                db_conn.commit()
            return {'id': new_id, 'name': name, 'status': 'created'}
        except sqlite3.IntegrityError:
            return {'error': f"A prompt with the name '{name}' already exists."}
        except Exception as e:
            self.logger(f"PromptManagerService(create_prompt): Error - {e}", "ERROR")
            return {'error': str(e)}
    def update_prompt(self, prompt_id: str, prompt_data: dict):
        """Updates an existing prompt template."""
        name = prompt_data.get('name')
        content = prompt_data.get('content')
        if not name or content is None:
            return {'error': 'Name and content are required'}
        try:
            with self._get_db_connection() as db_conn:
                if not db_conn: return {'error': 'DatabaseService not available'}
                cursor = db_conn.cursor()
                cursor.execute("UPDATE prompt_templates SET name = ?, content = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?", (name, content, prompt_id))
                if cursor.rowcount == 0:
                    return {'error': 'Prompt not found'}
                db_conn.commit()
            return {'id': prompt_id, 'status': 'updated'}
        except sqlite3.IntegrityError:
            return {'error': f"A prompt with the name '{name}' already exists."}
        except Exception as e:
            self.logger(f"PromptManagerService(update_prompt): Error - {e}", "ERROR")
            return {'error': str(e)}
    def delete_prompt(self, prompt_id: str):
        """Deletes a prompt template."""
        try:
            with self._get_db_connection() as db_conn:
                if not db_conn: return {'error': 'DatabaseService not available'}
                cursor = db_conn.cursor()
                cursor.execute("DELETE FROM prompt_templates WHERE id = ?", (prompt_id,))
                if cursor.rowcount == 0:
                    return {'error': 'Prompt not found'}
                db_conn.commit()
            return {'id': prompt_id, 'status': 'deleted'}
        except Exception as e:
            self.logger(f"PromptManagerService(delete_prompt): Error - {e}", "ERROR")
            return {'error': str(e)}
    def _dict_factory(self, cursor, row):
        d = {}
        for idx, col in enumerate(cursor.description):
            d[col[0]] = row[idx]
        return d
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\scanner_manager_service\scanner_manager_service.py
# JUMLAH BARIS : 72
#######################################################################

```py
import os
import re
import importlib
import inspect
import sys
from ..base_service import BaseService
from scanners.base_scanner import BaseScanner
from importlib.machinery import ExtensionFileLoader # [PENAMBAHAN]
class ScannerManagerService(BaseService):
    """
    Manages the discovery, loading, and access to all diagnostic scanner modules.
    (MODIFIED) Now supports hybrid loading of source (.py) and compiled (.scanner.flowork) files.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.scanners_dir = os.path.join(self.kernel.project_root_path, 'scanners')
        self.loaded_scanners = {}
        self.logger(f"Service '{self.service_id}' initialized.", "DEBUG") # English Log
    def discover_and_load_scanners(self):
        """
        Discovers all available scanner classes from the top-level 'scanners' directory.
        """
        self.logger("ScannerManager: Discovering all scanner modules...", "INFO") # English Log
        self.loaded_scanners.clear()
        if not os.path.isdir(self.scanners_dir):
            self.logger(f"Scanner directory not found at '{self.scanners_dir}'. Skipping scan.", "WARN") # English Log
            return
        if self.kernel.project_root_path not in sys.path:
            sys.path.insert(0, self.kernel.project_root_path)
        for entry_name in os.listdir(self.scanners_dir):
            if entry_name.startswith('__') or not entry_name.endswith('.py'):
                continue
            module_name_base = entry_name[:-3]
            module_path = os.path.join(self.scanners_dir, entry_name)
            native_file_path = os.path.join(self.scanners_dir, f"{module_name_base}.scanner.flowork")
            path_to_load = None
            is_native_module = False
            if os.path.exists(native_file_path):
                path_to_load = native_file_path
                is_native_module = True
            elif os.path.exists(module_path):
                path_to_load = module_path
            if not path_to_load:
                continue
            module_name = f"scanners.{module_name_base}"
            try:
                if is_native_module:
                    loader = ExtensionFileLoader(module_name, path_to_load)
                    spec = importlib.util.spec_from_loader(loader.name, loader)
                else:
                    spec = importlib.util.spec_from_file_location(module_name, path_to_load)
                module = importlib.util.module_from_spec(spec)
                sys.modules[module_name] = module # (COMMENT) Cache module to avoid re-import issues
                spec.loader.exec_module(module)
                for name, obj in inspect.getmembers(module, inspect.isclass):
                    if issubclass(obj, BaseScanner) and obj is not BaseScanner:
                        self.loaded_scanners[obj.__name__] = obj
                        self.logger(f"  -> Discovered scanner: '{name}'", "SUCCESS") # English Log
            except Exception as e:
                self.logger(f"ScannerManager: Failed to import scanner from '{entry_name}': {e}", "ERROR") # English Log
        self.logger(f"Scanner discovery complete. Found {len(self.loaded_scanners)} scanners.", "INFO") # English Log
    def get_all_scanners(self):
        """Returns a list of all loaded scanner classes."""
        return list(self.loaded_scanners.values())
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\scheduler_manager_service\scheduler_manager_service.py
# JUMLAH BARIS : 87
#######################################################################

```py
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.cron import CronTrigger
from apscheduler.jobstores.base import JobLookupError
from datetime import datetime
from ..base_service import BaseService
class SchedulerManagerService(BaseService):
    """
    Manages all scheduling tasks (Cron Jobs) for Flowork.
    Uses APScheduler to run presets at specified times.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.scheduler = BackgroundScheduler(daemon=False)
        self.kernel.write_to_log("Service 'SchedulerManager' initialized.", "DEBUG") # English Log
    def start(self):
        """Starts the scheduler in the background."""
        try:
            if not self.scheduler.running:
                self.scheduler.start()
                self.kernel.write_to_log("Background scheduler started successfully.", "SUCCESS") # English Log
        except Exception as e:
            self.kernel.write_to_log(f"Failed to start scheduler: {e}", "ERROR") # English Log
    def stop(self):
        """Stops the scheduler safely when the application closes."""
        try:
            if self.scheduler.running:
                self.scheduler.shutdown()
                self.kernel.write_to_log("Background scheduler stopped successfully.", "INFO") # English Log
        except Exception as e:
            self.kernel.write_to_log(f"Failed to stop scheduler: {e}", "ERROR") # English Log
    def schedule_rule(self, rule_id, rule_data):
        """Adds or updates a scheduled job based on a trigger rule."""
        preset_name = rule_data.get("preset_to_run")
        config = rule_data.get("config", {})
        cron_string = config.get("cron_string")
        if not all([preset_name, cron_string]):
            self.kernel.write_to_log(f"Scheduled rule '{rule_id}' is incomplete (missing preset or cron string).", "WARN") # English Log
            return
        api_service = self.kernel.get_service("api_server_service")
        if not api_service:
            self.kernel.write_to_log(f"Cannot schedule job for rule '{rule_id}', ApiServerService not available.", "ERROR") # English Log
            return
        def job_wrapper():
            self.kernel.write_to_log(f"Executing scheduled job '{rule_id}' for preset '{preset_name}'.", "INFO") # English Log
            api_service.trigger_workflow_by_api(preset_name, initial_payload={"triggered_by": "scheduler", "rule_id": rule_id})
            self.kernel.write_to_log(f"Job '{rule_id}' finished. It will run again on its next schedule.", "INFO") # English Log
        try:
            self.scheduler.add_job(
                job_wrapper, # (MODIFIED) We schedule our new wrapper function.
                trigger=CronTrigger.from_crontab(cron_string),
                id=str(rule_id),
                name=f"Cron for preset: {preset_name}",
                replace_existing=True
            )
            self.kernel.write_to_log(f"Scheduled job '{rule_data.get('name')}' for preset '{preset_name}' added/updated successfully.", "SUCCESS") # English Log
        except ValueError as e:
             self.kernel.write_to_log(f"Invalid Cron String format for rule '{rule_data.get('name')}': {e}", "ERROR") # English Log
        except Exception as e:
            self.kernel.write_to_log(f"Failed to add scheduled job '{rule_id}': {e}", "ERROR") # English Log
    def remove_scheduled_rule(self, rule_id):
        """Removes a scheduled job from the scheduler."""
        try:
            self.scheduler.remove_job(str(rule_id))
            self.kernel.write_to_log(f"Scheduled job with ID '{rule_id}' removed successfully.", "INFO") # English Log
        except JobLookupError:
            self.kernel.write_to_log(f"Attempted to remove a scheduled job '{rule_id}' that does not exist.", "WARN") # English Log
        except Exception as e:
            self.kernel.write_to_log(f"Failed to remove scheduled job '{rule_id}': {e}", "ERROR") # English Log
    def get_next_run_time(self, job_id: str) -> datetime | None:
        """
        Gets the next execution time for a scheduled job.
        """
        try:
            for job in self.scheduler.get_jobs():
                if job.id == str(job_id):
                    return job.next_run_time
        except Exception as e:
            self.kernel.write_to_log(f"Error while searching for scheduled job '{job_id}': {e}", "ERROR") # English Log
        return None
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\screen_recorder_service\screen_recorder_service.py
# JUMLAH BARIS : 148
#######################################################################

```py
import os
import threading
import time
import shutil
import wave
import pyaudio
import numpy as np
import mss
import subprocess
import tempfile
from ..base_service import BaseService
class ScreenRecorderService(BaseService):
    """
    Manages the screen and audio recording lifecycle.
    [V5] Added software-based audio gain (amplification).
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.is_recording = False
        self.temp_dir = None
        self.audio_thread = None
        self.video_thread = None
        self.current_gain = 1.0
        ffmpeg_executable = "ffmpeg.exe" if os.name == 'nt' else "ffmpeg"
        self.ffmpeg_path = os.path.join(self.kernel.project_root_path, "vendor", "ffmpeg", "bin", ffmpeg_executable)
    def start(self):
        self.kernel.write_to_log("Screen Recorder Service is ready.", "SUCCESS")
    def start_recording(self, monitor_num=1, record_audio=True, gain=1.0):
        if self.is_recording:
            self.kernel.write_to_log("Recording is already in progress.", "WARN")
            return False
        try:
            self.temp_dir = tempfile.mkdtemp(prefix="flowork_rec_")
            self.kernel.write_to_log(f"Temporary recording directory created: {self.temp_dir}", "INFO")
            self.is_recording = True
            if record_audio:
                self.current_gain = gain # Store the gain for the audio worker
                self.audio_thread = threading.Thread(target=self._audio_worker, daemon=True)
                self.audio_thread.start()
            else:
                self.kernel.write_to_log("Recording video only, as requested by user.", "INFO")
            self.video_thread = threading.Thread(target=self._capture_worker, args=(monitor_num,), daemon=True)
            self.video_thread.start()
            return True
        except Exception as e:
            self.kernel.write_to_log(f"Failed to start recording process: {e}", "CRITICAL")
            self.is_recording = False
            return False
    def stop_recording(self):
        if not self.is_recording: return None
        self.is_recording = False
        self.kernel.write_to_log("Stopping recording threads...", "INFO")
        if self.audio_thread: self.audio_thread.join(timeout=2)
        if self.video_thread: self.video_thread.join(timeout=2)
        self.kernel.write_to_log("Threads stopped. Starting final video merge...", "INFO")
        final_path = self._merge_with_ffmpeg()
        return final_path
    def _audio_worker(self):
        CHUNK = 1024
        FORMAT = pyaudio.paInt16
        CHANNELS = 1
        RATE = 44100
        audio_file = os.path.join(self.temp_dir, 'output.wav')
        p = pyaudio.PyAudio()
        stream = None
        frames = []
        INT16_MAX = 32767
        try:
            stream = p.open(format=FORMAT,
                            channels=CHANNELS,
                            rate=RATE,
                            input=True,
                            frames_per_buffer=CHUNK)
            self.kernel.write_to_log(f"PyAudio stream opened for default input device with gain: {self.current_gain}x", "INFO")
            while self.is_recording:
                data = stream.read(CHUNK)
                audio_as_np_int16 = np.frombuffer(data, dtype=np.int16)
                amplified_audio = audio_as_np_int16 * self.current_gain
                clipped_audio = np.clip(amplified_audio, -INT16_MAX, INT16_MAX)
                final_audio_bytes = clipped_audio.astype(np.int16).tobytes()
                frames.append(final_audio_bytes)
        except Exception as e:
            self.kernel.write_to_log(f"PyAudio recording failed: {e}", "ERROR")
        finally:
            if stream:
                stream.stop_stream()
                stream.close()
            p.terminate()
            if frames:
                wf = wave.open(audio_file, 'wb')
                wf.setnchannels(CHANNELS)
                wf.setsampwidth(p.get_sample_size(FORMAT))
                wf.setframerate(RATE)
                wf.writeframes(b''.join(frames))
                wf.close()
                self.kernel.write_to_log(f"Audio stream saved to {audio_file}", "SUCCESS")
    def _capture_worker(self, monitor_num):
        frame_rate = 15
        sleep_interval = 1 / frame_rate
        frame_count = 0
        with mss.mss() as sct:
            if monitor_num >= len(sct.monitors):
                self.kernel.write_to_log(f"Invalid monitor number {monitor_num}. Defaulting to primary.", "WARN")
                monitor_num = 1
            monitor = sct.monitors[monitor_num]
            while self.is_recording:
                screenshot = sct.grab(monitor)
                frame_path = os.path.join(self.temp_dir, f"frame_{frame_count:06d}.png")
                mss.tools.to_png(screenshot.rgb, screenshot.size, output=frame_path)
                frame_count += 1
                time.sleep(sleep_interval)
        self.kernel.write_to_log(f"Video capture finished. Total frames: {frame_count}", "INFO")
    def _merge_with_ffmpeg(self):
        output_filename = f"Flowork_Tutorial_{time.strftime('%Y%m%d_%H%M%S')}.mp4"
        default_save_path = os.path.join(os.path.expanduser("~"), "Videos", "Flowork Tutorials")
        save_path = self.loc.get_setting("recorder_save_path", default_save_path)
        os.makedirs(save_path, exist_ok=True)
        final_video_path = os.path.join(save_path, output_filename)
        audio_input = os.path.join(self.temp_dir, 'output.wav')
        video_input = os.path.join(self.temp_dir, 'frame_%06d.png')
        if not os.path.exists(audio_input):
            self.kernel.write_to_log("No audio file found, merging video only.", "WARN")
            cmd = [ self.ffmpeg_path, '-y', '-framerate', '15', '-i', video_input, '-c:v', 'libx264', '-pix_fmt', 'yuv420p', final_video_path ]
        else:
            cmd = [ self.ffmpeg_path, '-y', '-framerate', '15', '-i', video_input, '-i', audio_input, '-c:v', 'libx264', '-c:a', 'aac', '-strict', 'experimental', '-shortest', '-pix_fmt', 'yuv420p', final_video_path ]
        try:
            startupinfo = None
            if os.name == 'nt':
                startupinfo = subprocess.STARTUPINFO()
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            subprocess.run(cmd, check=True, capture_output=True, text=True, startupinfo=startupinfo)
            self.kernel.write_to_log(f"Video merged successfully: {final_video_path}", "SUCCESS")
            return final_video_path
        except subprocess.CalledProcessError as e:
            self.kernel.write_to_log(f"FFmpeg merge failed: {e.stderr}", "ERROR")
            return None
        finally:
            if self.temp_dir and os.path.isdir(self.temp_dir):
                shutil.rmtree(self.temp_dir)
                self.kernel.write_to_log(f"Cleaned up temp directory: {self.temp_dir}", "INFO")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\semantic_search_service\semantic_search_service.py
# JUMLAH BARIS : 123
#######################################################################

```py
import threading
from ..base_service import BaseService
import os
import json
import time
try:
    from sentence_transformers import SentenceTransformer
    from sentence_transformers.util import cos_sim
    import torch # ADDED: Import the core torch library
    SENTENCE_TRANSFORMERS_AVAILABLE = True
except ImportError:
    SENTENCE_TRANSFORMERS_AVAILABLE = False
class SemanticSearchService(BaseService):
    """
    The 'brain' behind semantic search. It scans all components, creates
    vector embeddings for them, and provides a method to find the most
    relevant components for a given text query.
    [FIXED] Solved a race condition by subscribing to the event on the main thread
    before starting the background model loading.
    [FIXED V2] Added missing 'import time'.
    [FIXED V3] Correctly stack tensors before comparison to fix ValueError.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.logger = self.kernel.write_to_log
        self.model = None
        self.component_embeddings = {} # {'modules': [{'id': ..., 'embedding': ...}]}
        self.is_ready = False
        self.lock = threading.Lock()
    def start(self):
        """
        Loads the AI model and builds the initial embedding index in a background thread.
        """
        if not SENTENCE_TRANSFORMERS_AVAILABLE:
            self.logger("Library 'sentence-transformers' not found. Semantic Search will be disabled.", "ERROR")
            self.kernel.write_to_log("Please run 'pip install sentence-transformers' to enable this feature.", "ERROR")
            return
        self.logger("Semantic Search Service is starting...", "INFO")
        event_bus = self.kernel.get_service("event_bus")
        if event_bus:
            event_bus.subscribe("event_all_services_started", f"{self.service_id}_builder", self.build_index)
        threading.Thread(target=self._initialize_model, daemon=True).start()
    def _initialize_model(self):
        """Loads the AI model in the background."""
        try:
            self.logger("Loading sentence transformer model... (This may take a moment)", "INFO")
            self.model = SentenceTransformer('all-MiniLM-L6-v2')
            self.logger("Sentence transformer model loaded successfully.", "SUCCESS")
        except Exception as e:
            self.logger(f"Failed to initialize Semantic Search Service model: {e}", "CRITICAL")
            self.is_ready = False
    def build_index(self, event_data=None):
        """
        Scans all components and creates vector embeddings for their metadata.
        This method is now safely called by the event bus after all modules are loaded.
        """
        while not self.model:
            time.sleep(0.5)
        self.logger("Building semantic search index...", "INFO")
        module_manager = self.kernel.get_service("module_manager_service")
        widget_manager = self.kernel.get_service("widget_manager_service")
        component_sources = {
            "modules": module_manager.loaded_modules if module_manager else {},
            "plugins": module_manager.loaded_modules if module_manager else {},
            "widgets": widget_manager.loaded_widgets if widget_manager else {}
        }
        with self.lock:
            self.component_embeddings.clear()
            for comp_type, components in component_sources.items():
                self.component_embeddings[comp_type] = []
                texts_to_encode = []
                component_ids = []
                for comp_id, data in components.items():
                    installed_as = data.get('installed_as')
                    if comp_type == 'modules' and installed_as != 'module':
                        continue
                    if comp_type == 'plugins' and installed_as != 'plugin':
                        continue
                    manifest = data.get('manifest', {})
                    searchable_text = f"Name: {manifest.get('name', '')}. Description: {manifest.get('description', '')}. ID: {comp_id}"
                    texts_to_encode.append(searchable_text)
                    component_ids.append(comp_id)
                if texts_to_encode:
                    embeddings = self.model.encode(texts_to_encode, convert_to_tensor=True)
                    for i, comp_id in enumerate(component_ids):
                        self.component_embeddings[comp_type].append({
                            'id': comp_id,
                            'embedding': embeddings[i]
                        })
            self.is_ready = True
            self.logger("Semantic search index built successfully.", "SUCCESS")
            event_bus = self.kernel.get_service("event_bus")
            if event_bus:
                event_bus.publish("SEMANTIC_INDEX_BUILT", {"status": "ready"})
    def search(self, query: str, component_type: str, top_k: int = 10) -> list[str]:
        """
        Finds the most relevant components for a given query.
        Returns a ranked list of component IDs.
        """
        if not self.is_ready or not self.model:
            return []
        with self.lock:
            if component_type not in self.component_embeddings or not self.component_embeddings[component_type]:
                return []
            corpus = self.component_embeddings[component_type]
            corpus_embeddings = [item['embedding'] for item in corpus]
            corpus_tensor = torch.stack(corpus_embeddings)
            query_embedding = self.model.encode(query, convert_to_tensor=True)
            cos_scores = cos_sim(query_embedding, corpus_tensor)[0]
            top_results = cos_scores.topk(min(top_k, len(corpus)), largest=True)
            ranked_ids = []
            for score, idx in zip(top_results[0], top_results[1]):
                if score > 0.25:
                    ranked_ids.append(corpus[idx]['id'])
            return ranked_ids
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\startup_service\startup_service.py
# JUMLAH BARIS : 94
#######################################################################

```py
from ..base_service import BaseService
import time
from tkinter import messagebox
from flowork_kernel.exceptions import MandatoryUpdateRequiredError, PermissionDeniedError
from flowork_kernel.api_client import ApiClient
class StartupService(BaseService):
    """
    A dedicated service to handle the application's startup sequence.
    (MODIFIED V3) Now starts only SERVER-side components.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.api_client = ApiClient(kernel=self.kernel)
    def run_startup_sequence(self):
        """
        Executes the main startup logic with robust error handling.
        """
        try:
            self.logger("StartupService (Phase 1): Running automatic file update check...", "INFO") # English Log
            update_service = self.kernel.get_service("update_service", is_system_call=True)
            if update_service:
                update_service.run_update_check()
            self.logger("StartupService (Phase 2): Running Benteng Baja file integrity check...", "INFO") # English Log
            integrity_checker = self.kernel.get_service("integrity_checker_service", is_system_call=True)
            if integrity_checker: integrity_checker.verify_core_files()
            self._attempt_auto_login()
            self.logger("StartupService (Phase 3): Remote License Verification...", "INFO") # English Log
            license_manager = self.kernel.get_service("license_manager_service", is_system_call=True)
            if license_manager: license_manager.verify_license_on_startup()
            permission_manager = self.kernel.get_service("permission_manager_service", is_system_call=True)
            if permission_manager and license_manager:
                self.logger("StartupService: Injecting remote rules into PermissionManager...", "INFO")
                permission_manager.load_rules_from_source(license_manager.remote_permission_rules)
            self.logger("StartupService (Phase 4): All checks passed. Starting normal services...", "INFO")
            services_to_start = [
                ("localization_manager", lambda s: s.load_all_languages()),
                ("documentation_service", lambda s: s.start() if hasattr(s, 'start') else None),
                ("scheduler_manager_service", lambda s: s.start() if hasattr(s, 'start') else None),
                ("trigger_manager_service", lambda s: s.start() if hasattr(s, 'start') else None),
                ("api_server_service", lambda s: s.start() if hasattr(s, 'start') else None)
            ]
            for service_id, start_action in services_to_start:
                try:
                    service_instance = self.kernel.get_service(service_id, is_system_call=True)
                    if service_instance:
                        start_action(service_instance)
                except PermissionDeniedError as e:
                    self.logger(f"StartupService: Skipped loading/starting '{service_id}' due to license restrictions.", "WARN")
                except Exception as e:
                    self.logger(f"StartupService: An error occurred with service '{service_id}': {e}", "ERROR")
            time.sleep(1)
            event_bus = self.kernel.get_service("event_bus", is_system_call=True)
            if event_bus:
                event_bus.publish("event_all_services_started", {})
            self.kernel.startup_complete = True
            self.logger("StartupService: All services started successfully.", "SUCCESS")
            return {"status": "complete"}
        except MandatoryUpdateRequiredError:
            raise
        except Exception as e:
            self.logger(f"A critical, unrecoverable error occurred during startup: {e}", "CRITICAL")
            raise e
    def _attempt_auto_login(self):
        self.logger("StartupService: Checking for saved user session...", "INFO")
        state_manager = self.kernel.get_service("state_manager", is_system_call=True)
        if not state_manager:
            self.logger("StartupService: StateManager not available for auto-login.", "WARN")
            return
        saved_token = state_manager.get("user_session_token")
        if not saved_token:
            self.logger("StartupService: No saved session token found.", "INFO")
            return
        self.logger("StartupService: Found session token, attempting to validate with server...", "INFO")
        success, user_data = self.api_client.get_user_profile_by_token(saved_token)
        if success:
            self.logger(f"Auto-login successful for user: {user_data.get('email')}", "SUCCESS")
            self.kernel.current_user = user_data
            user_tier = user_data.get('tier', 'free')
            self.kernel.license_tier = user_tier
            self.kernel.is_premium = self.kernel.TIER_HIERARCHY.get(user_tier, 0) > 0
            event_bus = self.kernel.get_service("event_bus", is_system_call=True)
            if event_bus:
                event_bus.publish("USER_LOGGED_IN", user_data)
        else:
            self.logger(f"Auto-login failed: Token is invalid or expired. Reason: {user_data}", "WARN")
            state_manager.delete("user_session_token")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\state_manager_service\state_manager_service.py
# JUMLAH BARIS : 73
#######################################################################

```py
import os
import json
import threading
from ..base_service import BaseService
class StateManagerService(BaseService):
    """
    Manages persistent state data for the entire application in a thread-safe manner.
    Data is stored in JSON format in the data/state.json file.
    """
    STATE_FILE_NAME = "state.json"
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.data_path = self.kernel.data_path
        self.state_file_path = os.path.join(self.data_path, self.STATE_FILE_NAME)
        self._state_data = {}
        self._lock = threading.Lock()
        self.kernel.write_to_log("Service 'StateManager' initialized.", "DEBUG")
        self.load_state()
    def load_state(self):
        """Loads the state data from the JSON file into memory."""
        with self._lock:
            try:
                if os.path.exists(self.state_file_path):
                    with open(self.state_file_path, 'r', encoding='utf-8') as f:
                        self._state_data = json.load(f)
                    self.kernel.write_to_log(f"StateManager: State loaded successfully from {self.state_file_path}", "INFO")
                else:
                    self._state_data = {}
                    self.kernel.write_to_log("StateManager: state.json not found. A new state will be created.", "INFO")
            except (IOError, json.JSONDecodeError) as e:
                self.kernel.write_to_log(f"StateManager: Failed to load state from file: {e}. Using empty state.", "ERROR")
                self._state_data = {}
    def _save_state_to_file(self):
        """Saves the entire state data from memory to the JSON file."""
        self.kernel.write_to_log(f"StateManagerService: Attempting to save state to file: {self.state_file_path}", "DEBUG")
        try:
            with open(self.state_file_path, 'w', encoding='utf-8') as f:
                json.dump(self._state_data, f, indent=4)
            self.kernel.write_to_log(f"StateManagerService: State successfully saved to file.", "DEBUG")
        except IOError as e:
            self.kernel.write_to_log(f"StateManagerService: FAILED to save state to file. Error: {e}", "ERROR")
    def get(self, key, default=None):
        """Retrieves a value from the state."""
        with self._lock:
            return self._state_data.get(key, default)
    def set(self, key, value):
        """Sets or updates a value in the state and saves it to the file immediately."""
        self.kernel.write_to_log(f"StateManagerService: set() called for key '{key}'.", "DEBUG")
        with self._lock:
            self._state_data[key] = value
            self._save_state_to_file()
        self.kernel.write_to_log(f"StateManager: State for key '{key}' has been set.", "DEBUG")
    def delete(self, key):
        """Deletes a key and its value from the state and saves the changes."""
        with self._lock:
            if key in self._state_data:
                del self._state_data[key]
                self._save_state_to_file()
                self.kernel.write_to_log(f"StateManager: State for key '{key}' has been deleted.", "DEBUG")
            else:
                self.kernel.write_to_log(f"StateManager: Attempted to delete non-existent key '{key}'.", "WARN")
    def get_all(self):
        """Returns a copy of the entire state data."""
        with self._lock:
            return self._state_data.copy()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\tab_manager_service\tab_manager_service.py
# JUMLAH BARIS : 60
#######################################################################

```py
import uuid
from ..base_service import BaseService
from flowork_kernel.api_contract import BaseUIProvider
from flowork_kernel.api_client import ApiClient
import threading
from flowork_kernel.utils.performance_logger import log_performance
class TabManagerService(BaseService):
    """
    (REFACTORED V2) Now subscribes to an event to populate tabs, fixing a race condition.
    (REFACTORED V3) Moves tab discovery to the start() method to fix race condition.
    (FIXED V4) Now correctly gets UI providers from PluginManagerService instead of ModuleManagerService.
    (REFACTORED V5 - API DRIVEN) This service no longer creates UI widgets directly. It only manages
    the STATE of the tabs, which the GUI will fetch via API to render.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.api_client = ApiClient(kernel=self.kernel)
        self.state_manager = self.kernel.get_service("state_manager")
        self.opened_tabs = {}
        self.custom_tab_count = 0
        self.MANAGED_TAB_CLASSES = {}
        self.SESSION_TAB_CLASSES = {} # ADDED: Simplified for backend state management.
        self.initialized_tabs = set()
        self.kernel.write_to_log("Service 'TabManagerService' initialized.", "SUCCESS") # English Log
    def start(self):
        self.kernel.write_to_log("TabManagerService is starting, populating managed tabs immediately.", "INFO") # English Log
        self._populate_managed_tabs()
    def find_workflow_for_node(self, target_node_id: str):
        """
        Searches all WorkflowEditorTabs for a specific node ID.
        If a tab's content is not yet initialized, it will be loaded.
        Returns the workflow graph and the tab instance if found.
        """
        return None, None # ADDED: Return default value. This function is now conceptual for the backend.
    @log_performance("Populating managed tabs from plugins")
    def _populate_managed_tabs(self):
        self.kernel.write_to_log("TabManager: Discovering UI tabs from all plugins...", "DEBUG") # English Log
        plugin_manager = self.kernel.get_service("plugin_manager_service")
        if not plugin_manager:
            self.kernel.write_to_log("TabManager: PluginManagerService not found, cannot discover tabs.", "ERROR") # English Log
            return
        self.MANAGED_TAB_CLASSES.clear()
        for plugin_id, plugin_data in plugin_manager.loaded_plugins.items():
            instance = plugin_manager.get_instance(plugin_id)
            if instance and isinstance(instance, BaseUIProvider):
                provided_tabs = instance.get_ui_tabs()
                for tab_info in provided_tabs:
                    key = tab_info.get("key")
                    if key: #and frame_class:
                        self.MANAGED_TAB_CLASSES[key] = tab_info # Storing the whole info dict
                        self.kernel.write_to_log(f"  -> Discovered tab '{key}' from plugin '{plugin_id}'", "SUCCESS") # English Log
        self.kernel.write_to_log("TabManager's known class list has been updated.", "DEBUG") # English Log
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\trigger_manager_service\trigger_manager_service.py
# JUMLAH BARIS : 324
#######################################################################

```py
import os
import json
import importlib.util
from importlib.machinery import ExtensionFileLoader
import uuid
import time
import tempfile
import zipfile
import shutil
from flowork_kernel.api_contract import BaseTriggerListener
from ..base_service import BaseService
import hashlib
import subprocess
import sys
class TriggerManagerService(BaseService):
    """
    Manages the discovery, loading, and lifecycle of all Trigger modules.
    (MODIFIED V3) Now loads compiled triggers with the '.trigger.flowork' extension.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.triggers_dir = self.kernel.triggers_path
        self.loaded_triggers = {}
        self.active_listeners = []
        self.cache_file = os.path.join(self.kernel.data_path, 'trigger_index.cache')
        self.kernel.write_to_log("Service 'TriggerManager' initialized.", "DEBUG")
    def start(self):
        """
        Subscribes to the main event bus to safely start listeners after all services are ready.
        """
        event_bus = self.kernel.get_service("event_bus")
        if event_bus:
            event_bus.subscribe(
                "event_all_services_started",
                "TriggerManagerStarter",
                self.start_all_listeners
            )
            self.logger("TriggerManager is now waiting for the signal to start all listeners.", "INFO") # English Log
    def _is_cache_valid(self):
        if not os.path.exists(self.cache_file):
            return False
        cache_mod_time = os.path.getmtime(self.cache_file)
        if os.path.exists(self.triggers_dir):
            if os.path.getmtime(self.triggers_dir) > cache_mod_time:
                return False
            for root, dirs, _ in os.walk(self.triggers_dir):
                for d in dirs:
                    if os.path.getmtime(os.path.join(root, d)) > cache_mod_time:
                        return False
        return True
    def discover_and_load_triggers(self):
        self.kernel.write_to_log("TriggerManager: Starting discovery and loading of Trigger modules...", "INFO") # English Log
        self.loaded_triggers.clear()
        if self._is_cache_valid():
            self.kernel.write_to_log("TriggerManager: Valid cache found. Loading triggers from index...", "INFO") # English Log
            with open(self.cache_file, 'r', encoding='utf-8') as f:
                cached_data = json.load(f)
            for trigger_id, trigger_data in cached_data.items():
                self._process_single_trigger(
                    trigger_dir=trigger_data['path'],
                    trigger_id=trigger_id,
                    manifest_override=trigger_data['manifest']
                )
            self.kernel.write_to_log(f"Trigger discovery from cache complete. Total processed: {len(self.loaded_triggers)}", "INFO") # English Log
            return
        self.kernel.write_to_log("TriggerManager: Cache not found or stale. Discovering from disk...", "WARN") # English Log
        discovered_data_for_cache = {}
        if not os.path.exists(self.triggers_dir):
            self.kernel.write_to_log(f"Triggers directory '{self.triggers_dir}' not found. Skipping.", "WARN") # English Log
            return
        for trigger_id in os.listdir(self.triggers_dir):
            trigger_dir = os.path.join(self.triggers_dir, trigger_id)
            if not os.path.isdir(trigger_dir) or trigger_id == '__pycache__':
                continue
            manifest = self._process_single_trigger(trigger_dir, trigger_id)
            if manifest:
                discovered_data_for_cache[trigger_id] = {
                    'manifest': manifest,
                    'path': trigger_dir
                }
        try:
            with open(self.cache_file, 'w', encoding='utf-8') as f:
                json.dump(discovered_data_for_cache, f)
            self.kernel.write_to_log(f"TriggerManager: Trigger index cache created at {self.cache_file}", "SUCCESS") # English Log
        except Exception as e:
            self.kernel.write_to_log(f"TriggerManager: Failed to write trigger cache file: {e}", "ERROR") # English Log
        self.kernel.write_to_log(f"Trigger discovery complete. Total processed: {len(self.loaded_triggers)}", "INFO") # English Log
    def _process_single_trigger(self, trigger_dir, trigger_id, manifest_override=None):
        manifest = manifest_override
        if manifest is None:
            manifest_path = os.path.join(trigger_dir, "manifest.json")
            if not os.path.exists(manifest_path):
                return None
            try:
                with open(manifest_path, 'r', encoding='utf-8') as f:
                    manifest = json.load(f)
            except Exception as e:
                self.kernel.write_to_log(f" ! Failed to load trigger manifest for '{trigger_id}': {e}", "ERROR") # English Log
                return None
        try:
            self.kernel.write_to_log(f" -> Found trigger: '{manifest.get('name', trigger_id)}'", "DEBUG") # English Log
            self._install_dependencies_locally(trigger_dir, manifest.get('name', trigger_id))
            trigger_data = {
                "class": None,
                "manifest": manifest,
                "path": trigger_dir,
                "config_ui_class": None
            }
            entry_point = manifest.get("entry_point")
            if entry_point:
                module_filename, class_name = entry_point.split('.')
                source_file_path = os.path.join(trigger_dir, f"{module_filename}.py")
                native_file_path = os.path.join(trigger_dir, f"{module_filename}.trigger.flowork")
                path_to_load = None
                is_native_module = False
                if os.path.exists(native_file_path):
                    path_to_load = native_file_path
                    is_native_module = True
                elif os.path.exists(source_file_path):
                    path_to_load = source_file_path
                if not path_to_load:
                    raise FileNotFoundError(f"Entry point file '{module_filename}.py' or '{os.path.basename(native_file_path)}' not found.")
                safe_trigger_id = trigger_id.replace('-', '_')
                module_full_name = f"triggers.{safe_trigger_id}.{module_filename}"
                if is_native_module:
                    loader = ExtensionFileLoader(module_full_name, path_to_load)
                    spec = importlib.util.spec_from_loader(loader.name, loader)
                else:
                    spec = importlib.util.spec_from_file_location(module_full_name, source_file_path)
                module_lib = importlib.util.module_from_spec(spec)
                if module_full_name not in sys.modules:
                    sys.modules[module_full_name] = module_lib
                spec.loader.exec_module(module_lib)
                TriggerClass = getattr(module_lib, class_name)
                if not issubclass(TriggerClass, BaseTriggerListener):
                    if manifest.get("id") != "cron_trigger":
                        raise TypeError(f"Class '{class_name}' must inherit from BaseTriggerListener.")
                trigger_data["class"] = TriggerClass
            config_ui_entry = manifest.get("config_ui_entry_point")
            if config_ui_entry:
                ui_module_filename, ui_class_name = config_ui_entry.split('.')
                ui_source_path = os.path.join(trigger_dir, f"{ui_module_filename}.py")
                if not os.path.exists(ui_source_path):
                     raise FileNotFoundError(f"Config UI file '{ui_module_filename}.py' not found.")
                ui_module_full_name = f"triggers.{trigger_id}.{ui_module_filename}"
                ui_spec = importlib.util.spec_from_file_location(ui_module_full_name, ui_source_path)
                ui_module_lib = importlib.util.module_from_spec(ui_spec)
                ui_spec.loader.exec_module(ui_module_lib)
                trigger_data["config_ui_class"] = getattr(ui_module_lib, ui_class_name)
            self.loaded_triggers[trigger_id] = trigger_data
            self.kernel.write_to_log(f" + Trigger '{manifest.get('name', trigger_id)}' processed successfully.", "SUCCESS") # English Log
        except Exception as e:
            self.kernel.write_to_log(f" ! Failed to load trigger from folder '{trigger_id}': {e}", "ERROR") # English Log
        return manifest
    def _calculate_requirements_hash(self, file_path):
        sha256_hash = hashlib.sha256()
        try:
            with open(file_path, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            return sha256_hash.hexdigest()
        except IOError:
            return None
    def _install_dependencies_locally(self, component_path, component_name):
        requirements_path = os.path.join(component_path, 'requirements.txt')
        if not os.path.exists(requirements_path):
            return True
        vendor_path = os.path.join(component_path, 'vendor')
        hash_file_path = os.path.join(component_path, '.vendor_hash')
        current_hash = self._calculate_requirements_hash(requirements_path)
        if os.path.isdir(vendor_path) and os.path.exists(hash_file_path):
            try:
                with open(hash_file_path, 'r') as f:
                    saved_hash = f.read().strip()
                if saved_hash == current_hash:
                    return True
            except IOError:
                pass
        self.kernel.write_to_log(f"Trigger '{component_name}' has local dependencies. Installing into 'vendor' folder...", "INFO") # English Log
        if os.path.isdir(vendor_path):
            shutil.rmtree(vendor_path, ignore_errors=True)
        try:
            python_exe = sys.executable
            command = [
                python_exe, "-m", "pip", "install", "--target", vendor_path,
                "-r", requirements_path, "--no-user", "--disable-pip-version-check"
            ]
            creation_flags = 0
            if sys.platform == "win32":
                creation_flags = subprocess.CREATE_NO_WINDOW
            subprocess.run(command, check=True, capture_output=True, creationflags=creation_flags)
            with open(hash_file_path, 'w') as f:
                f.write(current_hash)
            self.kernel.write_to_log(f"Successfully installed local dependencies for '{component_name}'.", "SUCCESS") # English Log
            return True
        except subprocess.CalledProcessError as e:
            self.kernel.write_to_log(f"FAILED to install local dependencies for '{component_name}'. Pip Error: {e.stderr.decode('utf-8', 'ignore')}", "CRITICAL") # English Log
            return False
        except Exception as e:
            self.kernel.write_to_log(f"An unexpected error occurred during local dependency installation for '{component_name}': {e}", "CRITICAL") # English Log
            return False
    def get_config_ui_class(self, trigger_id: str):
        trigger_data = self.loaded_triggers.get(trigger_id)
        if trigger_data:
            return trigger_data.get("config_ui_class")
        return None
    def start_all_listeners(self, event_data=None):
        self.kernel.write_to_log("TriggerManager: Starting all listeners and scheduling rules...", "INFO") # English Log
        self.stop_all_listeners()
        scheduler_manager = self.kernel.get_service("scheduler_manager_service")
        if scheduler_manager and scheduler_manager.scheduler.running:
            scheduler_manager.scheduler.remove_all_jobs()
        state_manager = self.kernel.get_service("state_manager")
        rules = state_manager.get("trigger_rules", {}) if state_manager else {}
        for rule_id, rule_data in rules.items():
            if not rule_data.get("is_enabled", False):
                continue
            trigger_id = rule_data.get("trigger_id")
            if trigger_id == 'cron_trigger':
                if scheduler_manager:
                    scheduler_manager.schedule_rule(rule_id, rule_data)
            else:
                trigger_info = self.loaded_triggers.get(trigger_id)
                if not trigger_info: continue
                TriggerClass = trigger_info.get("class")
                if not TriggerClass: continue
                try:
                    config = rule_data.get("config", {})
                    services_to_inject = {
                        "kernel": self.kernel,
                        "loc": self.loc,
                        "state_manager": state_manager,
                        "event_bus": self.kernel.get_service("event_bus"),
                        "logger": self.kernel.write_to_log
                    }
                    listener_instance = TriggerClass(trigger_id=trigger_id, config=config, services=services_to_inject, rule_id=rule_id)
                    listener_instance.set_callback(self._handle_event)
                    listener_instance.start()
                    self.active_listeners.append(listener_instance)
                except Exception as e:
                    self.kernel.write_to_log(f"Failed to start listener for rule '{rule_data.get('name')}': {e}", "ERROR") # English Log
    def stop_all_listeners(self):
        if not self.active_listeners:
            return
        for listener in self.active_listeners:
            try:
                listener.stop()
            except Exception as e:
                self.kernel.write_to_log(f"Error while stopping listener for trigger '{listener.trigger_id}': {e}", "ERROR") # English Log
        self.active_listeners.clear()
    def _handle_event(self, event_data: dict):
        rule_id = event_data.get("rule_id")
        state_manager = self.kernel.get_service("state_manager")
        if not rule_id or not state_manager: return
        rules = state_manager.get("trigger_rules", {})
        rule_data = rules.get(rule_id)
        if not rule_data: return
        preset_to_run = rule_data.get("preset_to_run")
        if not preset_to_run: return
        self.kernel.write_to_log(f"TRIGGER DETECTED! Rule '{rule_data.get('name')}' met. Scheduling execution for preset '{preset_to_run}'.", "SUCCESS") # English Log
        initial_payload = {
            "data": {
                "trigger_type": "event",
                "trigger_rule_id": rule_id,
                "trigger_rule_name": rule_data.get('name'),
                "trigger_event_data": event_data
            },
            "history": []
        }
        api_service = self.kernel.get_service("api_server_service")
        if api_service:
            api_service.trigger_workflow_by_api(preset_name=preset_to_run, initial_payload=initial_payload)
    def install_component(self, zip_filepath: str) -> (bool, str):
        with tempfile.TemporaryDirectory() as temp_dir:
            try:
                with zipfile.ZipFile(zip_filepath, 'r') as zip_ref:
                    zip_ref.extractall(temp_dir)
                component_root_path = None
                if os.path.exists(os.path.join(temp_dir, 'manifest.json')):
                    component_root_path = temp_dir
                else:
                    dir_items = [d for d in os.listdir(temp_dir) if os.path.isdir(os.path.join(temp_dir, d))]
                    if len(dir_items) == 1:
                        potential_path = os.path.join(temp_dir, dir_items[0])
                        if os.path.exists(os.path.join(potential_path, 'manifest.json')):
                            component_root_path = potential_path
                if not component_root_path:
                    return False, "manifest.json not found in the root of the zip archive or in a single subdirectory."
                with open(os.path.join(component_root_path, 'manifest.json'), 'r', encoding='utf-8') as f:
                    manifest = json.load(f)
                required_tier = manifest.get('tier', 'free')
                if not self.kernel.is_tier_sufficient(required_tier):
                    error_msg = f"Installation failed. This trigger requires a '{required_tier.capitalize()}' license."
                    return False, error_msg
                component_id = manifest.get('id')
                if not component_id:
                    return False, "Component 'id' is missing from manifest.json."
                final_path = os.path.join(self.triggers_dir, component_id)
                if os.path.exists(final_path):
                    return False, f"Trigger '{component_id}' is already installed."
                shutil.move(component_root_path, final_path)
                return True, f"Trigger '{manifest.get('name', component_id)}' installed successfully."
            except Exception as e:
                return False, f"An error occurred during trigger installation: {e}"
    def uninstall_component(self, component_id: str) -> (bool, str):
        if component_id not in self.loaded_triggers:
            return False, f"Trigger '{component_id}' is not currently loaded or does not exist."
        component_path = self.loaded_triggers[component_id].get('path')
        if not component_path or not os.path.isdir(component_path):
            return False, f"Path for trigger '{component_id}' not found."
        try:
            shutil.rmtree(component_path)
            del self.loaded_triggers[component_id]
            return True, f"Trigger '{component_id}' uninstalled successfully."
        except Exception as e:
            return False, f"Could not delete trigger folder: {e}"
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\update_service\update_service.py
# JUMLAH BARIS : 154
#######################################################################

```py
import os
import json
import hashlib
import requests
from ..base_service import BaseService
import threading
import base64
try:
    from cryptography.hazmat.primitives import hashes as crypto_hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import padding
    from cryptography.exceptions import InvalidSignature
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False
class UpdateService(BaseService):
    """
    (REMASTERED V2) Handles the SECURE automatic update process.
    It now fetches a signature file and cryptographically verifies the
    fingerprint manifest before trusting it, preventing tampering.
    Also respects a 'devmode.on' file to skip updates.
    """
    UPDATE_SIGNATURE_PUBLIC_KEY = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAysqZG2+F82W0TgLHmF3Y
0GRPEZvXvmndTY84N/wA1ljt+JxMBVsmcVTkv8f1TrmFRD19IDzl2Yzb2lgqEbEy
GFxHhudC28leDsVEIp8B+oYWVm8Mh242YKYK8r5DAvr9CPQivnIjZ4BWgKKddMTd
harVxLF2CoSoTs00xWKd6VlXfoW9wdBvoDVifL+hCMepgLLdQQE4HbamPDJ3bpra
pCgcAD5urmVoJEUJdjd+Iic27RBK7jD1dWDO2MASMh/0IyXyM8i7RDymQ88gZier
U0OdWzeCWGyl4EquvR8lj5GNz4vg2f+oEY7h9AIC1f4ARtoihc+apSntqz7nAqa/
sQIDAQAB
-----END PUBLIC KEY-----"""
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.repo_owner = "FLOWORK-gif"
        self.repo_name = "FLOWORK"
        self.branch = "main"
        self.fingerprint_filename = "file_fingerprints.json"
        self.signature_filename = "file_fingerprints.sig"
        self.dev_mode_file = "devmode.on"
        self.public_key = self._load_public_key()
    def _load_public_key(self):
        if not CRYPTO_AVAILABLE:
            self.logger("UpdateService: Cryptography library not found. Signature verification will be skipped.", "CRITICAL")
            return None
        try:
            pem_data = self.UPDATE_SIGNATURE_PUBLIC_KEY.strip().encode('utf-8')
            return serialization.load_pem_public_key(pem_data)
        except Exception as e:
            self.logger(f"UpdateService: Failed to load public key for update verification: {e}", "CRITICAL")
            return None
    def _calculate_local_sha256(self, file_path):
        """Calculates the SHA-256 hash of a file."""
        sha256 = hashlib.sha256()
        try:
            with open(file_path, "rb") as f:
                while chunk := f.read(8192):
                    sha256.update(chunk)
            return sha256.hexdigest()
        except IOError:
            return None
    def _get_verified_remote_fingerprints(self):
        """Downloads the fingerprint manifest and its signature, then verifies them."""
        if not self.public_key:
            self.logger("Update verification skipped: Public key not available.", "ERROR")
            return None # Cannot proceed without the public key
        fingerprint_url = f"https://raw.githubusercontent.com/{self.repo_owner}/{self.repo_name}/{self.branch}/{self.fingerprint_filename}"
        signature_url = f"https://raw.githubusercontent.com/{self.repo_owner}/{self.repo_name}/{self.branch}/{self.signature_filename}"
        try:
            self.logger(f"UpdateService: Fetching fingerprints from {fingerprint_url}", "INFO")
            fp_response = requests.get(fingerprint_url, timeout=15)
            fp_response.raise_for_status()
            fingerprint_content_bytes = fp_response.content
            self.logger(f"UpdateService: Fetching signature from {signature_url}", "INFO")
            sig_response = requests.get(signature_url, timeout=15)
            sig_response.raise_for_status()
            signature_b64 = sig_response.text.strip()
            signature_bytes = base64.b64decode(signature_b64)
            self.public_key.verify(
                signature_bytes,
                fingerprint_content_bytes,
                padding.PKCS1v15(),
                crypto_hashes.SHA256()
            )
            self.logger("UpdateService: Remote fingerprint signature VERIFIED successfully.", "SUCCESS")
            return json.loads(fingerprint_content_bytes)
        except InvalidSignature:
            self.logger("UpdateService: BENTENG BAJA FAILED! The remote fingerprint file has an INVALID signature. Update process aborted for security.", "CRITICAL")
            return None
        except requests.exceptions.RequestException as e:
            self.logger(f"UpdateService: Could not connect to GitHub to check for updates: {e}", "ERROR")
            return None
        except (json.JSONDecodeError, base64.binascii.Error) as e:
            self.logger(f"UpdateService: Fingerprint or signature file is corrupted. Error: {e}", "ERROR")
            return None
        except Exception as e:
            self.logger(f"UpdateService: An unexpected error occurred during verification: {e}", "CRITICAL")
            return None
    def _download_file(self, relative_path):
        """Downloads a single file from the GitHub repo and saves it locally."""
        url = f"https://raw.githubusercontent.com/{self.repo_owner}/{self.repo_name}/{self.branch}/{relative_path}"
        local_path = os.path.join(self.kernel.project_root_path, relative_path.replace('/', os.sep))
        self.logger(f"  -> Downloading update for: {relative_path}", "INFO")
        try:
            os.makedirs(os.path.dirname(local_path), exist_ok=True)
            response = requests.get(url, timeout=30)
            response.raise_for_status()
            with open(local_path, 'wb') as f:
                f.write(response.content)
            return True
        except requests.exceptions.RequestException as e:
            self.logger(f"    [FAIL] Could not download '{relative_path}': {e}", "ERROR")
            return False
    def run_update_check(self):
        """
        The main method called by StartupService to perform the update.
        """
        if self.kernel.is_dev_mode:
            self.logger("DEVELOPER MODE ACTIVE: Auto-update check is disabled.", "WARN")
            return
        self.logger("--- Starting SECURE Automatic Update Check ---", "INFO")
        remote_fingerprints = self._get_verified_remote_fingerprints()
        if not remote_fingerprints:
            self.logger("Could not get or verify remote version info. Skipping update. The application might be offline or the remote files are compromised.", "WARN")
            return
        files_to_update = []
        for relative_path, remote_hash in remote_fingerprints.items():
            local_path = os.path.join(self.kernel.project_root_path, relative_path.replace('/', os.sep))
            if not os.path.exists(local_path):
                files_to_update.append({'path': relative_path, 'reason': 'New file'})
            else:
                local_hash = self._calculate_local_sha256(local_path)
                if local_hash != remote_hash:
                    files_to_update.append({'path': relative_path, 'reason': 'File changed'})
        if not files_to_update:
            self.logger("Application is up to date. No new files to download.", "SUCCESS")
            return
        self.logger(f"Found {len(files_to_update)} file(s) to update/add. Starting download process...", "WARN")
        success_count = 0
        for file_info in files_to_update:
            if self._download_file(file_info['path']):
                success_count += 1
        self.logger(f"Update process finished. {success_count}/{len(files_to_update)} files updated successfully.", "SUCCESS")
        if success_count > 0:
            event_bus = self.kernel.get_service("event_bus")
            if event_bus:
                self.logger("Files were updated. Requesting application restart...", "WARN")
                self.kernel.root.after(2000, lambda: event_bus.publish("RESTART_APP_AFTER_UPDATE", {"message": f"{success_count} file(s) have been updated."}))
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\variable_manager_service\variable_manager_service.py
# JUMLAH BARIS : 234
#######################################################################

```py
import os
import json
import threading
import base64
import logging
import secrets
import string
import random
from ..base_service import BaseService
from flowork_kernel.exceptions import PermissionDeniedError
class VariableManagerService(BaseService):
    """
    Acts as a secure vault for all global and secret variables.
    [MODIFIED V8] Now auto-creates default Supabase variables.
    """
    VARIABLES_FILENAME = "variables.json"
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.variables_file_path = os.path.join(self.kernel.data_path, self.VARIABLES_FILENAME)
        self._variables_data = {}
        self._lock = threading.Lock()
        self.kernel.write_to_log("Service 'VariableManager' initialized.", "DEBUG") # English Log
        self.load_variables()
    def autodiscover_and_sync_variables(self):
        self.logger("VariableManager: Starting autodiscovery of required variables...", "INFO") # English Log
        all_components = {}
        try:
            module_manager = self.kernel.get_service("module_manager_service")
            if module_manager: all_components.update(module_manager.loaded_modules)
        except PermissionDeniedError:
            self.logger("VariableManager: Could not access ModuleManager due to permissions. Skipping.", "WARN") # English Log
        try:
            widget_manager = self.kernel.get_service("widget_manager_service")
            if widget_manager: all_components.update(widget_manager.loaded_widgets)
        except PermissionDeniedError:
            self.logger("VariableManager: Could not access WidgetManager due to permissions. Skipping.", "WARN") # English Log
        try:
            ai_provider_manager = self.kernel.get_service("ai_provider_manager_service")
            if ai_provider_manager:
                ai_providers_components = {}
                if hasattr(ai_provider_manager, 'loaded_providers'):
                    for pid, provider_instance in ai_provider_manager.loaded_providers.items():
                        if hasattr(provider_instance, 'get_manifest'):
                            ai_providers_components[pid] = {"manifest": provider_instance.get_manifest()}
                all_components.update(ai_providers_components)
        except PermissionDeniedError:
             self.logger("VariableManager: Could not access AIProviderManager due to permissions. Skipping its variables.", "WARN") # English Log
        found_new = False
        with self._lock:
            for component_id, data in all_components.items():
                manifest = data.get("manifest", {})
                required_vars = manifest.get("requires_variables", [])
                for var_info in required_vars:
                    var_name = var_info.get("name")
                    if var_name and var_name not in self._variables_data:
                        self.logger(f"  -> Discovered new required variable '{var_name}' from component '{component_id}'. Adding to list.", "INFO") # English Log
                        self._variables_data[var_name] = {
                            "value": "PLEASE_EDIT_ME",
                            "values": [],
                            "mode": "single",
                            "is_secret": var_info.get("is_secret", False),
                            "is_enabled": True,
                            "sequential_index": 0
                        }
                        found_new = True
        if found_new:
            self._save_variables_to_file()
            self.logger("VariableManager: Autodiscovery complete. New variables have been saved.", "SUCCESS") # English Log
        else:
            self.logger("VariableManager: Autodiscovery complete. No new variables needed.", "INFO") # English Log
    def load_variables(self):
        with self._lock:
            requires_save = False
            try:
                if os.path.exists(self.variables_file_path):
                    with open(self.variables_file_path, 'r', encoding='utf-8') as f:
                        self._variables_data = json.load(f)
                else:
                    self._variables_data = {}
                default_vars = {
                    "FLOWORK_API_KEY": {
                        "value_generator": lambda: ''.join(secrets.choice(string.ascii_uppercase + string.digits) for i in range(10)),
                        "is_secret": False
                    },
                    "SUPABASE_URL": {
                        "value_generator": lambda: "https://kmzumshczfkmcijxllps.supabase.co",
                        "is_secret": False
                    },
                    "SUPABASE_KEY": {
                        "value_generator": lambda: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImttenVtc2hjemZrbWNpanhsbHBzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYxMzI3MjAsImV4cCI6MjA3MTcwODcyMH0.QN1tKaXEo9shGQjU8cKiRAiGJSQTHLtC4ifozV3Qs10",
                        "is_secret": True # Kita anggap secret agar bisa disembunyikan di UI
                    }
                }
                for var_name, var_details in default_vars.items():
                    if var_name not in self._variables_data:
                        self.kernel.write_to_log(f"'{var_name}' not found. Generating a new default value.", "WARN") # English Log
                        self._variables_data[var_name] = {
                            "value": var_details["value_generator"](),
                            "values": [],
                            "mode": "single",
                            "is_secret": var_details["is_secret"],
                            "is_enabled": True,
                            "sequential_index": 0
                        }
                        requires_save = True
                for name, data in self._variables_data.items():
                    if 'mode' not in data: data['mode'] = 'single'; requires_save = True
                    if 'values' not in data: data['values'] = []; requires_save = True
                    if 'sequential_index' not in data: data['sequential_index'] = 0; requires_save = True
            except (IOError, json.JSONDecodeError) as e:
                self.kernel.write_to_log(f"VariableManager: Failed to load variables from file: {e}. Using empty state.", "ERROR") # English Log
                self._variables_data = {}
                requires_save = True # Force creation of defaults
            if requires_save:
                self._save_variables_to_file()
    def _save_variables_to_file(self):
        try:
            with open(self.variables_file_path, 'w', encoding='utf-8') as f:
                json.dump(self._variables_data, f, indent=4)
        except IOError as e:
            self.kernel.write_to_log(f"VariableManager: Failed to save variables to file: {e}", "ERROR") # English Log
    def get_all_variables_for_api(self):
        with self._lock:
            api_safe_vars = json.loads(json.dumps(self._variables_data))
            for name, data in api_safe_vars.items():
                if data.get('is_secret'):
                    if data.get('mode', 'single') == 'single':
                        data['value'] = ""
                    else:
                        data['values'] = []
            return [dict(data, **{'name': name}) for name, data in sorted(api_safe_vars.items())]
    def get_all_variables_for_ui(self):
        api_data = self.get_all_variables_for_api()
        ui_list = []
        for var_data in api_data:
            value_for_display = ""
            if var_data.get('mode', 'single') != 'single':
                value_for_display = f"[Pool: {len(var_data.get('values', []))} keys] - Mode: {var_data.get('mode', '').capitalize()}"
            elif var_data.get('is_secret'):
                value_for_display = '*****'
            else:
                value_for_display = var_data.get('value')
            ui_list.append({
                "name": var_data["name"],
                "value": value_for_display,
                "is_secret": var_data.get('is_secret', False),
                "is_enabled": var_data.get('is_enabled', True),
            })
        return ui_list
    def get_variable(self, name):
        with self._lock:
            var_data = self._variables_data.get(name)
            if not var_data or not var_data.get('is_enabled', True):
                return None
            mode = var_data.get('mode', 'single')
            value_to_return = None
            if mode == 'single':
                value_to_return = var_data.get('value')
            elif mode in ['random', 'sequential']:
                values_list = var_data.get('values', [])
                if not values_list:
                    return None
                if mode == 'random':
                    value_to_return = random.choice(values_list)
                elif mode == 'sequential':
                    current_index = var_data.get('sequential_index', 0)
                    value_to_return = values_list[current_index]
                    var_data['sequential_index'] = (current_index + 1) % len(values_list)
                    self._save_variables_to_file() # (IMPORTANT) Save the new index state
            if var_data.get('is_secret') and value_to_return:
                try:
                    decoded_bytes = base64.b64decode(str(value_to_return).encode('utf-8'))
                    return decoded_bytes.decode('utf-8')
                except Exception:
                    return None
            else:
                return value_to_return
    def set_variable(self, name, value, is_secret, is_enabled=True, mode='single'):
        if not name.isupper() or not name.replace('_', '').isalnum():
             raise ValueError("Variable name must only contain uppercase letters (A-Z), numbers (0-9), and underscores (_).")
        with self._lock:
            if mode == 'single':
                processed_value = value
                if is_secret and value and value != "PLEASE_EDIT_ME":
                    processed_value = base64.b64encode(str(value).encode('utf-8')).decode('utf-8')
                self._variables_data[name] = {
                    "value": processed_value,
                    "values": [],
                    "mode": "single",
                    "is_secret": is_secret,
                    "is_enabled": is_enabled,
                    "sequential_index": 0
                }
            else:
                if not isinstance(value, list):
                    raise ValueError("Value for a pooled variable must be a list of strings.")
                processed_values = []
                if is_secret:
                    for val in value:
                        if val: processed_values.append(base64.b64encode(str(val).encode('utf-8')).decode('utf-8'))
                else:
                    processed_values = value
                self._variables_data[name] = {
                    "value": None,
                    "values": processed_values,
                    "mode": mode,
                    "is_secret": is_secret,
                    "is_enabled": is_enabled,
                    "sequential_index": 0
                }
            self._save_variables_to_file()
    def set_variable_enabled_state(self, name, is_enabled: bool):
        with self._lock:
            if name in self._variables_data:
                self._variables_data[name]['is_enabled'] = is_enabled
                self._save_variables_to_file()
                return True
            return False
    def delete_variable(self, name):
        with self._lock:
            if name in self._variables_data:
                del self._variables_data[name]
                self._save_variables_to_file()
                return True
            else:
                return False
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\widget_manager_service\widget_manager_service.py
# JUMLAH BARIS : 252
#######################################################################

```py
import os
import json
import importlib.util
import subprocess
import sys
from importlib.machinery import ExtensionFileLoader
import importlib.metadata
from ..base_service import BaseService
import zipfile
import tempfile
import shutil
import hashlib
class WidgetManagerService(BaseService):
    """
    Manages the discovery, loading, and access to all custom dashboard widgets.
    (MODIFIED V2) Now loads compiled widgets with the '.widget.flowork' extension.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.widgets_dir = self.kernel.widgets_path
        self.loaded_widgets = {}
        self.paused_status_file = os.path.join(self.kernel.data_path, 'paused_widgets.json')
        self.cache_file = os.path.join(self.kernel.data_path, 'widget_index.cache')
        self.kernel.write_to_log("Service 'WidgetManager' initialized.", "DEBUG") # English Log
    def _is_cache_valid(self):
        if not os.path.exists(self.cache_file):
            return False
        cache_mod_time = os.path.getmtime(self.cache_file)
        if os.path.exists(self.widgets_dir):
            if os.path.getmtime(self.widgets_dir) > cache_mod_time:
                return False
            for root, dirs, _ in os.walk(self.widgets_dir):
                for d in dirs:
                    if os.path.getmtime(os.path.join(root, d)) > cache_mod_time:
                        return False
        return True
    def discover_and_load_widgets(self):
        self.kernel.write_to_log("WidgetManager: Starting discovery and loading of custom widgets...", "INFO") # English Log
        auto_compiler = self.kernel.get_service("auto_compiler_service")
        if auto_compiler and self.kernel.is_dev_mode:
            auto_compiler.initial_scan()
        self.loaded_widgets.clear()
        paused_ids = self._load_paused_status()
        if self._is_cache_valid():
            self.kernel.write_to_log("WidgetManager: Valid cache found. Loading widgets from index...", "INFO") # English Log
            with open(self.cache_file, 'r', encoding='utf-8') as f:
                cached_data = json.load(f)
            for widget_id, widget_data in cached_data.items():
                self._process_single_widget(
                    widget_dir=widget_data['path'],
                    widget_id=widget_id,
                    paused_ids=paused_ids,
                    manifest_override=widget_data['manifest']
                )
            self.kernel.write_to_log(f"WidgetManager: Widget loading from cache complete. Total loaded: {len(self.loaded_widgets)}", "INFO") # English Log
            return
        self.kernel.write_to_log("WidgetManager: Cache not found or stale. Discovering from disk...", "WARN") # English Log
        discovered_data_for_cache = {}
        if not os.path.exists(self.widgets_dir):
            return
        for widget_id in os.listdir(self.widgets_dir):
            widget_dir = os.path.join(self.widgets_dir, widget_id)
            if os.path.isdir(widget_dir) and widget_id != '__pycache__':
                manifest = self._process_single_widget(widget_dir, widget_id, paused_ids)
                if manifest:
                    discovered_data_for_cache[widget_id] = {
                        'manifest': manifest,
                        'path': widget_dir
                    }
        try:
            with open(self.cache_file, 'w', encoding='utf-8') as f:
                json.dump(discovered_data_for_cache, f)
            self.kernel.write_to_log(f"WidgetManager: Widget index cache created at {self.cache_file}", "SUCCESS") # English Log
        except Exception as e:
            self.kernel.write_to_log(f"WidgetManager: Failed to write widget cache file: {e}", "ERROR") # English Log
        self.kernel.write_to_log(f"WidgetManager: Custom widget loading complete. Total loaded: {len(self.loaded_widgets)}", "INFO") # English Log
    def _process_single_widget(self, widget_dir, widget_id, paused_ids, manifest_override=None):
        self.kernel.write_to_log(f" -> Processing widget: '{widget_id}'", "DEBUG") # English Log
        manifest = manifest_override
        if manifest is None:
            manifest_path = os.path.join(widget_dir, "manifest.json")
            if not os.path.exists(manifest_path):
                return None
            try:
                with open(manifest_path, 'r', encoding='utf-8') as f:
                    manifest = json.load(f)
            except Exception as e:
                self.kernel.write_to_log(f"   ! Failed to read manifest for widget '{widget_id}': {e}", "WARN") # English Log
                return None
        try:
            self._install_dependencies_locally(widget_dir, manifest.get('name', widget_id))
            entry_point = manifest.get("entry_point")
            if not entry_point:
                raise ValueError("entry_point not found in manifest.json")
            module_filename, class_name = entry_point.split('.')
            native_file_path = os.path.join(widget_dir, f"{module_filename}.widget.flowork")
            source_file_path = os.path.join(widget_dir, f"{module_filename}.py")
            path_to_load = native_file_path if os.path.exists(native_file_path) else source_file_path
            is_native_module = path_to_load.endswith(".widget.flowork")
            if not os.path.exists(path_to_load):
                self.kernel.write_to_log(f"   ! Failed: No source or protected file found for widget '{widget_id}'.", "ERROR") # English Log
                return manifest
            if is_native_module:
                self.logger(f"  -> Found locked native file for widget '{widget_id}'. Prioritizing it.", "DEBUG") # English Log
                module_full_name = f"widgets.{widget_id}.{module_filename}"
                loader = ExtensionFileLoader(module_full_name, path_to_load)
                spec = importlib.util.spec_from_loader(loader.name, loader)
            else:
                safe_widget_id = widget_id.replace('-', '_')
                module_full_name = f"widgets.{safe_widget_id}.{module_filename}"
                spec = importlib.util.spec_from_file_location(module_full_name, source_file_path)
            module_lib = importlib.util.module_from_spec(spec)
            if module_full_name not in sys.modules:
                 sys.modules[module_full_name] = module_lib
            spec.loader.exec_module(module_lib)
            widget_class = getattr(module_lib, class_name)
            self.loaded_widgets[widget_id] = {
                "class": widget_class,
                "name": manifest.get('name', widget_id),
                "manifest": manifest,
                "path": widget_dir,
                "is_paused": widget_id in paused_ids
            }
            self.kernel.write_to_log(f" + Success: Widget '{widget_id}' loaded.", "SUCCESS") # English Log
        except Exception as e:
            self.kernel.write_to_log(f" ! Failed to load widget '{widget_id}': {e}", "ERROR") # English Log
        return manifest
    def _calculate_requirements_hash(self, file_path):
        sha256_hash = hashlib.sha256()
        try:
            with open(file_path, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            return sha256_hash.hexdigest()
        except IOError:
            return None
    def _install_dependencies_locally(self, component_path, component_name):
        requirements_path = os.path.join(component_path, 'requirements.txt')
        if not os.path.exists(requirements_path):
            return True
        vendor_path = os.path.join(component_path, 'vendor')
        hash_file_path = os.path.join(component_path, '.vendor_hash')
        current_hash = self._calculate_requirements_hash(requirements_path)
        if os.path.isdir(vendor_path) and os.path.exists(hash_file_path):
            try:
                with open(hash_file_path, 'r') as f:
                    saved_hash = f.read().strip()
                if saved_hash == current_hash:
                    return True
            except IOError:
                pass
        self.kernel.write_to_log(f"Widget '{component_name}' has local dependencies. Installing into 'vendor' folder...", "INFO") # English Log
        if os.path.isdir(vendor_path):
            shutil.rmtree(vendor_path, ignore_errors=True)
        try:
            python_exe = sys.executable
            command = [
                python_exe, "-m", "pip", "install", "--target", vendor_path,
                "-r", requirements_path, "--no-user", "--disable-pip-version-check"
            ]
            creation_flags = 0
            if sys.platform == "win32":
                creation_flags = subprocess.CREATE_NO_WINDOW
            subprocess.run(command, check=True, capture_output=True, creationflags=creation_flags)
            with open(hash_file_path, 'w') as f:
                f.write(current_hash)
            self.kernel.write_to_log(f"Successfully installed local dependencies for '{component_name}'.", "SUCCESS") # English Log
            return True
        except subprocess.CalledProcessError as e:
            self.kernel.write_to_log(f"FAILED to install local dependencies for '{component_name}'. Pip Error: {e.stderr.decode('utf-8', 'ignore')}", "CRITICAL") # English Log
            return False
        except Exception as e:
            self.kernel.write_to_log(f"An unexpected error occurred during local dependency installation for '{component_name}': {e}", "CRITICAL") # English Log
            return False
    def _load_paused_status(self):
        if os.path.exists(self.paused_status_file):
            try:
                with open(self.paused_status_file, 'r') as f: return json.load(f)
            except (json.JSONDecodeError, IOError): return []
        return []
    def _save_paused_status(self):
        paused_ids = [wid for wid, data in self.loaded_widgets.items() if data.get("is_paused")]
        try:
            with open(self.paused_status_file, 'w') as f: json.dump(paused_ids, f, indent=4)
        except IOError as e:
            self.kernel.write_to_log(f" ! Failed to save widget paused status: {e}", "ERROR") # English Log
    def set_widget_paused(self, widget_id, is_paused):
        if widget_id in self.loaded_widgets:
            self.loaded_widgets[widget_id]["is_paused"] = is_paused
            self._save_paused_status()
            if self.kernel.root:
                self.kernel.root.refresh_ui_components()
            return True
        return False
    def install_component(self, zip_filepath: str) -> (bool, str):
        with tempfile.TemporaryDirectory() as temp_dir:
            try:
                with zipfile.ZipFile(zip_filepath, 'r') as zip_ref:
                    zip_ref.extractall(temp_dir)
                component_root_path = None
                if os.path.exists(os.path.join(temp_dir, 'manifest.json')):
                    component_root_path = temp_dir
                else:
                    dir_items = [d for d in os.listdir(temp_dir) if os.path.isdir(os.path.join(temp_dir, d))]
                    if len(dir_items) == 1:
                        potential_path = os.path.join(temp_dir, dir_items[0])
                        if os.path.exists(os.path.join(potential_path, 'manifest.json')):
                            component_root_path = potential_path
                if not component_root_path:
                    return False, "manifest.json not found in the root of the zip archive or in a single subdirectory."
                with open(os.path.join(component_root_path, 'manifest.json'), 'r', encoding='utf-8') as f:
                    manifest = json.load(f)
                required_tier = manifest.get('tier', 'free')
                if not self.kernel.is_tier_sufficient(required_tier):
                    error_msg = f"Installation failed. This widget requires a '{required_tier.capitalize()}' license or higher. Your current tier is '{self.kernel.license_tier.capitalize()}'."
                    self.kernel.write_to_log(error_msg, "ERROR") # English Log
                    return False, error_msg
                component_id = manifest.get('id')
                if not component_id:
                    return False, "Component 'id' is missing from manifest.json."
                final_path = os.path.join(self.widgets_dir, component_id)
                if os.path.exists(final_path):
                    return False, f"Widget '{component_id}' is already installed."
                shutil.move(component_root_path, final_path)
                self.kernel.write_to_log(f"Widget '{component_id}' installed successfully.", "SUCCESS") # English Log
                return True, f"Widget '{manifest.get('name', component_id)}' installed successfully."
            except Exception as e:
                self.kernel.write_to_log(f"Widget installation failed: {e}", "ERROR") # English Log
                return False, f"An error occurred during widget installation: {e}"
    def uninstall_component(self, component_id: str) -> (bool, str):
        if component_id not in self.loaded_widgets:
            return False, f"Widget '{component_id}' is not currently loaded or does not exist."
        component_data = self.loaded_widgets[component_id]
        component_path = component_data.get('path')
        if not component_path or not os.path.isdir(component_path):
            return False, f"Path for widget '{component_id}' not found or is invalid."
        try:
            shutil.rmtree(component_path)
            del self.loaded_widgets[component_id]
            self.kernel.write_to_log(f"Widget '{component_id}' folder deleted successfully.", "SUCCESS") # English Log
            return True, f"Widget '{component_id}' uninstalled. A restart is required to fully clear it."
        except Exception as e:
            self.kernel.write_to_log(f"Failed to delete widget folder '{component_path}': {e}", "ERROR") # English Log
            return False, f"Could not delete widget folder: {e}"
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\services\workflow_executor_service\workflow_executor_service.py
# JUMLAH BARIS : 471
#######################################################################

```py
import json
import time
import threading
import logging
import re
import os
import uuid
import random
import sys
import psutil
import traceback
from queue import Queue
from ..base_service import BaseService
from flowork_kernel.api_contract import LoopConfig
from flowork_kernel.execution.VariableResolver import VariableResolver
from flowork_kernel.exceptions import PermissionDeniedError
import queue
class WorkflowExecutorService(BaseService):
    """
    (REMASTERED V2) The main engine for running workflows. This version includes a critical
    fix for branching logic to correctly handle single-path execution from nodes with multiple
    output ports like 'IF Condition'.
    """
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self._paused = False
        self._pause_event = threading.Event()
        self._pause_event.set()
        self._stop_event = threading.Event()
        self.behavior_manager = None
        self.current_workflow_context_id = None
        self._connection_history = {}
        self._history_lock = threading.Lock()
        self.variable_resolver = VariableResolver(self.kernel)
        self.logger("Service 'WorkflowExecutor' initialized.", "DEBUG")
        self.process = psutil.Process(os.getpid())
        self.ai_analyzer = self.kernel.get_service("ai_analyzer_service")
    def trigger_workflow_from_node(self, target_node_id: str, payload: dict):
        self.logger(f"Executor searching for node '{target_node_id}' in all active workflow tabs...", "DEBUG")
        tab_manager = self.kernel.get_service("tab_manager_service")
        if not tab_manager:
            self.logger("Cannot trigger from node: TabManagerService is not available.", "ERROR")
            return
        workflow_data, target_tab_widget = tab_manager.find_workflow_for_node(target_node_id)
        if workflow_data and target_tab_widget:
            self.logger(f"Target node '{target_node_id}' found. Starting workflow in tab '{target_tab_widget.tab_id}'.", "SUCCESS")
            self._start_remote_workflow_on_ui_thread(target_tab_widget, target_node_id, payload, workflow_data)
            return
        self.logger(f"Could not find any workflow containing node ID '{target_node_id}'.", "WARN")
    def _wait_for_canvas_manager(self, tab_id, target_node_id, payload, workflow_data, attempt=0):
        MAX_ATTEMPTS = 50
        if attempt > MAX_ATTEMPTS:
            self.logger(f"Timeout waiting for CanvasManager on tab '{tab_id}'. Aborting trigger.", "ERROR")
            return
        tab_manager = self.kernel.get_service("tab_manager_service")
        if not tab_manager or not tab_manager.notebook: return
        target_tab_widget = None
        for tab_id_str in tab_manager.notebook.tabs():
            widget = tab_manager.notebook.nametowidget(tab_id_str)
            if hasattr(widget, 'tab_id') and widget.tab_id == tab_id:
                target_tab_widget = widget
                break
        if not target_tab_widget: return
        if hasattr(target_tab_widget, '_content_initialized') and not target_tab_widget._content_initialized:
            target_tab_widget._initialize_content()
        if hasattr(target_tab_widget, 'canvas_area_instance') and target_tab_widget.canvas_area_instance and hasattr(target_tab_widget.canvas_area_instance, 'canvas_manager') and target_tab_widget.canvas_area_instance.canvas_manager:
            self.logger(f"CanvasManager for tab '{tab_id}' is ready. Starting workflow.", "SUCCESS")
            self._start_remote_workflow_on_ui_thread(target_tab_widget, target_node_id, payload, workflow_data)
        else:
            self.kernel.root.after(100, self._wait_for_canvas_manager, tab_id, target_node_id, payload, workflow_data, attempt + 1)
    def _start_remote_workflow_on_ui_thread(self, target_tab_widget, target_node_id, payload, workflow_data):
        visual_manager = target_tab_widget.canvas_area_instance.canvas_manager.visual_manager
        nodes_dict = {node['id']: node for node in workflow_data['nodes']}
        connections_dict = {conn['id']: conn for conn in workflow_data.get('connections', [])}
        self.execute_workflow(
            nodes_dict, connections_dict, payload,
            logger=self.logger,
            status_updater=visual_manager.update_node_status,
            highlighter=visual_manager.highlight_element,
            ui_callback=target_tab_widget.run_on_ui_thread,
            workflow_context_id=f"remote_trigger_{target_node_id}",
            mode='EXECUTE',
            job_status_updater=None,
            on_complete=target_tab_widget.action_handler._on_execution_finished,
            start_node_id=target_node_id
        )
    def _record_connection_event(self, context_id, connection_id, payload):
        with self._history_lock:
            if context_id not in self._connection_history:
                self._connection_history[context_id] = {}
            if 'steps' not in self._connection_history[context_id]:
                self._connection_history[context_id]['steps'] = []
            history_entry = {
                'connection_id': connection_id,
                'payload': payload,
                'timestamp': time.time()
            }
            self._connection_history[context_id]['steps'].append(history_entry)
    def get_connection_history(self, context_id, connection_id=None):
        with self._history_lock:
            history = self._connection_history.get(context_id, {})
            try:
                serializable_history = json.loads(json.dumps(history, default=str))
                return serializable_history
            except (TypeError, OverflowError):
                history['steps'] = [{'payload': str(step['payload']), 'connection_id': step['connection_id']} for step in history.get('steps', [])]
                return history
    def get_current_context_id(self):
        return self.current_workflow_context_id
    def _get_fresh_settings(self):
        settings_path = os.path.join(self.kernel.data_path, "settings.json")
        if not os.path.exists(settings_path):
            return {}
        try:
            with open(settings_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            self.kernel.write_to_log(f"Failed to read settings.json directly: {e}", "ERROR")
            return {}
    def _execute_global_error_handler(self, original_error, failed_workflow_id):
        fresh_settings = self._get_fresh_settings()
        handler_preset_name = fresh_settings.get('global_error_workflow_preset')
        self.kernel.write_to_log(f"GLOBAL ERROR HANDLER: Triggering preset '{handler_preset_name}'...", "WARN")
        preset_manager = self.kernel.get_service("preset_manager")
        if not preset_manager:
            self.kernel.write_to_log(f"GLOBAL ERROR HANDLER: Failed, PresetManager service not available.", "ERROR")
            return
        handler_workflow_data = preset_manager.get_preset_data(handler_preset_name)
        if not handler_workflow_data:
            self.kernel.write_to_log(f"GLOBAL ERROR HANDLER: Failed, preset '{handler_preset_name}' not found.", "ERROR")
            return
        error_payload = { "data": { "failed_workflow_id": failed_workflow_id, "error_message": str(original_error), "error_time": time.time() }, "history": [] }
        try:
            nodes = {node['id']: node for node in handler_workflow_data.get('nodes', [])}
            connections = {conn['id']: conn for conn in handler_workflow_data.get('connections', [])}
            self.execute_workflow_synchronous(
                nodes=nodes, connections=connections, initial_payload=error_payload,
                logger=self.kernel.write_to_log, status_updater=lambda a, b, c: None,
                highlighter=lambda a, b: None, ui_callback=lambda func, *args: func(*args),
                workflow_context_id=f"error_handler_for_{failed_workflow_id}", mode='EXECUTE', job_status_updater=None
            )
            self.kernel.write_to_log(f"GLOBAL ERROR HANDLER: Execution of preset '{handler_preset_name}' completed.", "SUCCESS")
        except Exception as handler_e:
            self.kernel.write_to_log(f"GLOBAL ERROR HANDLER: An error occurred while EXECUTING the error handler itself: {handler_e}", "ERROR")
    def execute_workflow(self, nodes, connections, initial_payload, logger=None, status_updater=None, highlighter=None, ui_callback=None, workflow_context_id="default_workflow", mode='EXECUTE', job_status_updater=None, on_complete=None, start_node_id=None):
        log = logger if callable(logger) else self.kernel.write_to_log
        exec_thread = threading.Thread(
            target=self.execute_workflow_synchronous,
            args=(nodes, connections, initial_payload, log, status_updater, highlighter, ui_callback, workflow_context_id, mode, job_status_updater, on_complete, start_node_id)
        )
        exec_thread.daemon = True
        exec_thread.start()
        return exec_thread
    def execute_workflow_synchronous(self, nodes, connections, initial_payload, logger, status_updater, highlighter, ui_callback, workflow_context_id, mode, job_status_updater, on_complete=None, start_node_id=None):
        log = logger or self.kernel.write_to_log
        run_on_ui = ui_callback if callable(ui_callback) else lambda func, *args: func(*args) if callable(func) else None
        with self._history_lock:
            if workflow_context_id in self._connection_history:
                del self._connection_history[workflow_context_id]
                log(f"Cleared previous run history for context: {workflow_context_id}", "DEBUG")
        if self.behavior_manager is None:
            self.behavior_manager = self.kernel.get_service("behavior_manager_service")
        self.current_workflow_context_id = workflow_context_id
        if callable(job_status_updater):
            job_status_updater(workflow_context_id, {"status": "RUNNING"})
        self._paused = False
        self._pause_event.set()
        self._stop_event.clear()
        if mode == 'SIMULATE':
            log("===== STARTING SIMULATION MODE =====", "WARN")
        if not nodes:
            log("Execution failed: No nodes to execute.", "ERROR")
            return ValueError("No nodes to execute.")
        state_manager = self.kernel.get_service("state_manager")
        checkpoint_key = f"checkpoint::{workflow_context_id}"
        saved_checkpoint = state_manager.get(checkpoint_key) if state_manager else None
        final_payload = None
        try:
            if saved_checkpoint and isinstance(saved_checkpoint, dict) and mode == 'EXECUTE':
                resume_node_id = saved_checkpoint.get("node_id")
                resume_payload = saved_checkpoint.get("payload")
                if resume_node_id and resume_payload is not None:
                    node_name = nodes.get(resume_node_id, {}).get('name', resume_node_id)
                    log(f"CHECKPOINT FOUND: Resuming workflow from state after '{node_name}'.", "WARN")
                    if state_manager:
                        state_manager.delete(checkpoint_key)
                    final_payload = self._find_and_execute_next_nodes(
                        current_node_id=resume_node_id,
                        execution_result=resume_payload,
                        nodes=nodes, connections=connections, log=log,
                        update_status=status_updater, highlight=highlighter,
                        run_on_ui=run_on_ui,
                        workflow_context_id=workflow_context_id, mode=mode
                    )
            elif start_node_id:
                log(f"Service call: Starting workflow execution from specific node '{nodes.get(start_node_id, {}).get('name', start_node_id)}'.", "DEBUG")
                final_payload = self._traverse_and_execute(start_node_id, nodes, connections, initial_payload, log, status_updater, highlighter, run_on_ui, workflow_context_id, mode)
            else:
                all_node_ids = set(nodes.keys())
                nodes_with_incoming = set(conn_data['to'] for conn_data in connections.values() if conn_data.get('to') and conn_data.get('type', 'data') == 'data')
                start_nodes = all_node_ids - nodes_with_incoming
                if not start_nodes:
                    log("Execution failed: No start node found.", "ERROR")
                    return ValueError("No start node found.")
                final_payload = self._run_all_flows_sequentially(start_nodes, nodes, connections, log, status_updater, highlighter, run_on_ui, initial_payload, workflow_context_id, mode)
            if isinstance(final_payload, Exception):
                raise final_payload
        except PermissionDeniedError as e:
            final_payload = e
            log(f"!!! PERMISSION DENIED IN WORKFLOW: {e}", "CRITICAL")
            if hasattr(self.kernel, 'root') and self.kernel.root and hasattr(self.kernel.root, 'display_permission_denied_popup'):
                run_on_ui(self.kernel.display_permission_denied_popup, str(e))
        except Exception as e:
            final_payload = e
            log(f"!!! FATAL ERROR IN WORKFLOW EXECUTOR: {e}", "ERROR")
            log(traceback.format_exc(), "DEBUG")
        finally:
            if isinstance(final_payload, Exception):
                if callable(job_status_updater):
                    job_status_updater(workflow_context_id, {"status": "FAILED", "end_time": time.time(), "error": str(final_payload)})
                fresh_settings = self._get_fresh_settings()
                if fresh_settings.get('global_error_handler_enabled') and fresh_settings.get('global_error_workflow_preset') and not workflow_context_id.startswith("error_handler_for_"):
                    self._execute_global_error_handler(final_payload, workflow_context_id)
            else:
                if callable(job_status_updater):
                     job_status_updater(workflow_context_id, {"status": "SUCCEEDED", "end_time": time.time(), "result": "Execution completed successfully."})
            if mode == 'SIMULATE':
                log("===== SIMULATION FINISHED =====", "WARN")
            self.current_workflow_context_id = None
            history = self.get_connection_history(workflow_context_id)
            if callable(on_complete):
                run_on_ui(on_complete, history)
            if self.ai_analyzer and mode == 'EXECUTE':
                log(f"Executor: Attempting to dispatch analysis request for context '{workflow_context_id}'", "INFO")
                try:
                    permission_manager = self.kernel.get_service("permission_manager_service", is_system_call=True)
                    if permission_manager and permission_manager.check_permission("ai_copilot", is_system_call=False):
                         self.ai_analyzer.request_analysis(workflow_context_id)
                except PermissionDeniedError:
                    self.logger("AI Co-pilot analysis skipped due to license tier.", "WARN")
        return final_payload
    def stop_execution(self):
        self.kernel.write_to_log("STOP request received.", "INFO")
        self._stop_event.set()
    def pause_execution(self):
        self._paused = True
        self._pause_event.clear()
    def resume_execution(self):
        self._paused = False
        self._pause_event.set()
    def _run_all_flows(self, start_nodes, nodes, connections, log, update_status, highlight, run_on_ui, initial_payload, workflow_context_id, mode):
        final_payload = initial_payload
        threads = []
        results_queue = queue.Queue()
        def target_wrapper(start_node_id, payload_copy):
            try:
                result = self._traverse_and_execute(start_node_id, nodes, connections, payload_copy, log, update_status, highlight, run_on_ui, workflow_context_id, mode)
                results_queue.put(result)
            except Exception as e:
                results_queue.put(e)
        for start_node_id in start_nodes:
            payload_copy = json.loads(json.dumps(initial_payload))
            thread = threading.Thread(target=target_wrapper, args=(start_node_id, payload_copy))
            threads.append(thread)
            thread.start()
        for thread in threads:
            thread.join()
        while not results_queue.empty():
            result = results_queue.get()
            if isinstance(result, Exception):
                return result
            final_payload = result
        return final_payload
    def _run_all_flows_sequentially(self, start_nodes, nodes, connections, log, update_status, highlight, run_on_ui, initial_payload, workflow_context_id, mode):
        final_payload = initial_payload
        for start_node_id in start_nodes:
             final_payload = self._traverse_and_execute(start_node_id, nodes, connections, final_payload, log, update_status, highlight, run_on_ui, workflow_context_id, mode)
             if isinstance(final_payload, Exception):
                 return final_payload
        return final_payload
    def _find_and_execute_next_nodes(self, current_node_id, execution_result, nodes, connections, log, update_status, highlight, run_on_ui, workflow_context_id="default_workflow", mode: str = 'EXECUTE'):
        if self._stop_event.is_set():
            return execution_result
        if isinstance(execution_result, Exception):
            return execution_result
        payload_for_next = execution_result.get('payload', execution_result) if isinstance(execution_result, dict) else execution_result
        expected_output_name = None
        if isinstance(execution_result, dict) and "output_name" in execution_result:
            expected_output_name = execution_result["output_name"]
        next_nodes_to_execute = []
        for conn_id, conn_data in connections.items():
            if conn_data.get('from') == current_node_id and conn_data.get('type', 'data') != 'tool':
                source_port_name = conn_data.get('source_port_name')
                if expected_output_name is not None:
                    if source_port_name == expected_output_name:
                        self._record_connection_event(workflow_context_id, conn_id, payload_for_next)
                        next_nodes_to_execute.append((conn_id, conn_data.get('to'), payload_for_next))
                else:
                    self._record_connection_event(workflow_context_id, conn_id, payload_for_next)
                    next_nodes_to_execute.append((conn_id, conn_data.get('to'), payload_for_next))
        if not next_nodes_to_execute:
            node_name_for_log = nodes.get(current_node_id, {}).get('name', '[Unnamed Node]')
            log(f"Execution path finished. Node '{node_name_for_log}' has no outgoing connections from port '{expected_output_name or 'default'}'.", "INFO")
            return execution_result
        if len(next_nodes_to_execute) > 1:
            threads = []
            results_queue = queue.Queue()
            def target_wrapper(next_node_id, payload_copy):
                try:
                    result = self._traverse_and_execute(next_node_id, nodes, connections, payload_copy, log, update_status, highlight, run_on_ui, workflow_context_id, mode)
                    results_queue.put(result)
                except Exception as e:
                    results_queue.put(e)
            for conn_id, next_node_id, payload in next_nodes_to_execute:
                if not next_node_id: continue
                if callable(highlight): run_on_ui(highlight, 'connection', conn_id); time.sleep(0.1)
                payload_copy = json.loads(json.dumps(payload, default=str))
                thread = threading.Thread(target=target_wrapper, args=(next_node_id, payload_copy))
                threads.append(thread)
                thread.start()
            for thread in threads:
                thread.join()
            successful_results = []
            exceptions = []
            while not results_queue.empty():
                result = results_queue.get()
                if isinstance(result, Exception):
                    exceptions.append(result)
                else:
                    successful_results.append(result)
            if exceptions:
                for exc in exceptions:
                    log(f"A parallel branch failed with an error: {exc}", "WARN")
            if successful_results:
                return successful_results[-1]
            elif exceptions:
                log(f"All {len(exceptions)} parallel branches failed. Propagating the first error.", "ERROR")
                return exceptions[0]
            else:
                return execution_result
        else:
            conn_id, next_node_id, payload = next_nodes_to_execute[0]
            if not next_node_id: return payload
            if callable(highlight): run_on_ui(highlight, 'connection', conn_id); time.sleep(0.1)
            return self._traverse_and_execute(next_node_id, nodes, connections, payload, log, update_status, highlight, run_on_ui, workflow_context_id, mode)
    def _traverse_and_execute(self, current_node_id, nodes, connections, payload, log, update_status, highlight, run_on_ui, workflow_context_id, mode):
        if self._stop_event.is_set(): return payload
        self._pause_event.wait()
        if current_node_id not in nodes: return payload
        node_info = nodes[current_node_id]
        start_time = time.perf_counter()
        mem_before = self.process.memory_info().rss
        payload_size_in = sys.getsizeof(payload)
        execution_result = None
        try:
            node_name_for_log = node_info.get('name', '[Unnamed]')
            module_id_to_run = node_info.get("module_id")
            module_manager = self.kernel.get_service("module_manager_service")
            if not module_manager: raise ValueError("ModuleManagerService not available.")
            if module_id_to_run in self.kernel.MODULE_CAPABILITY_MAP:
                capability_needed = self.kernel.MODULE_CAPABILITY_MAP[module_id_to_run]
                self.logger(f"Capability check required for module '{module_id_to_run}': '{capability_needed}'", "DEBUG")
                permission_manager = self.kernel.get_service("permission_manager_service")
                if permission_manager:
                    permission_manager.check_permission(capability_needed)
            module_instance = module_manager.get_instance(module_id_to_run)
            if not module_instance: raise ValueError(f"Module '{module_id_to_run}' not found or is paused.")
            if callable(highlight) and not getattr(module_instance, 'MANAGES_OWN_HIGHLIGHTING', False):
                run_on_ui(highlight, 'node', current_node_id); time.sleep(0.1)
            log(f"INFO: Executing node '{node_name_for_log}' (Module: {module_id_to_run})", "INFO")
            node_config = node_info.get("config_values", {})
            node_config['__internal_node_id'] = current_node_id
            resolved_config = self.variable_resolver.resolve(node_config)
            kwargs_for_execute = {}
            if module_id_to_run == 'agent_host_module':
                log("Executor: Agent Host Node detected. Gathering connected components.", "DEBUG")
                kwargs_for_execute['highlighter'] = highlight
                kwargs_for_execute['connections'] = connections
                connected_tools = []
                connected_brain = None
                connected_prompt = None
                log(f"--- START AGENT HOST CONNECTION INSPECTION (Node ID: {current_node_id}) ---", "DEBUG")
                for conn_id, conn_data in connections.items():
                    log(f"  Inspecting connection '{conn_id}': FROM {conn_data.get('from')} TO {conn_data.get('to')} | TYPE: {conn_data.get('type')} | TARGET PORT: {conn_data.get('target_port_name')}", "DEBUG")
                    if conn_data.get('to') == current_node_id:
                        log(f"    -> Connection is incoming to Agent Host.", "DEBUG")
                        if conn_data.get('type') == 'tool':
                            log(f"    -> Connection type is 'tool'. MATCH!", "SUCCESS")
                            source_node_id = conn_data.get('from')
                            target_port = conn_data.get('target_port_name')
                            if source_node_id in nodes:
                                source_node_data = nodes[source_node_id]
                                if target_port == 'brain_port':
                                    connected_brain = source_node_data
                                    log(f"    -> Target port is 'brain_port'. BRAIN FOUND: '{source_node_data.get('name')}'", "SUCCESS")
                                elif target_port == 'prompt_port':
                                    connected_prompt = source_node_data
                                    log(f"    -> Target port is 'prompt_port'. PROMPT FOUND: '{source_node_data.get('name')}'", "SUCCESS")
                                elif target_port == 'tools_port':
                                    connected_tools.append(source_node_data)
                                    log(f"    -> Target port is 'tools_port'. TOOL ADDED: '{source_node_data.get('name')}'", "SUCCESS")
                                else:
                                    log(f"    -> WARNING: Connection is 'tool' type but target port '{target_port}' is unknown.", "WARN")
                            else:
                                log(f"    -> ERROR: Source node '{source_node_id}' not found in nodes dictionary.", "ERROR")
                        else:
                            log(f"    -> Connection type is '{conn_data.get('type')}', not 'tool'. SKIPPING.", "INFO")
                log(f"--- END AGENT HOST CONNECTION INSPECTION ---", "DEBUG")
                kwargs_for_execute['connected_tools'] = connected_tools
                kwargs_for_execute['connected_brain'] = connected_brain
                kwargs_for_execute['connected_prompt'] = connected_prompt
            def safe_status_updater(msg, lvl):
                if callable(update_status):
                    run_on_ui(update_status, current_node_id, msg, lvl)
            def core_execution_function(current_payload, current_config, status_updater_func, ui_callback_func, current_mode, node_info_func, highlight_func, **kwargs):
                return module_instance.execute(
                    current_payload, current_config, status_updater_func, ui_callback_func,
                    current_mode, **kwargs
                )
            wrapped_executor = self.behavior_manager.wrap_execution(module_id_to_run, core_execution_function)
            execution_result = wrapped_executor(
                payload, resolved_config, safe_status_updater, run_on_ui, mode,
                node_info, highlight, **kwargs_for_execute
            )
            if not self._stop_event.is_set():
                connections_from_this_node = [c for c in connections.values() if c.get('from') == current_node_id]
                if not connections_from_this_node:
                    log(f"Service workflow reached an end node '{node_name_for_log}'. Returning its result.", "DEBUG")
                    return execution_result
                return self._find_and_execute_next_nodes(current_node_id, execution_result, nodes, connections, log, update_status, highlight, run_on_ui, workflow_context_id, mode)
            else:
                return payload
        except PermissionDeniedError as e:
            execution_result = e
            log(f"ERROR: An error occurred while executing node '{node_info.get('name', 'N/A')}': {e}", "ERROR")
            if callable(update_status):
                run_on_ui(update_status, current_node_id, "Error", "ERROR")
            raise e
        except Exception as e:
            execution_result = e
            log(f"ERROR: An error occurred while executing node '{node_info.get('name', 'N/A')}': {e}", "ERROR")
            if callable(update_status):
                run_on_ui(update_status, current_node_id, "Error", "ERROR")
            return e
        finally:
            if mode == 'EXECUTE':
                end_time = time.perf_counter()
                mem_after = self.process.memory_info().rss
                payload_size_out = sys.getsizeof(execution_result)
                metric_data = {
                    "workflow_context_id": workflow_context_id,
                    "node_id": current_node_id,
                    "node_name": node_info.get('name', '[Unnamed]'),
                    "module_id": node_info.get("module_id"),
                    "status": "ERROR" if isinstance(execution_result, Exception) else "SUCCESS",
                    "execution_time_ms": (end_time - start_time) * 1000,
                    "memory_usage_bytes": mem_after - mem_before,
                    "payload_size_in_bytes": payload_size_in,
                    "payload_size_out_bytes": payload_size_out,
                }
                event_bus = self.kernel.get_service("event_bus")
                if event_bus:
                    event_bus.publish("NODE_EXECUTION_METRIC", metric_data)
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\utils\condition_evaluator.py
# JUMLAH BARIS : 62
#######################################################################

```py
from .type_converter import to_number
def evaluate_condition(actual_value, operator, compare_value):
    """
    Evaluates a condition between an actual value and a comparison value using a specified operator.
    This is the central logic for all 'if' comparisons in the system.
    Args:
        actual_value: The value from the payload.
        operator (str): The comparison operator (e.g., '==', '>', 'contains').
        compare_value: The value to compare against.
    Returns:
        bool: True if the condition is met, False otherwise.
    """
    if operator == "is empty":
        return not actual_value
    if operator == "is not empty":
        return bool(actual_value)
    if operator == "is number":
        return to_number(actual_value) is not None
    if operator == "is not number":
        return to_number(actual_value) is None
    str_actual = str(actual_value).lower()
    str_compare = str(compare_value).lower()
    if operator == "contains":
        return str_compare in str_actual
    if operator == "not contains":
        return str_compare not in str_actual
    if operator == "starts_with":
        return str_actual.startswith(str_compare)
    if operator == "ends_with":
        return str_actual.endswith(str_compare)
    if operator == "==":
        try:
            typed_compare_value = type(actual_value)(compare_value)
            return actual_value == typed_compare_value
        except (ValueError, TypeError):
            return str(actual_value) == str(compare_value)
    if operator == "!=":
        try:
            typed_compare_value = type(actual_value)(compare_value)
            return actual_value != typed_compare_value
        except (ValueError, TypeError):
            return str(actual_value) != str(compare_value)
    num_actual = to_number(actual_value)
    num_compare = to_number(compare_value)
    if num_actual is not None and num_compare is not None:
        if operator == ">":
            return num_actual > num_compare
        if operator == "<":
            return num_actual < num_compare
        if operator == ">=":
            return num_actual >= num_compare
        if operator == "<=":
            return num_actual <= num_compare
    return False
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\utils\file_helper.py
# JUMLAH BARIS : 26
#######################################################################

```py
import re
def sanitize_filename(name: str) -> str:
    """
    Cleans a string to make it a valid filename.
    It removes characters that are illegal in Windows, Linux, and macOS filenames,
    and replaces whitespace with underscores.
    Args:
        name (str): The original filename or string.
    Returns:
        str: A sanitized, safe filename.
    """
    if not isinstance(name, str):
        name = str(name)
    sanitized = re.sub(r'[<>:"/\\|?*]', '', name)
    sanitized = re.sub(r'\s+', '_', sanitized)
    if not sanitized:
        return "unnamed_file"
    return sanitized
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\utils\payload_helper.py
# JUMLAH BARIS : 23
#######################################################################

```py
def get_nested_value(d, key_path):
    """
    Safely retrieves a value from a nested dictionary using a dot-separated path.
    Example: get_nested_value(payload, 'data.user.name')
    """
    if not key_path or not isinstance(key_path, str):
        return None
    parts = key_path.split('.')
    val = d
    for part in parts:
        if isinstance(val, dict) and part in val:
            val = val[part]
        else:
            return None
    return val
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\utils\performance_logger.py
# JUMLAH BARIS : 32
#######################################################################

```py
import time
from functools import wraps
def log_performance(log_message: str):
    """
    A decorator that logs the execution time of a function.
    It accesses the api_client logger through the 'self' argument of the decorated method.
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            instance = args[0] if args else None
            logger = print # Default to print
            start_time = time.perf_counter()
            result = func(*args, **kwargs)
            end_time = time.perf_counter()
            duration_ms = (end_time - start_time) * 1000
            log_entry = f"PERF-GUI: {log_message} - Execution Time: {duration_ms:.2f} ms" # English Hardcode
            if logger:
                logger(log_entry)
            else:
                print(log_entry) # Fallback
            return result
        return wrapper
    return decorator
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\utils\type_converter.py
# JUMLAH BARIS : 20
#######################################################################

```py
def to_number(value):
    """
    Safely converts a value to an integer or float.
    Returns the number if successful, otherwise returns None.
    """
    try:
        return int(value)
    except (ValueError, TypeError):
        try:
            return float(value)
        except (ValueError, TypeError):
            return None
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\flowork_kernel\workers\ai_worker.py
# JUMLAH BARIS : 53
#######################################################################

```py
import sys
import json
import io # (ADDED) Import the io module
from llama_cpp import Llama
def main():
    """
    This worker script is designed to be called by a subprocess.
    It loads a GGUF model, takes a prompt from stdin,
    generates a response, and prints the response to stdout.
    This isolates the memory-intensive AI operations from the main application.
    """
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')
    if len(sys.argv) < 3:
        print(json.dumps({"error": "Worker requires model_path and n_gpu_layers arguments."}))
        sys.exit(1)
    model_path = sys.argv[1]
    try:
        n_gpu_layers_from_arg = int(sys.argv[2])
    except (ValueError, TypeError):
        print(json.dumps({"error": f"Invalid n_gpu_layers argument received: {sys.argv[2]}"}))
        sys.exit(1)
    print(f"AI Worker: Initializing. Loading model: {model_path} with n_gpu_layers={n_gpu_layers_from_arg}", file=sys.stderr)
    try:
        prompt = sys.stdin.read()
        llm = Llama(
            model_path=model_path,
            n_ctx=8192,
            n_gpu_layers=n_gpu_layers_from_arg,
            verbose=False
        )
        messages = [{"role": "user", "content": prompt}]
        response = llm.create_chat_completion(
            messages=messages,
            max_tokens=2048,
            temperature=0.2
        )
        raw_suggestions = response['choices'][0]['message']['content'].strip()
        print(raw_suggestions)
    except Exception as e:
        error_response = {"error": f"AI Worker failed: {e}", "traceback": str(e)}
        print(json.dumps(error_response), file=sys.stderr)
        sys.exit(1)
if __name__ == "__main__":
    main()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\formatters\csv_formatter\formatter.py
# JUMLAH BARIS : 25
#######################################################################

```py
import csv
import io
class CsvFormatter:
    """A formatter for handling CSV data."""
    def parse(self, data_string: str) -> list:
        """Parses a CSV string into a list of dictionaries."""
        reader = csv.DictReader(io.StringIO(data_string))
        return [row for row in reader]
    def stringify(self, data_list: list) -> str:
        """Converts a list of dictionaries into a CSV string."""
        if not data_list:
            return ""
        output = io.StringIO()
        writer = csv.DictWriter(output, fieldnames=data_list[0].keys())
        writer.writeheader()
        writer.writerows(data_list)
        return output.getvalue()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\locales\en.json
# JUMLAH BARIS : 586
#######################################################################

```json
{
    "app_title": "FLOWORK Synapse : Weaving Intelligence",
    "menu_file": "File",
    "menu_save_workflow": "Save Workflow",
    "menu_load_workflow": "Load Workflow",
    "menu_exit": "Exit",
    "workflow_editor_tab_title": "Dashboard",
    "settings_tab_title": "Settings",
    "untitled_tab_title": "Untitled {count}",
    "context_menu_rename_tab": "Rename Tab",
    "menu_close_tab": "Close Tab",
    "rename_tab_popup_title": "Rename Tab",
    "rename_tab_popup_label": "Enter a new name for the tab:",
    "logic_modules_title": "Logic Modules",
    "run_workflow_button": "Run Workflow",
    "clear_cache_button": "Clear Cache",
    "module_name_column": "Module Name",
    "action_plugins_title": "Action Plugins",
    "plugin_name_column": "Plugin Name",
    "properties_title": "Node Properties",
    "execution_log_title": "Execution Log",
    "copy_log_button": "Copy Log",
    "clear_log_button": "Clear Log",
    "search_log_placeholder": "Search Log...",
    "log_level_all": "All",
    "log_level_info": "Info",
    "log_level_warn": "Warning",
    "log_level_error": "Error",
    "log_level_success": "Success",
    "log_level_debug": "Debug",
    "log_level_cmd": "Command",
    "log_level_detail": "Detail",
    "log_copied_to_clipboard": "Log: Log content copied to clipboard.",
    "log_cleared": "Log: Log cleared.",
    "exec_no_nodes": "WARNING: There are no nodes on the canvas to execute.",
    "exec_no_start_node": "ERROR: No starting node found. Check the workflow for infinite loops.",
    "exec_found_start_nodes": "INFO: Found {count} starting nodes. Beginning execution...",
    "exec_executing_node": "INFO: Executing node '{node_name}' (Module: {module_id})",
    "exec_payload_out": "DETAIL: Produced payload:",
    "exec_going_to_next": "INFO: Proceeding to next node: {node_id}",
    "log_clearing_canvas": "INFO: Clearing the canvas...",
    "flowork_workflow_filetype": "Flowork Workflow",
    "workflow_saved_success": "Workflow saved successfully.",
    "workflow_loaded_success": "Workflow loaded successfully.",
    "error_title": "Error",
    "node_deleted_success": "Node '{node_id}' deleted successfully.",
    "confirm_cache_clear_title": "Confirm Cache Clear",
    "confirm_cache_clear_message": "This will remove all Python cache files (__pycache__) and log files (*.log) from the project folder. Continue?",
    "info_done": "Done",
    "cache_clear_summary_log": "SUCCESS: Cache clear complete. {folders} cache folders and {files} log files were deleted.",
    "context_menu_delete_node": "Delete Node",
    "context_menu_delete_connection": "Delete Connection",
    "context_menu_properties": "Properties",
    "context_menu_duplicate_node": "Duplicate Node",
    "node_duplicated_success": "Node '{node_id}' duplicated successfully.",
    "button_cancel": "Cancel",
    "theme_management_title": "Theme Management",
    "upload_theme_button": "Upload Theme",
    "uninstall_button": "❌",
    "theme_list_item_format": "• {name} ({id})",
    "info_title": "Info",
    "success_title": "Success",
    "failed_title": "Failed",
    "warning_title": "Warning",
    "confirm_delete_title": "Confirm Deletion",
    "confirm_delete_preset_message": "Are you sure you want to delete the preset '{name}'?",
    "select_theme_file_title": "Select Theme File (.json)",
    "json_files_label": "JSON Files",
    "invalid_theme_format_error": "JSON file is not a valid theme format (requires 'name' and 'colors').",
    "theme_upload_success": "Theme '{name}' uploaded successfully.",
    "theme_not_found_error": "Theme '{name}' not found or path is unknown.",
    "confirm_delete_theme_message": "Are you sure you want to delete the theme '{name}'?",
    "theme_deleted_success_message": "Theme '{name}' has been deleted.",
    "theme_delete_failed_error": "Failed to delete theme '{name}': {error}",
    "log_populating_theme_list": "DEBUG: Populating theme list...",
    "log_theme_list_populated_success": "INFO: Theme list populated successfully.",
    "log_upload_theme_started": "INFO: Theme upload process started.",
    "module_name_label": "Module Name",
    "description_label": "Description",
    "save_changes_button": "Save Changes",
    "edit_button": "✏️",
    "tooltip_edit_theme": "Edit this theme file",
    "tooltip_delete_theme": "Delete this theme",
    "preset_frame_title": "Workflow Presets",
    "save_preset_button": "Save Workflow as Preset",
    "load_preset_label": "Load Preset:",
    "save_preset_popup_title": "Save Preset",
    "save_preset_popup_prompt": "Enter a name for this preset:",
    "preset_loaded_log": "INFO: Loading preset '{name}'.",
    "preset_load_error": "Failed to load preset data for '{name}': {error}",
    "preset_save_success": "Preset '{name}' saved successfully via API.",
    "preset_save_error": "Failed to save preset '{name}' via API: {error}",
    "preset_delete_success": "Preset '{name}' deleted successfully via API.",
    "preset_delete_error": "Failed to delete preset '{name}' via API: {error}",
    "preset_not_found_error": "Preset with name '{name}' not found.",
    "exec_loop_count_finished": "Count-based loop for '{node_name}' finished after {iterations} iterations.",
    "delete_preset_button": "Delete Preset",
    "select_preset_to_delete_warning": "Please select a preset to delete first.",
    "exec_stop_request_received": "STOP request received.",
    "manual_approval_title": "Manual Approval Required",
    "manual_approval_message": "The workflow '{workflow_name}' requires your approval.\\n\\nMessage from step: {node_message}",
    "button_approve": "Approve",
    "button_reject": "Reject",
    "save_preset_version_info": "Old version of preset '{name}' has been saved as '{version_file_name}'.",
    "manage_versions_button": "Manage Versions",
    "version_manager_title": "Version Manager for '{preset_name}'",
    "version_list_label": "Historical Versions (newest first):",
    "version_name_column": "Version Name",
    "version_datetime_column": "Date & Time",
    "no_versions_found": "No historical versions found for this preset.",
    "version_name_format": "Version from {timestamp}",
    "log_loading_version": "INFO: Loading version '{version_name}' for preset '{preset_name}'...",
    "log_version_loaded_success": "SUCCESS: Version '{version_name}' of preset '{preset_name}' loaded successfully.",
    "log_version_load_error": "ERROR: Failed to load version '{version_name}' for preset '{preset_name}'. Error: {error}",
    "confirm_delete_version_title": "Confirm Deletion",
    "confirm_delete_version_message": "Are you sure you want to permanently delete version '{version_name}'?",
    "log_version_deleted_success": "SUCCESS: Version '{version_name}' of preset '{preset_name}' has been deleted.",
    "log_version_delete_error": "ERROR: Failed to delete version '{version_name}' for preset '{preset_name}'. Error: {error}",
    "cache_clear_loop_states": "Stored loop states cleared: {count} entries.",
    "template_manager_page_title": "Template Management",
    "trigger_manager_page_title": "Trigger Management",
    "generator_page_title": "Generator Tools",
    "menu_settings": "Settings",
    "menu_open_settings_tab": "Open Settings",
    "no_widgets_available": "No widgets available",
    "menu_triggers_placeholder": "Manage Triggers...",
    "menu_templates_placeholder": "Manage Templates...",
    "action_execution_error": "Error executing action '{action_name}': {error}",
    "action_workflow_tab_only": "This action can only be performed in a Workflow tab.",
    "clear_layout_button": "Clear Layout",
    "confirm_clear_layout_title": "Confirm Clear Layout",
    "confirm_clear_layout_message": "Are you sure you want to clear all widgets from this dashboard?",
    "action_dashboard_tab_only": "This action only applies to Dashboard tabs.",
    "layout_and_session_saved": "Layout and Session saved successfully!",
    "confirm_exit_title": "Exit Application",
    "confirm_exit_save_workflow_message": "Do you want to save your work before exiting?",
    "available_widgets_header": "Available Widgets",
    "confirm_load_version_title": "Load Version?",
    "confirm_load_version_message": "Are you sure you want to load version '{version_name}' of preset '{preset_name}'? Changes on the current canvas will be lost.",
    "no_themes_installed_message": "No themes are installed yet.",
    "log_no_themes_found": "INFO: No custom themes were found.",
    "log_theme_added_to_list": "DEBUG: Theme '{name}' ({id}) added to list.",
    "log_uninstall_theme_attempt": "INFO: Attempting to uninstall theme '{name}' ({id}).",
    "log_theme_not_found_for_uninstall": "ERROR: Theme '{name}' ({id}) not found for uninstall.",
    "log_theme_deleted_success": "SUCCESS: Theme '{name}' deleted successfully.",
    "log_theme_uninstall_cancelled": "INFO: Theme '{name}' deletion cancelled.",
    "theme_upload_cancelled": "WARNING: Theme upload process cancelled.",
    "log_upload_theme_target_path": "DEBUG: Target path for theme '{filename}' is: {path}",
    "log_theme_exists_removing": "WARNING: Theme '{name}' ({id}) already exists, removing old file.",
    "theme_upload_failed_error": "Failed to upload theme '{filename}': {error}",
    "theme_upload_failed_title": "Theme Upload Failed",
    "log_generator_page_refreshed": "DEBUG: Generator page refreshed.",
    "log_opening_folder": "INFO: Opening path in file explorer: {path}",
    "log_failed_to_open_folder": "ERROR: Failed to open path '{path}'. Error: {error}",
    "version_action_load": "Load This Version",
    "version_action_delete": "Delete This Version",
    "version_actions_column": "Actions",
    "version_action_column_placeholder": "Click for Actions...",
    "button_close": "Close",
    "exec_loading_loop_state": "DEBUG: Loading loop state for '{node_name}' (context: '{context_id}'). Starting from iteration: {start_iter}",
    "exec_loop_stopped": "Loop on node '{node_name}' was stopped.",
    "context_menu_start_connection": "Start Connection From Here",
    "context_menu_finish_connection": "Finish Connection Here",
    "tooltip_zoom_in": "Zoom In",
    "tooltip_zoom_out": "Zoom Out",
    "tooltip_zoom_reset": "Reset Zoom",
    "exec_node_timeout_error": "Timeout Exceeded: Node '{node_name}' ran for more than {seconds} seconds and was stopped.",
    "exec_node_retrying_error": "Node '{node_name}' failed. Retrying in {delay} seconds... (Attempt {attempt}/{total_attempts})",
    "simulate_workflow_button": "Run Simulation",
    "generator_guide_title": "Generator Guide",
    "generator_guide_intro": "Use the form on the left to create the boilerplate for your new feature. This panel will provide contextual explanations based on your selections.",
    "generator_guide_kind_title": "\\n--- Feature Kind ---\\n",
    "generator_guide_type_title": "\\n--- Specific Type ---\\n",
    "node_id_label": "Node ID (Unique & Unchangeable):",
    "copy_id_button": "Copy ID",
    "log_node_created": "NODE CREATED: Name='{name}', ID='{id}'",
    "settings_general_title": "General Settings",
    "settings_webhook_title": "Webhook Settings",
    "settings_save_button": "Save All Settings",
    "settings_language_label": "Interface Language:",
    "settings_theme_label": "Application Theme:",
    "settings_webhook_enable_label": "Enable Webhook/API Server",
    "settings_webhook_port_label": "Server Port:",
    "messagebox_success_title": "Success",
    "messagebox_error_title": "An Error Occurred",
    "messagebox_warning_title": "Warning",
    "messagebox_confirm_title": "Confirmation",
    "settings_save_success_msg": "Settings saved successfully. Some changes may require an application restart.",
    "settings_save_error_msg": "Failed to save settings",
    "settings_variables_title": "Variable & Secret Management",
    "settings_variables_col_name": "Variable Name",
    "settings_variables_col_value": "Value",
    "settings_variables_btn_add": "Add",
    "settings_variables_btn_edit": "Edit",
    "settings_variables_btn_delete": "Delete",
    "settings_variables_dialog_add_title": "Add New Variable",
    "settings_variables_dialog_edit_title": "Edit Variable",
    "settings_variables_dialog_name": "Name:",
    "settings_variables_dialog_value": "Value:",
    "settings_variables_dialog_secret_placeholder": "(Leave empty if you don't want to change)",
    "settings_variables_dialog_secret_check": "Mask this value (secret)",
    "settings_variables_warn_name_empty": "Variable name cannot be empty.",
    "settings_variables_warn_name_format": "Variable name can only contain uppercase letters (A-Z), numbers (0-9), and underscores (_).",
    "settings_variables_warn_value_empty": "Value cannot be empty.",
    "settings_variables_warn_select_to_edit": "Please select a variable to edit first.",
    "settings_variables_warn_select_to_delete": "Please select a variable to delete first.",
    "settings_variables_confirm_delete": "Are you sure you want to delete the variable '{var_name}'?",
    "settings_variables_action_copy": "[ Copy ]",
    "settings_variables_warn_select_to_copy": "Please select a variable to copy the placeholder for.",
    "settings_variables_copy_success": "Placeholder '{placeholder_text}' has been copied to clipboard.",
    "generator_option_use_variable": "Provide an example of using Settings Variables",
    "generator_guide_option_variable": "Use Settings Variables: Check this if your module needs to retrieve values from 'Variable & Secret Management' in Settings. It will generate sample code to get a value using a placeholder like {{vars.YOUR_NAME}}.",
    "settings_error_handler_title": "Global Error Handler Settings",
    "settings_error_handler_enable_label": "Enable Global Error Handler",
    "settings_error_handler_preset_label": "Select Error Handler Preset:",
    "menu_help": "Help",
    "menu_about": "About Application",
    "about_title": "About Flowork",
    "trigger_col_next_run": "Next Run",
    "status_calculating": "Calculating...",
    "status_not_scheduled": "Not Scheduled",
    "status_waiting_schedule": "Waiting...",
    "trigger_col_name": "Rule Name",
    "trigger_col_type": "Trigger Type",
    "trigger_col_preset": "Preset to Run",
    "trigger_col_status": "Status",
    "status_enabled": "Enabled",
    "status_disabled": "Disabled",
    "trigger_warn_select_to_edit": "Please select a rule to edit.",
    "trigger_warn_select_to_delete": "Please select a rule to delete.",
    "trigger_confirm_delete": "Are you sure you want to delete the rule '{name}'?",
    "trigger_editor_title_edit": "Edit Trigger Rule",
    "trigger_btn_new": "New Rule...",
    "trigger_btn_edit": "Edit...",
    "trigger_btn_delete": "Delete",
    "trigger_form_name": "Rule Name:",
    "trigger_form_type": "Trigger Type:",
    "trigger_form_preset": "Preset to Run:",
    "trigger_form_enable": "Enable This Rule",
    "button_save": "Save",
    "trigger_err_no_type_selected": "Please select a trigger type first.",
    "metrics_dashboard_title": "Metrics Dashboard",
    "menu_open_metrics_dashboard": "Open Metrics Dashboard",
    "prop_approval_message_label": "Message to display in popup:",
    "diagnostics_tab_title": "System Diagnostics",
    "license_popup_title": "Premium Feature Activation",
    "license_popup_message": "The module '{module_name}' is a premium feature. Please enter your license key to activate.",
    "license_popup_entry_label": "License Key:",
    "license_popup_activate_button": "Activate",
    "generator_optional_features_title": "Optional Features",
    "generator_option_use_state_manager": "Sediakan contoh penggunaan State Manager",
    "menu_activate_license": "Activate License...",
    "settings_notifications_title": "Popup Notification Settings",
    "settings_notifications_enable_label": "Enable Popup Notifications",
    "settings_notifications_duration_label": "Display Duration (seconds):",
    "settings_notifications_position_label": "Popup Position:",
    "settings_license_title": "License Management",
    "settings_license_deactivate_button": "Deactivate License on This Computer",
    "settings_license_deactivate_confirm_title": "Confirm Deactivation",
    "settings_license_deactivate_confirm_message": "Are you sure? This will release the license from this computer, allowing you to use it elsewhere. You will need to reactivate the license to use premium features here.",
    "confirm_save_session_title": "Confirm Save",
    "confirm_save_session_message": "Are you sure you want to save the current workflow, all open tabs, and dashboard layout?",
    "menu_themes": "Themes",
    "menu_manage_themes": "Manage Themes...",
    "tray_menu_show": "Show Flowork",
    "tray_menu_exit": "Exit Flowork",
    "settings_variables_col_status": "Status",
    "settings_variables_btn_disable": "Disable",
    "settings_variables_btn_enable": "Enable",
    "ai_architect_err_no_provider": "Failed to generate workflow: No Master AI Provider is configured in Settings > AI Center Configuration.",
    "ai_architect_err_provider_not_ready": "Failed to generate workflow: Master AI Provider '{provider_name}' is not ready. Message: {message}",
    "gemini_provider_err_not_configured": "Gemini Provider is not configured. Check for a valid GEMINI_API_KEY in Settings.",
    "update_popup_title": "Mandatory Update Available",
    "update_popup_header": "Update to Version {version} Required",
    "update_popup_changelog_label": "Changes in this version:",
    "update_popup_button": "Download Update & Exit",
    "update_popup_button_loading": "Opening browser...",
    "update_popup_exit_message": "The application will now close. Please download the new version.",
    "update_popup_open_browser_prompt": "Open the download page now?",
    "marketplace_upload_btn": "Upload to Community...",
    "marketplace_upload_confirm_title": "Confirm Upload",
    "marketplace_upload_confirm_message": "Are you sure you want to upload '{component_name}' to the community repository? This will make it publicly available.",
    "marketplace_core_component_error": "Core components cannot be uploaded.",
    "marketplace_scan_failed_error": "Pre-upload scan failed. Please fix the issues reported by the System Diagnostics tool before uploading.",
    "marketplace_github_token_missing_title": "GitHub Token Required",
    "marketplace_github_token_missing_message": "To upload, please add a 'GITHUB_UPLOAD_TOKEN' variable in Settings > Variable & Secret Management. This should be a GitHub Personal Access Token with 'repo' permissions.",
    "marketplace_upload_success": "Upload successful! Thank you for your contribution.",
    "marketplace_upload_failed": "Upload failed: {error}",
    "marketplace_page_title": "Addon Manager",
    "menu_open_marketplace": "Open Addon Manager",
    "marketplace_col_name": "Addon Name",
    "marketplace_col_desc": "Description",
    "marketplace_col_tier": "Tier",
    "marketplace_tab_presets": "Presets",
    "marketplace_restart_needed": "Action successful. The application will now hot-reload components.",
    "marketplace_uninstall_confirm": "Are you sure you want to uninstall '{component_name}'? This action cannot be undone.",
    "marketplace_install_dialog_title": "Select Component Zip File",
    "diagnostics_control_panel_title": "Control Panel",
    "diagnostics_select_all_toggle": "Select / Deselect All",
    "diagnostics_run_selected_button": "Run Selected Scanners",
    "diagnostics_run_all_button": "Run All Scanners",
    "diagnostics_save_config_button": "Save Configuration",
    "diagnostics_copy_results_button": "Copy Scan Results",
    "diagnostics_report_panel_title": "Report Panel",
    "diagnostics_filter_level_label": "Show Levels:",
    "cron_ui_schedule_type": "Schedule Type",
    "cron_ui_every_x_minutes": "Every X Minutes",
    "cron_ui_every_hour": "Every Hour",
    "cron_ui_daily": "Daily",
    "cron_ui_weekly": "Weekly",
    "cron_ui_run_every": "Run every",
    "cron_ui_minutes_label": "minutes",
    "cron_ui_run_at_minute": "Run at minute:",
    "cron_ui_run_at_time": "Run at time:",
    "day_mon": "Mon",
    "day_tue": "Tue",
    "day_wed": "Wed",
    "day_thu": "Thu",
    "day_fri": "Fri",
    "day_sat": "Sat",
    "day_sun": "Sun",
    "api_core_component_delete_error": "Core components cannot be deleted.",
    "api_core_component_disable_error": "Core components cannot be disabled.",
    "api_core_component_upload_error": "Core components cannot be uploaded to the community repository.",
    "marketplace_preset_desc": "Workflow Preset File",
    "marketplace_hot_reload_prompt_title": "Reload Required",
    "marketplace_install_hot_reload_prompt_message": "Installation successful. Reload all components now to use the new component?",
    "marketplace_uninstall_hot_reload_prompt_message": "Uninstallation successful. Reload all components now to apply changes?",
    "marketplace_toggle_hot_reload_prompt_message": "State changed successfully. Reload all components now to apply?",
    "pricing_page_title": "View & Upgrade Plan",
    "menu_open_pricing_page": "View Plans & Upgrade",
    "tier_free_title": "Free",
    "tier_free_price": "$0",
    "tier_free_desc": "For students, hobbyists, & anyone getting started.",
    "tier_basic_title": "Basic",
    "tier_basic_price": "~$3 USD / month",
    "tier_basic_desc": "For professionals, freelancers, & serious users.",
    "tier_pro_title": "Pro",
    "tier_pro_price": "~$9 USD / month",
    "tier_pro_desc": "For developers & SMBs with AI needs.",
    "tier_architect_title": "Architect",
    "tier_architect_price": "~$32 USD / month",
    "tier_architect_desc": "For power users & teams building complex solutions.",
    "tier_enterprise_title": "Enterprise",
    "tier_enterprise_price": "Contact Us",
    "tier_enterprise_desc": "For large companies with scaling & security needs.",
    "feature_visual_editor": "Visual Workflow Editor",
    "feature_basic_modules": "Basic Modules & Plugins",
    "feature_manual_install": "Manual Addon Installation",
    "feature_limited_api": "API & Webhooks (Limited)",
    "feature_unlimited_api": "Unlimited API & Webhooks",
    "feature_headless_mode": "Headless Mode (CLI)",
    "feature_theme_customization": "Theme & Layout Customization",
    "feature_time_travel_debugger": "Time-Travel Debugger",
    "feature_preset_versioning": "Preset Version Management",
    "feature_basic_tier_addons": "Access Basic Tier Addons",
    "feature_pro_tier_addons": "Access Pro Tier Addons",
    "feature_architect_tier_addons": "Access Architect Tier Addons",
    "feature_enterprise_tier_addons": "Access All Addons",
    "feature_marketplace_upload": "Upload to Marketplace",
    "feature_ai_copilot": "AI Co-pilot (Analysis & Suggestions)",
    "feature_advanced_triggers": "Advanced Triggers",
    "feature_ai_architect": "AI Architect (Workflow Generator)",
    "feature_core_editor": "Core Workflow Editor",
    "feature_advanced_security": "Advanced Security & Auditing",
    "feature_priority_support": "Priority Support (SLA)",
    "feature_team_collaboration": "Team Collaboration Features",
    "btn_current_plan": "Your Current Plan",
    "btn_included": "Included",
    "btn_upgrade": "Upgrade Now",
    "btn_contact_us": "Contact Us",
    "about_message": "Flowork: The Limitless Visual Automation Platform\n\nThis platform is designed to transform complex ideas into elegant and efficient automated workflows.\n\nFrom daily tasks to intricate business processes, Flowork is your canvas for automation creativity.\n\n-- Core Development Team --\nLead Developer: Awenk Audico\nPlugin Architect: Imam Oechil\nModule Specialist: Irzad\nWidget Master: Teguh FX",
    "api_contract_err_executor_not_requested": "Error: The 'workflow_executor_service' was not requested by this module.",
"api_contract_err_kernel_not_requested": "Error: The 'kernel' service was not requested, cannot display popup.",
"api_contract_err_eventbus_not_requested": "Error: The 'event_bus' service was not requested, cannot publish event '{eventName}'.",
"api_contract_warn_trigger_no_ruleid": "CRITICAL WARNING FOR TRIGGER '{triggerId}': Listener was created without a rule_id. This trigger will be unable to run a workflow.",
"custom_tab_placeholder_text": "This is Your Custom Tab.\\n\\nRight-click to add modules or other widgets.",
"custom_tab_watermark": "WWW.TEETAH.ART",
"notification_ready_title": "Flowork is Ready!",
"notification_ready_message": "Welcome to the future of automation.",
"confirm_clear_cache_title": "Confirm Cache Clearing",
"confirm_clear_cache_message": "This will clear all cache and log files from the project. Continue?",
"ai_architect_page_title": "AI Architect",
"ai_architect_status_ready": "Ready.",
"ai_architect_prompt_placeholder": "Example: Create a workflow that gets data from a web scraper and then shows it in a debug popup.",
"ai_architect_generate_button": "🚀 Generate Workflow",
"ai_architect_status_thinking": "Thinking...",
"ai_architect_warn_empty_prompt_title": "Empty Prompt",
"ai_architect_warn_empty_prompt_msg": "Please describe the workflow you want to create.",
"ai_architect_status_success": "Success! New tab created.",
"ai_architect_status_failed": "Failed.",
"ai_architect_error_title": "AI Architect Error",
"ai_architect_error_failed_to_create": "Failed to create workflow:\n\n{error}",
"marketplace_tab_local": "Locally Installed",
"marketplace_tab_community": "Community",
"marketplace_warn_no_selection_title": "Warning",
"marketplace_warn_no_selection_msg": "Please select a component from the community list to install.",
"marketplace_install_failed_title": "Installation Failed",
"marketplace_install_tier_error": "This component requires a '{tier}' tier license, but your current tier is '{userTier}'.",
"marketplace_install_no_url_error": "The download URL for this component is not available.",
"save_session_button": "Save Session & Layout",
"marketplace_status_installed": "Installed",
"marketplace_status_not_installed": "Not Installed",
"context_menu_add_note": "Add Text Note",
    "canvas_new_label_text": "Double click to edit...",
    "edit_note_title": "Edit Note",
    "edit_note_prompt": "Enter new text for the note:",
    "context_menu_edit_note": "Edit Note...",
    "context_menu_delete_note": "Delete Note",
    "debug_settings_title": "Debug & Reliability Settings",
    "set_breakpoint_checkbox": "Set Breakpoint on This Node",
    "set_breakpoint_tooltip": "Pause the workflow execution right before this node runs.",
    "execution_timeout_label": "Execution Timeout (seconds):",
    "execution_timeout_tooltip": "Stop this node if it runs longer than the specified time (0 = infinite).",
    "retry_settings_title": "Retry Settings",
    "retry_attempts_label": "Retry Attempts:",
    "retry_attempts_tooltip": "How many times to retry on error (0 = no retries).",
    "retry_delay_label": "Delay Between Retries (seconds):",
    "retry_delay_tooltip": "Time to wait before retrying.",
    "checkpoint_settings_title": "Checkpoint Settings",
    "enable_checkpoint_checkbox": "Enable Checkpoint After This Node",
    "checkpoint_tooltip": "Save the workflow state after this node succeeds. If the workflow fails, it can be resumed from here.",
    "setting_ai_config_title": "Default AI Model Configuration",
    "setting_ai_config_help": "Select the default AI model for each task type. Features like AI Architect will use these settings.",
    "setting_ai_for_text": "Text & Analysis:",
    "setting_ai_for_music": "Music:",
    "setting_ai_for_tts": "Text-to-Speech (TTS):",
    "setting_ai_for_image": "Image:",
    "setting_ai_for_video": "Video:",
    "setting_ai_for_other": "Other (Fallback):",
    "ai_copilot_prompt": "\nYou are an expert Flowork workflow efficiency and architecture analyst. Based on the following node execution history, find potential inefficiencies or anti-patterns.\nLook for things like:\n- A node that frequently fails ('status: ERROR').\n- A node that is unusually slow ('execution_time_ms' is very high).\n- Logical anti-patterns, such as a sequence of multiple 'Keyword Router' nodes in a row that could potentially be simplified.\nFor each finding, provide a concise suggestion. Your entire response MUST be a valid JSON list of objects.\nEach object must have these keys: 'node_id' (use the UUID from the history), 'node_name', 'module_id', and 'suggestion'.\nIf you find nothing, return an empty list [].\n\nExample Response:\n[\n    {{\n        \"node_id\": \"a1b2c3d4-e5f6-g7h8-i9j0-k1l2m3n4o5p6\",\n        \"node_name\": \"User Status Router\",\n        \"module_id\": \"keyword_router_module\",\n        \"suggestion\": \"Detected several Router nodes in a sequence. Consider combining their logic into a single 'Function Runner (Nano)' node for a cleaner and more efficient flow.\"\n    }}\n]\n\nVery important: all text inside the 'suggestion' key MUST be in English.\n\nHere is the execution history to analyze:\n---\n{summary_text}\n---\n",
    "cache_clear_ai_cache": "AI suggestion cache cleared: {count} entries.",
    "cache_clear_summary_log_full": "SUCCESS: Cache clear complete. {folders} folders, {files} files, and {ai_caches} AI caches were deleted.",
    "model_converter_config_title": "1. Conversion Setup",
    "model_converter_source_label": "Fine-Tuned Model Folder:",
    "model_converter_output_label": "New .gguf Filename (no extension):",
    "model_converter_quant_label": "Quantization Method:",
    "model_converter_monitor_title": "2. Conversion Monitor",
    "model_converter_start_btn": "Start Conversion Job",
    "agent_command_page_title": "Agent Command Center",
    "agent_available_label": "Available Agents",
    "agent_interaction_label": "Agent Interaction",
    "agent_objective_placeholder": "Enter the agent's objective here...",
    "agent_run_button": "Run Agent",
    "agent_running_button": "Running...",
    "agent_new_button": "New...",
    "agent_edit_button": "Edit...",
    "agent_delete_button": "Delete",
    "agent_confirm_delete_title": "Confirm Delete",
    "agent_confirm_delete_msg": "Are you sure you want to delete the agent '{agent_name}'?",
    "agent_no_agent_selected_msg": "Please select an agent from the list on the left.",
    "agent_no_objective_msg": "Please enter an objective for the agent.",
    "agent_dialog_title_new": "Create New Agent",
    "agent_dialog_title_edit": "Edit Agent",
    "agent_dialog_name_label": "Agent Name:",
    "agent_dialog_desc_label": "Description:",
    "agent_dialog_brain_label": "Brain (GGUF Model):",
    "agent_dialog_tools_label": "Allowed Tools (Modules):",
    "duallist_available": "Available",
    "duallist_selected": "Selected",
    "menu_open_ai_trainer": "Open AI Trainer",
    "menu_open_model_factory": "Open Model Factory",
    "menu_agent_command_center": "Agent Command Center",
    "menu_developer": "Developer",
    "menu_open_core_editor": "Open Core Workflow Editor",
    "agent_no_agent_selected_title": "No Agent Selected",
    "agent_no_objective_title": "No Objective",
    "recorder_widget_tooltip": "Open Tutorial Recorder Controls",
    "recorder_panel_title": "Tutorial Studio",
    "recorder_select_screen": "Record Screen:",
    "recorder_select_mic": "Record Audio From:",
    "recorder_start_button": "Start Recording",
    "recorder_stop_button": "Stop & Save",
    "recorder_pause_button": "Pause",
    "recorder_resume_button": "Resume",
    "recorder_status_recording": "Recording...",
    "recorder_save_success_title": "Recording Saved",
    "recorder_save_success_msg": "Your tutorial has been successfully saved to the 'Videos/Flowork Tutorials' folder.",
    "recorder_settings_title": "Screen Recorder Settings",
    "recorder_save_path_label": "Default Save Location:",
    "recorder_browse_button": "Browse Folder...",
    "recorder_no_audio": "No Audio / Muted",
    "recorder_refresh_mics_tooltip": "Refresh microphone list",
    "recorder_no_mics_found": "No microphones were detected on your system.",
    "recorder_mic_query_error": "Error scanning for microphones. Check your audio drivers.",
    "recorder_use_default_mic": "Record Audio (uses default microphone)",
    "recorder_gain_label": "Amplification (Gain):",
    "permission_denied_capability": "Access Denied. Your current license tier does not grant permission for the '{capability}' capability. Please upgrade your plan.",
    "permission_denied_library": "Access Denied. Your license tier does not permit the use of the '{library}' library, which is required for the '{capability}' capability.",
    "permission_denied_detailed": "Access Denied. The '{capability}' capability requires a '{required_tier}' license, but your current tier is '{user_tier}'.",
    "permission_denied_secure_mode": "Access Denied due to secure mode. Please check license file signature.",
    "permission_denied_upgrade_prompt": "Would you like to view available plans to upgrade?",
    "btn_most_popular": "MOST POPULAR",
    "tier_pemula_title": "THE BEGINNER",
    "tier_pemula_tagline": "Ignite Your Automation Flame",
    "tier_pemula_desc_detail": "The gateway to your work revolution. Turn exhausting manual clicks into smart workflows that run 24/7, tirelessly.",
    "tier_profesional_title": "THE PROFESSIONAL",
    "tier_profesional_tagline": "Break the Limits, Work Smarter",
    "tier_profesional_desc_detail": "Unlock full connectivity to the outside world. Scrape data from the most complex sites and track every execution step like a detective.",
    "tier_arsitek_ai_title": "THE AI ARCHITECT",
    "tier_arsitek_ai_tagline": "This Is Where The Real Magic Begins",
    "tier_arsitek_ai_desc_detail": "Give your automation a brain. You become the director of an AI team ready to create images, music, and analyze data for you.",
    "tier_maestro_title": "THE MAESTRO",
    "tier_maestro_tagline": "Create Your Own Rules of the Game",
    "tier_maestro_desc_detail": "For the visionaries. Design custom modules and compile visual workflows into standalone applications. You are no longer limited by the toolbox; you create it.",
    "tier_titan_title": "THE TITAN",
    "tier_titan_tagline": "Scalability & Security Without Compromise",
    "tier_titan_desc_detail": "For large companies with scaling & security needs.",
    "feature_group_foundation": "Core Automation Foundation",
    "feature_group_connectivity": "Super Connectivity",
    "feature_group_intelligence": "Artificial Intelligence Hub",
    "feature_group_powerhouse": "Powerhouse Features",
    "feature_group_creator": "Creator Tools",
    "feature_group_enterprise": "Enterprise Scale",
    "ai:provider_access": "AI Provider Access (Gemini, etc)",
    "ai:local_models": "Run Local AI Models (GGUF, etc)",
    "module_generator": "Module Generator (Visual)",
    "btn_upgrade_basic": "Become a Professional!",
    "btn_upgrade_pro": "Unleash AI Power!",
    "btn_upgrade_architect": "Become a Maestro!",
    "web_scraping_advanced": "Advanced Web Scraping (Selenium)",
    "video_processing": "Advanced Video Processing",
    "widget_prompt_sender_name": "Prompt Sender",
    "widget_prompt_sender_desc": "A dashboard widget to send a text prompt to a specific receiver module in a workflow.",
    "loop_run_label": "Repeat:",
    "loop_times_label": "times",
    "loop_status_update": "Running iteration {current} of {total}...",
    "loop_finished": "Looping finished.",
    "loop_stopped": "Looping stopped by user.",
    "enable_sleep_checkbox": "Enable Delay Between Iterations",
    "sleep_type_static_radio": "Static Delay (seconds)",
    "static_duration_tooltip": "Duration of the delay in seconds.",
    "sleep_type_random_radio": "Random Delay (seconds)",
    "random_min_label": "Min:",
    "random_min_tooltip": "Minimum delay duration in seconds.",
    "random_max_label": "Max:",
    "random_max_tooltip": "Maximum delay duration in seconds.",
     "prop_loop_control_title": "Loop & Delay Control",
    "enable_delay_checkbox": "Delay Between Loops",
    "delay_type_static": "Static",
    "delay_type_random": "Random",
    "log_delay_static": "Pausing for {delay} seconds...",
    "log_delay_random": "Pausing for a random duration of {delay:.2f} seconds...",
     "workflow_management_title": "Workflow Management",
    "execution_control_title": "Execution Control",
    "save_workflow_button": "💾 Save",
    "load_workflow_button": "📂 Load",
    "clear_canvas_button": "🧹 Clear",
    "btn_add_new_tab": "➕ Tab Baru",
    "btn_run_workflow": "Jalankan Alur Kerja",
    "btn_stop_workflow": "Hentikan Alur Kerja",
    "btn_pause": "Jeda",
    "btn_resume": "Lanjutkan",
    "btn_stopping": "Menghentikan...",
    "tooltip_toggle_sidebar": "Show/Hide Toolbox Panel",
    "tooltip_logic_toolbox": "Logic Modules",
    "tooltip_plugin_toolbox": "Action Plugins",
    "tooltip_widget_toolbox": "Dashboard Widgets",
    "tooltip_log_viewer": "Execution Log",
    "tooltip_prompt_sender": "Prompt Sender",
    "pin_dock_tooltip": "Pin this panel to keep it open",
    "unpin_dock_tooltip": "Unpin this panel to enable auto-hide",
    "fatal_error_title": "Fatal Error",
    "tab_manager_load_error": "TabManagerService could not be loaded. The application cannot continue.",
    "service_unavailable_error": "Service Unavailable: {service_name}",
    "select_license_file_title": "Select Your license.seal File",
    "license_seal_filetype": "License Seal File",
    "status_bar_ready": "Ready.",
    "status_bar_recording": "Recording screen and audio...",
    "status_bar_saving": "Saving video, please wait...",
    "recorder_start_error": "Could not start recording. Check logs for details.",
    "recorder_save_error": "Failed to save the recording. Check logs for details.",
    "ai_copilot_working_status": "AI Co-pilot is working...",
    "action_failed_title": "Action Failed",
    "license_invalid_format_error": "Invalid license file format: missing 'data' block.",
    "license_process_error": "Could not process the license file. Error: {error}",
    "license_activated_title": "License Activated",
    "license_restart_required_msg": "Please restart the application for the changes to take effect.",
    "license_activation_failed_title": "Activation Failed",
    "badge_tooltip_loop": "Loop enabled: Runs {count} times.",
    "badge_tooltip_retry": "Retry enabled: Tries up to {count} times on failure.",
    "debugger_title": "Time-Travel Debugger",
    "debugger_close_button": "Close Debugger",
    "debugger_payload_title": "Payload at Selected Step",
    "action_modules_title": "Action Modules"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\locales\id.json
# JUMLAH BARIS : 585
#######################################################################

```json
{
    "app_title": "FLOWORK Synapse : Weaving Intelligence",
    "menu_file": "File",
    "menu_save_workflow": "Simpan Alur Kerja",
    "menu_load_workflow": "Muat Alur Kerja",
    "menu_exit": "Keluar",
    "workflow_editor_tab_title": "Dashboard",
    "settings_tab_title": "Pengaturan",
    "untitled_tab_title": "Tanpa Judul {count}",
    "context_menu_rename_tab": "Ubah Nama Tab",
    "menu_close_tab": "Tutup Tab",
    "rename_tab_popup_title": "Ubah Nama Tab",
    "rename_tab_popup_label": "Masukkan nama baru untuk tab:",
    "logic_modules_title": "Modul Logika",
    "run_workflow_button": "Jalankan Alur Kerja",
    "clear_cache_button": "Bersihkan Cache",
    "module_name_column": "Nama Modul",
    "action_plugins_title": "Plugin Aksi",
    "plugin_name_column": "Nama Plugin",
    "properties_title": "Properti Node",
    "execution_log_title": "Log Eksekusi",
    "copy_log_button": "Salin Log",
    "clear_log_button": "Bersihkan Log",
    "search_log_placeholder": "Cari Log...",
    "log_level_all": "Semua",
    "log_level_info": "Info",
    "log_level_warn": "Peringatan",
    "log_level_error": "Kesalahan",
    "log_level_success": "Sukses",
    "log_level_debug": "Debug",
    "log_level_cmd": "Perintah",
    "log_level_detail": "Detail",
    "log_copied_to_clipboard": "Log: Konten log disalin ke clipboard.",
    "log_cleared": "Log: Log dibersihkan.",
    "exec_no_nodes": "PERINGATAN: Tidak ada node di kanvas untuk dieksekusi.",
    "exec_no_start_node": "KESALAHAN: Tidak ada node awal yang ditemukan. Periksa alur kerja untuk loop tak terbatas.",
    "exec_found_start_nodes": "INFO: Ditemukan {count} node awal. Memulai eksekusi...",
    "exec_executing_node": "INFO: Mengeksekusi node '{node_name}' (Modul: {module_id})",
    "exec_payload_out": "DETAIL: Menghasilkan payload:",
    "exec_going_to_next": "INFO: Melanjutkan ke node berikutnya: {node_id}",
    "log_clearing_canvas": "INFO: Membersihkan kanvas...",
    "flowork_workflow_filetype": "Alur Kerja Flowork",
    "workflow_saved_success": "Alur kerja berhasil disimpan.",
    "workflow_loaded_success": "Alur kerja berhasil dimuat.",
    "error_title": "Kesalahan",
    "node_deleted_success": "Node '{node_id}' berhasil dihapus.",
    "confirm_cache_clear_title": "Konfirmasi Pembersihan Cache",
    "confirm_cache_clear_message": "Ini akan menghapus semua file cache Python (__pycache__) dan file log (*.log) dari folder proyek. Lanjutkan?",
    "info_done": "Selesai",
    "cache_clear_summary_log": "SUKSES: Pembersihan cache selesai. {folders} folder cache dan {files} file log dihapus.",
    "context_menu_delete_node": "Hapus Node",
    "context_menu_delete_connection": "Hapus Koneksi",
    "context_menu_properties": "Properti",
    "context_menu_duplicate_node": "Duplikasi Node",
    "node_duplicated_success": "Node '{node_id}' berhasil diduplikasi.",
    "button_cancel": "Batal",
    "theme_management_title": "Manajemen Tema",
    "upload_theme_button": "Unggah Tema",
    "uninstall_button": "❌",
    "theme_list_item_format": "• {name} ({id})",
    "info_title": "Info",
    "success_title": "Sukses",
    "failed_title": "Gagal",
    "warning_title": "Peringatan",
    "confirm_delete_title": "Konfirmasi Hapus",
    "confirm_delete_preset_message": "Apakah Anda yakin ingin menghapus preset '{name}'?",
    "select_theme_file_title": "Pilih File Tema (.json)",
    "json_files_label": "File JSON",
    "invalid_theme_format_error": "File JSON bukan format tema yang valid (membutuhkan 'name' dan 'colors').",
    "theme_upload_success": "Tema '{name}' berhasil diunggah.",
    "theme_not_found_error": "Tema '{name}' tidak ditemukan atau jalur tidak diketahui.",
    "confirm_delete_theme_message": "Apakah Anda yakin ingin menghapus tema '{name}'?",
    "theme_deleted_success_message": "Tema '{name}' telah dihapus.",
    "theme_delete_failed_error": "Gagal menghapus tema '{name}': {error}",
    "log_populating_theme_list": "DEBUG: Mengisi daftar tema...",
    "log_theme_list_populated_success": "INFO: Daftar tema berhasil diisi.",
    "log_upload_theme_started": "INFO: Proses unggah tema dimulai.",
    "module_name_label": "Nama Modul",
    "description_label": "Deskripsi",
    "save_changes_button": "Simpan Perubahan",
    "edit_button": "✏️",
    "tooltip_edit_theme": "Edit file tema ini",
    "tooltip_delete_theme": "Hapus tema ini",
    "preset_frame_title": "Preset Alur Kerja",
    "save_preset_button": "Simpan Alur Kerja sebagai Preset",
    "load_preset_label": "Muat Preset:",
    "save_preset_popup_title": "Simpan Preset",
    "save_preset_popup_prompt": "Masukkan nama untuk preset ini:",
    "preset_loaded_log": "INFO: Memuat preset '{name}'.",
    "preset_load_error": "Gagal memuat data preset '{name}': {error}",
    "preset_save_success": "Preset '{name}' berhasil disimpan melalui API.",
    "preset_save_error": "Gagal menyimpan preset '{name}' melalui API: {error}",
    "preset_delete_success": "Preset '{name}' berhasil dihapus melalui API.",
    "preset_delete_error": "Gagal menghapus preset '{name}' melalui API: {error}",
    "preset_not_found_error": "Preset dengan nama '{name}' tidak ditemukan.",
    "exec_loop_count_finished": "Loop berdasarkan jumlah untuk '{node_name}' selesai setelah {iterations} iterasi.",
    "delete_preset_button": "Hapus Preset",
    "select_preset_to_delete_warning": "Pilih preset yang ingin dihapus terlebih dahulu.",
    "exec_stop_request_received": "Permintaan HENTI diterima.",
    "manual_approval_title": "Persetujuan Manual Dibutuhkan",
    "manual_approval_message": "Alur kerja '{workflow_name}' membutuhkan persetujuan Anda.\\n\\nPesan dari langkah: {node_message}",
    "button_approve": "Setuju",
    "button_reject": "Tolak",
    "save_preset_version_info": "Versi lama dari preset '{name}' telah disimpan sebagai '{version_file_name}'.",
    "manage_versions_button": "Kelola Versi",
    "version_manager_title": "Manajer Versi untuk '{preset_name}'",
    "version_list_label": "Versi Historis (terbaru dulu):",
    "version_name_column": "Nama Versi",
    "version_datetime_column": "Tanggal & Waktu",
    "no_versions_found": "Tidak ada versi historis yang ditemukan untuk preset ini.",
    "version_name_format": "Versi dari {timestamp}",
    "log_loading_version": "INFO: Memuat versi '{version_name}' untuk preset '{preset_name}'...",
    "log_version_loaded_success": "SUKSES: Versi '{version_name}' dari preset '{preset_name}' berhasil dimuat.",
    "log_version_load_error": "ERROR: Gagal memuat versi '{version_name}' untuk preset '{preset_name}'. Error: {error}",
    "confirm_delete_version_title": "Konfirmasi Hapus",
    "confirm_delete_version_message": "Apakah Anda yakin ingin menghapus permanen versi '{version_name}'?",
    "log_version_deleted_success": "SUKSES: Versi '{version_name}' dari preset '{preset_name}' telah dihapus.",
    "log_version_delete_error": "ERROR: Failed to delete version '{version_name}' for preset '{preset_name}'. Error: {error}",
    "cache_clear_loop_states": "Status loop yang tersimpan dihapus: {count} entri.",
    "template_manager_page_title": "Manajemen Tema",
    "trigger_manager_page_title": "Manajemen Pemicu",
    "generator_page_title": "Alat Generator",
    "menu_settings": "Pengaturan",
    "menu_open_settings_tab": "Buka Pengaturan",
    "no_widgets_available": "Tidak ada widget tersedia",
    "menu_triggers_placeholder": "Kelola Pemicu...",
    "menu_templates_placeholder": "Kelola Template...",
    "action_execution_error": "Error saat menjalankan aksi '{action_name}': {error}",
    "action_workflow_tab_only": "Aksi ini hanya bisa dilakukan di dalam tab Alur Kerja.",
    "clear_layout_button": "Bersihkan Layout",
    "confirm_clear_layout_title": "Konfirmasi Bersihkan Layout",
    "confirm_clear_layout_message": "Anda yakin ingin membersihkan semua widget dari dashboard ini?",
    "action_dashboard_tab_only": "Aksi ini hanya berlaku untuk tab Dashboard.",
    "layout_and_session_saved": "Layout dan Sesi berhasil disimpan!",
    "confirm_exit_title": "Keluar dari Aplikasi",
    "confirm_exit_save_workflow_message": "Apakah Anda ingin menyimpan pekerjaan Anda sebelum keluar?",
    "available_widgets_header": "Widget Tersedia",
    "confirm_load_version_title": "Muat Versi?",
    "confirm_load_version_message": "Apakah Anda yakin ingin memuat versi '{version_name}' dari preset '{preset_name}'? Perubahan di kanvas saat ini akan hilang.",
    "no_themes_installed_message": "Belum ada tema yang terinstal.",
    "log_no_themes_found": "INFO: Tidak ada tema kustom yang ditemukan.",
    "log_theme_added_to_list": "DEBUG: Tema '{name}' ({id}) ditambahkan ke daftar.",
    "log_uninstall_theme_attempt": "INFO: Mencoba menghapus tema '{name}' ({id}).",
    "log_theme_not_found_for_uninstall": "ERROR: Tema '{name}' ({id}) tidak ditemukan untuk di-uninstall.",
    "log_theme_deleted_success": "SUKSES: Tema '{name}' berhasil dihapus.",
    "log_theme_uninstall_cancelled": "INFO: Penghapusan tema '{name}' dibatalkan.",
    "theme_upload_cancelled": "PERINGATAN: Proses unggah tema dibatalkan.",
    "log_upload_theme_target_path": "DEBUG: Jalur target untuk tema '{filename}' adalah: {path}",
    "log_theme_exists_removing": "PERINGATAN: Tema '{name}' ({id}) sudah ada, menghapus file lama.",
    "theme_upload_failed_error": "Gagal mengunggah tema '{filename}': {error}",
    "theme_upload_failed_title": "Unggah Tema Gagal",
    "log_generator_page_refreshed": "DEBUG: Halaman Generator direfresh.",
    "log_opening_folder": "INFO: Membuka path di file explorer: {path}",
    "log_failed_to_open_folder": "ERROR: Gagal membuka path '{path}'. Error: {error}",
    "version_action_load": "Muat Versi Ini",
    "version_action_delete": "Hapus Versi Ini",
    "version_actions_column": "Aksi",
    "version_action_column_placeholder": "Klik untuk Aksi...",
    "button_close": "Tutup",
    "exec_loading_loop_state": "DEBUG: Memuat status loop untuk '{node_name}' (konteks: '{context_id}'). Dimulai dari iterasi: {start_iter}",
    "exec_loop_stopped": "Loop pada node '{node_name}' dihentikan.",
    "context_menu_start_connection": "Mulai Koneksi Dari Sini",
    "context_menu_finish_connection": "Selesaikan Koneksi Di Sini",
    "tooltip_zoom_in": "Perbesar",
    "tooltip_zoom_out": "Perkecil",
    "tooltip_zoom_reset": "Reset Zoom",
    "exec_node_timeout_error": "Batas Waktu Terlampaui: Node '{node_name}' berjalan lebih dari {seconds} detik dan dihentikan.",
    "exec_node_retrying_error": "Node '{node_name}' gagal. Mencoba ulang dalam {delay} detik... (Percobaan {attempt}/{total_attempts})",
    "simulate_workflow_button": "Jalankan Simulasi",
    "generator_guide_title": "Panduan Generator",
    "generator_guide_intro": "Gunakan form di sebelah kiri untuk membuat kerangka dasar fitur baru Anda. Panel ini akan memberikan penjelasan kontekstual berdasarkan pilihan Anda.",
    "generator_guide_kind_title": "\\n--- Jenis Fitur ---\\n",
    "generator_guide_type_title": "\\n--- Tipe Spesifik ---\\n",
    "node_id_label": "ID Node (Unik & Tidak Bisa Diubah):",
    "copy_id_button": "Salin ID",
    "log_node_created": "NODE DIBUAT: Nama='{name}', ID='{id}'",
    "settings_general_title": "Pengaturan Umum",
    "settings_webhook_title": "Pengaturan Webhook",
    "settings_save_button": "Simpan Semua Pengaturan",
    "settings_language_label": "Bahasa Antarmuka:",
    "settings_theme_label": "Tema Aplikasi:",
    "settings_webhook_enable_label": "Aktifkan Server Webhook/API",
    "settings_webhook_port_label": "Port Server:",
    "messagebox_success_title": "Sukses",
    "messagebox_error_title": "Terjadi Kesalahan",
    "messagebox_warning_title": "Peringatan",
    "messagebox_confirm_title": "Konfirmasi",
    "settings_save_success_msg": "Pengaturan berhasil disimpan. Beberapa perubahan mungkin memerlukan restart aplikasi.",
    "settings_save_error_msg": "Gagal menyimpan pengaturan",
    "settings_variables_title": "Manajemen Variabel & Secret",
    "settings_variables_col_name": "Nama Variabel",
    "settings_variables_col_value": "Nilai",
    "settings_variables_btn_add": "Tambah",
    "settings_variables_btn_edit": "Edit",
    "settings_variables_btn_delete": "Hapus",
    "settings_variables_dialog_add_title": "Tambah Variabel Baru",
    "settings_variables_dialog_edit_title": "Edit Variabel",
    "settings_variables_dialog_name": "Nama:",
    "settings_variables_dialog_value": "Nilai:",
    "settings_variables_dialog_secret_placeholder": "(Biarkan kosong jika tidak ingin mengubah)",
    "settings_variables_dialog_secret_check": "Rahasiakan nilai ini (secret)",
    "settings_variables_warn_name_empty": "Nama variabel tidak boleh kosong.",
    "settings_variables_warn_name_format": "Nama variabel hanya boleh berisi huruf besar (A-Z), angka (0-9), dan garis bawah (_).",
    "settings_variables_warn_value_empty": "Nilai tidak boleh kosong.",
    "settings_variables_warn_select_to_edit": "Pilih variabel yang ingin diedit terlebih dahulu.",
    "settings_variables_warn_select_to_delete": "Pilih variabel yang ingin dihapus terlebih dahulu.",
    "settings_variables_confirm_delete": "Apakah Anda yakin ingin menghapus variabel '{var_name}'?",
    "settings_variables_action_copy": "[ Salin ]",
    "settings_variables_warn_select_to_copy": "Pilih variabel yang ingin disalin placeholdernya.",
    "settings_variables_copy_success": "Placeholder '{placeholder_text}' telah disalin ke clipboard.",
    "generator_option_use_variable": "Sediakan contoh penggunaan Variabel Pengaturan",
    "generator_guide_option_variable": "Gunakan Variabel Pengaturan: Centang ini jika modul Anda perlu mengambil nilai dari 'Manajemen Variabel & Secret' di Pengaturan. Ini akan menghasilkan contoh kode untuk mengambil nilai menggunakan placeholder seperti {{vars.NAMA_ANDA}}.",
    "settings_error_handler_title": "Pengaturan Error Handler Global",
    "settings_error_handler_enable_label": "Aktifkan Penangan Error Global",
    "settings_error_handler_preset_label": "Pilih Preset Penangan Error:",
    "menu_help": "Bantuan",
    "menu_about": "Tentang Aplikasi",
    "about_title": "Tentang Flowork",
    "trigger_col_next_run": "Jadwal Berikutnya",
    "status_calculating": "Menghitung...",
    "status_not_scheduled": "Tidak Terjadwal",
    "status_waiting_schedule": "Menunggu...",
    "trigger_col_name": "Nama Aturan",
    "trigger_col_type": "Jenis Pemicu",
    "trigger_col_preset": "Preset Dijalankan",
    "trigger_col_status": "Status",
    "status_enabled": "Aktif",
    "status_disabled": "Nonaktif",
    "trigger_warn_select_to_edit": "Pilih sebuah aturan untuk diedit.",
    "trigger_warn_select_to_delete": "Pilih sebuah aturan untuk dihapus.",
    "trigger_confirm_delete": "Anda yakin ingin menghapus aturan '{name}'?",
    "trigger_editor_title_edit": "Edit Aturan Pemicu",
    "trigger_btn_new": "Aturan Baru...",
    "trigger_btn_edit": "Edit...",
    "trigger_btn_delete": "Hapus",
    "trigger_form_name": "Nama Aturan:",
    "trigger_form_type": "Jenis Pemicu:",
    "trigger_form_preset": "Preset yang Akan Dijalankan:",
    "trigger_form_enable": "Aktifkan Aturan Ini",
    "button_save": "Simpan",
    "trigger_err_no_type_selected": "Pilih jenis pemicu terlebih dahulu.",
    "metrics_dashboard_title": "Dashboard Metrik",
    "menu_open_metrics_dashboard": "Buka Dashboard Metrik",
    "prop_approval_message_label": "Pesan untuk ditampilkan di popup:",
    "diagnostics_tab_title": "Diagnostik Sistem",
    "license_popup_title": "Aktivasi Fitur Premium",
    "license_popup_message": "Modul '{module_name}' adalah fitur premium. Silakan masukkan kunci lisensi Anda untuk mengaktifkan.",
    "license_popup_entry_label": "Kunci Lisensi:",
    "license_popup_activate_button": "Aktifkan",
    "generator_optional_features_title": "Fitur Opsional",
    "generator_option_use_state_manager": "Sediakan contoh penggunaan State Manager",
    "menu_activate_license": "Aktivasi Lisensi...",
    "settings_notifications_title": "Pengaturan Notifikasi Popup",
    "settings_notifications_enable_label": "Aktifkan Notifikasi Popup",
    "settings_notifications_duration_label": "Durasi Tampil (detik):",
    "settings_notifications_position_label": "Posisi Popup:",
    "settings_license_title": "Manajemen Lisensi",
    "settings_license_deactivate_button": "Nonaktifkan Lisensi di Komputer Ini",
    "settings_license_deactivate_confirm_title": "Konfirmasi Deaktivasi",
    "settings_license_deactivate_confirm_message": "Apakah Anda yakin? Ini akan melepaskan lisensi dari komputer ini, memungkinkan Anda untuk menggunakannya di tempat lain. Anda perlu mengaktifkan kembali lisensi untuk menggunakan fitur premium di sini.",
    "confirm_save_session_title": "Konfirmasi Simpan",
    "confirm_save_session_message": "Apakah Anda yakin ingin menyimpan alur kerja saat ini, semua tab yang terbuka, dan tata letak dasbor?",
    "menu_themes": "Tema",
    "menu_manage_themes": "Kelola Tema...",
    "tray_menu_show": "Tampilkan Flowork",
    "tray_menu_exit": "Keluar dari Flowork",
    "settings_variables_col_status": "Status",
    "settings_variables_btn_disable": "Nonaktifkan",
    "settings_variables_btn_enable": "Aktifkan",
    "ai_architect_err_no_provider": "Gagal membuat alur kerja: Tidak ada Master AI Provider yang dikonfigurasi di Pengaturan > Konfigurasi AI Center.",
    "ai_architect_err_provider_not_ready": "Gagal membuat alur kerja: Master AI Provider '{provider_name}' tidak siap. Pesan: {message}",
    "gemini_provider_err_not_configured": "Provider Gemini tidak terkonfigurasi. Periksa apakah GEMINI_API_KEY sudah valid di Pengaturan.",
    "update_popup_title": "Update Wajib Tersedia",
    "update_popup_header": "Update ke Versi {version} Diperlukan",
    "update_popup_changelog_label": "Perubahan di versi ini:",
    "update_popup_button": "Download Update & Keluar",
    "update_popup_button_loading": "Membuka browser...",
    "update_popup_exit_message": "Aplikasi akan ditutup. Silakan unduh versi baru.",
    "update_popup_open_browser_prompt": "Buka halaman unduhan sekarang?",
    "marketplace_upload_btn": "Unggah ke Komunitas...",
    "marketplace_upload_confirm_title": "Konfirmasi Unggahan",
    "marketplace_upload_confirm_message": "Anda yakin ingin mengunggah '{component_name}' ke repositori komunitas? Ini akan membuatnya tersedia untuk publik.",
    "marketplace_core_component_error": "Komponen inti tidak dapat diunggah.",
    "marketplace_scan_failed_error": "Pemindaian pra-unggah gagal. Harap perbaiki masalah yang dilaporkan oleh alat Diagnostik Sistem sebelum mengunggah.",
    "marketplace_github_token_missing_title": "Token GitHub Dibutuhkan",
    "marketplace_github_token_missing_message": "Untuk mengunggah, silakan tambahkan variabel 'GITHUB_UPLOAD_TOKEN' di Pengaturan > Manajemen Variabel & Secret. Ini harus berupa Token Akses Pribadi GitHub dengan izin 'repo'.",
    "marketplace_upload_success": "Unggahan berhasil! Terima kasih atas kontribusi Anda.",
    "marketplace_upload_failed": "Unggahan gagal: {error}",
    "marketplace_page_title": "Manajer Addon",
    "menu_open_marketplace": "Buka Manajer Addon",
    "marketplace_col_name": "Nama Addon",
    "marketplace_col_desc": "Deskripsi",
    "marketplace_col_tier": "Tier",
    "marketplace_tab_presets": "Preset",
    "marketplace_restart_needed": "Aksi berhasil. Aplikasi akan melakukan hot-reload komponen sekarang.",
    "marketplace_uninstall_confirm": "Anda yakin ingin mencopot '{component_name}'? Aksi ini tidak bisa dibatalkan.",
    "marketplace_install_dialog_title": "Pilih File Zip Komponen",
    "diagnostics_control_panel_title": "Panel Kontrol",
    "diagnostics_select_all_toggle": "Pilih Semua / Hapus Pilihan",
    "diagnostics_run_selected_button": "Jalankan Scanner Terpilih",
    "diagnostics_run_all_button": "Jalankan Semua Scanner",
    "diagnostics_save_config_button": "Simpan Konfigurasi",
    "diagnostics_copy_results_button": "Salin Hasil Scan",
    "diagnostics_report_panel_title": "Panel Laporan",
    "diagnostics_filter_level_label": "Tampilkan Level:",
    "cron_ui_schedule_type": "Tipe Jadwal",
    "cron_ui_every_x_minutes": "Setiap X Menit",
    "cron_ui_every_hour": "Setiap Jam",
    "cron_ui_daily": "Setiap Hari",
    "cron_ui_weekly": "Setiap Minggu",
    "cron_ui_run_every": "Jalankan setiap",
    "cron_ui_minutes_label": "menit",
    "cron_ui_run_at_minute": "Jalankan pada menit ke-",
    "cron_ui_run_at_time": "Jalankan pada pukul",
    "day_mon": "Sen",
    "day_tue": "Sel",
    "day_wed": "Rab",
    "day_thu": "Kam",
    "day_fri": "Jum",
    "day_sat": "Sab",
    "day_sun": "Min",
    "api_core_component_delete_error": "Komponen inti tidak dapat dihapus.",
    "api_core_component_disable_error": "Komponen inti tidak dapat dinonaktifkan.",
    "api_core_component_upload_error": "Komponen inti tidak dapat diunggah ke repositori komunitas.",
    "marketplace_preset_desc": "File Preset Alur Kerja",
    "marketplace_hot_reload_prompt_title": "Perlu Muat Ulang",
    "marketplace_install_hot_reload_prompt_message": "Instalasi berhasil. Muat ulang semua komponen sekarang untuk menggunakan komponen baru?",
    "marketplace_uninstall_hot_reload_prompt_message": "Uninstalasi berhasil. Muat ulang semua komponen sekarang untuk menerapkan perubahan?",
    "marketplace_toggle_hot_reload_prompt_message": "Status berhasil diubah. Muat ulang semua komponen sekarang untuk menerapkan?",
    "pricing_page_title": "Lihat & Upgrade Paket",
    "menu_open_pricing_page": "Lihat Paket & Upgrade",
    "tier_free_title": "Free",
    "tier_free_price": "Rp 0,-",
    "tier_free_desc": "Untuk pelajar, hobi, & siapapun yang ingin mencoba.",
    "tier_basic_title": "Basic",
    "tier_basic_price": "Rp 49.000,- / bulan",
    "tier_basic_desc": "Untuk profesional, freelancer, & pengguna serius.",
    "tier_pro_title": "Pro",
    "tier_pro_price": "Rp 149.000,- / bulan",
    "tier_pro_desc": "Untuk developer & UKM dengan kebutuhan AI.",
    "tier_architect_title": "Architect",
    "tier_architect_price": "Rp 499.000,- / bulan",
    "tier_architect_desc": "Untuk power user & tim yang membangun solusi kompleks.",
    "tier_enterprise_title": "Enterprise",
    "tier_enterprise_price": "Hubungi Kami",
    "tier_enterprise_desc": "Untuk perusahaan dengan kebutuhan skala besar & keamanan.",
    "feature_visual_editor": "Editor Alur Kerja Visual",
    "feature_basic_modules": "Modul & Plugin Dasar",
    "feature_manual_install": "Instalasi Addon Manual",
    "feature_limited_api": "API & Webhook (Terbatas)",
    "feature_unlimited_api": "API & Webhook (Tanpa Batas)",
    "feature_headless_mode": "Mode Headless (CLI)",
    "feature_theme_customization": "Kustomisasi Tema & Layout",
    "feature_time_travel_debugger": "Time-Travel Debugger",
    "feature_preset_versioning": "Manajemen Versi Preset",
    "feature_basic_tier_addons": "Akses Addon Tier Basic",
    "feature_pro_tier_addons": "Akses Addon Tier Pro",
    "feature_architect_tier_addons": "Akses Addon Tier Architect",
    "feature_enterprise_tier_addons": "Akses Semua Addon",
    "feature_marketplace_upload": "Upload ke Marketplace",
    "feature_ai_copilot": "AI Co-pilot (Analisa & Saran)",
    "feature_advanced_triggers": "Pemicu (Triggers) Lanjutan",
    "feature_ai_architect": "AI Architect (Pembuat Workflow)",
    "feature_core_editor": "Core Workflow Editor",
    "feature_advanced_security": "Keamanan & Audit Lanjutan",
    "feature_priority_support": "Dukungan Prioritas (SLA)",
    "feature_team_collaboration": "Fitur Kolaborasi Tim",
    "btn_current_plan": "Paket Anda Saat Ini",
    "btn_included": "Sudah Termasuk",
    "btn_upgrade": "Upgrade Sekarang",
    "btn_contact_us": "Hubungi Kami",
    "about_message": "Flowork: Platform Otomasi Visual Tanpa Batas\n\nPlatform ini dirancang untuk mengubah ide-ide kompleks menjadi alur kerja otomatis yang elegan dan efisien.\n\nDari tugas harian hingga proses bisnis yang rumit, Flowork adalah kanvas untuk kreativitas otomasi Anda.\n\n-- Tim Pengembang Inti --\nDeveloper Utama: Awenk Audico\nArsitek Plugin: Imam Oechil\nSpesialis Modul: Irzad\nMaster Widget: Teguh FX",
    "api_contract_err_executor_not_requested": "Kesalahan: Layanan 'workflow_executor_service' tidak diminta oleh modul ini.",
"api_contract_err_kernel_not_requested": "Kesalahan: Layanan 'kernel' tidak diminta, tidak dapat menampilkan popup.",
"api_contract_err_eventbus_not_requested": "Kesalahan: Layanan 'event_bus' tidak diminta, tidak dapat menerbitkan event '{eventName}'.",
"api_contract_warn_trigger_no_ruleid": "PERINGATAN KRITIS UNTUK PEMICU '{triggerId}': Listener dibuat tanpa rule_id. Pemicu ini tidak akan bisa menjalankan workflow.",
"custom_tab_placeholder_text": "Ini adalah Tab Kustom Anda.\\n\\nKlik kanan untuk menambahkan modul atau widget lainnya.",
"custom_tab_watermark": "WWW.TEETAH.ART",
"notification_ready_title": "Flowork Siap!",
"notification_ready_message": "Selamat datang di masa depan otomasi.",
"confirm_clear_cache_title": "Konfirmasi Bersihkan Cache",
"confirm_clear_cache_message": "Ini akan membersihkan semua file cache dan log dari proyek. Lanjutkan?",
"ai_architect_page_title": "AI Architect",
"ai_architect_status_ready": "Siap.",
"ai_architect_prompt_placeholder": "SAYA MAU BUAT ALUR KERJA YANG MENGAMBIL DAFTAR FILEM TRENDING DARI https://www.themoviedb.org/ LALU UNTUK SETIAP FILEM AMBIL DETAILNYA, DAN YANG TERAKHIR SIMPAN SEMUA JUDUL DAN RATINGNYA KEDALAM SATU FILE CSV ",
"ai_architect_generate_button": "🚀 Buat Alur Kerja",
"ai_architect_status_thinking": "Berpikir...",
"ai_architect_warn_empty_prompt_title": "Prompt Kosong",
"ai_architect_warn_empty_prompt_msg": "Tolong tuliskan alur kerja seperti apa yang kamu inginkan.",
"ai_architect_status_success": "Sukses! Tab baru dibuat.",
"ai_architect_status_failed": "Gagal.",
"ai_architect_error_title": "AI Architect Error",
"ai_architect_error_failed_to_create": "Gagal membuat alur kerja:\n\n{error}",
"marketplace_tab_local": "Lokal Terinstall",
"marketplace_tab_community": "Komunitas",
"marketplace_warn_no_selection_title": "Peringatan",
"marketplace_warn_no_selection_msg": "Pilih komponen dari daftar komunitas untuk diinstal.",
"marketplace_install_failed_title": "Instalasi Gagal",
"marketplace_install_tier_error": "Komponen ini membutuhkan lisensi tier '{tier}', sedangkan tier Anda saat ini '{userTier}'.",
"marketplace_install_no_url_error": "URL download untuk komponen ini tidak tersedia.",
"save_session_button": "Simpan Sesi & Layout",
"marketplace_status_installed": "Terinstall",
"marketplace_status_not_installed": "Belum Terinstall",
"context_menu_add_note": "Tambah Catatan Teks",
    "canvas_new_label_text": "Klik dua kali untuk edit...",
    "edit_note_title": "Edit Catatan",
    "edit_note_prompt": "Masukkan teks baru untuk catatan:",
    "context_menu_edit_note": "Edit Catatan...",
    "context_menu_delete_note": "Hapus Catatan",
    "debug_settings_title": "Pengaturan Debug & Keandalan",
    "set_breakpoint_checkbox": "Set Breakpoint di Node Ini",
    "set_breakpoint_tooltip": "Jeda eksekusi alur kerja tepat sebelum node ini berjalan.",
    "execution_timeout_label": "Batas Waktu Eksekusi (detik):",
    "execution_timeout_tooltip": "Hentikan node ini jika berjalan lebih lama dari waktu yang ditentukan (0 = tak terbatas).",
    "retry_settings_title": "Pengaturan Coba Ulang (Retry)",
    "retry_attempts_label": "Jumlah Percobaan:",
    "retry_attempts_tooltip": "Berapa kali mencoba ulang jika terjadi error (0 = jangan coba ulang).",
    "retry_delay_label": "Jeda Antar Percobaan (detik):",
    "retry_delay_tooltip": "Waktu jeda sebelum mencoba ulang.",
    "checkpoint_settings_title": "Pengaturan Checkpoint",
    "enable_checkpoint_checkbox": "Aktifkan Checkpoint Setelah Node Ini",
    "checkpoint_tooltip": "Simpan state alur kerja setelah node ini berhasil. Jika alur kerja gagal, eksekusi bisa dilanjutkan dari titik ini.",
    "setting_ai_config_title": "Konfigurasi Model AI Default",
    "setting_ai_config_help": "Pilih model AI default untuk setiap jenis tugas. Fitur seperti AI Architect akan menggunakan setelan ini.",
    "setting_ai_for_text": "Teks & Analisa:",
    "setting_ai_for_music": "Musik:",
    "setting_ai_for_tts": "Text-to-Speech (TTS):",
    "setting_ai_for_image": "Gambar:",
    "setting_ai_for_video": "Video:",
    "setting_ai_for_other": "Lainnya (Default):",
    "ai_copilot_prompt": "\nKamu adalah seorang ahli efisiensi dan arsitek alur kerja Flowork. Berdasarkan data histori eksekusi node berikut, temukan potensi inefisiensi atau anti-pattern.\nCari hal-hal seperti:\n- Node yang sering gagal ('status: ERROR').\n- Node yang sangat lambat ('execution_time_ms' sangat tinggi).\n- Anti-pattern logika, seperti urutan beberapa node 'Keyword Router' berturut-turut yang mungkin bisa disederhanakan.\nUntuk setiap temuan, berikan satu saran yang ringkas. Seluruh respons Anda HARUS berupa list JSON objek yang valid.\nSetiap objek harus memiliki kunci ini: 'node_id' (gunakan UUID dari histori), 'node_name', 'module_id', dan 'suggestion'.\nJika tidak menemukan apa-apa, kembalikan list kosong [].\n\nContoh Respons:\n[\n    {{\n        \"node_id\": \"a1b2c3d4-e5f6-g7h8-i9j0-k1l2m3n4o5p6\",\n        \"node_name\": \"Get User Data\",\n        \"module_id\": \"web_scraper_module\",\n        \"suggestion\": \"Node ini gagal 3 kali berturut-turut. Pertimbangkan untuk menambahkan perilaku Coba Ulang (Retry) di propertinya agar lebih tangguh.\"\n    }}\n]\n\nSangat penting: semua teks di dalam kunci 'suggestion' HARUS dalam Bahasa Indonesia.\n\nBerikut adalah histori eksekusi untuk dianalisa:\n---\n{summary_text}\n---\n BALAS PAKE BAHASA INDONESIA",
    "cache_clear_ai_cache": "Cache saran AI dibersihkan: {count} entri.",
    "cache_clear_summary_log_full": "SUKSES: Pembersihan cache selesai. {folders} folder, {files} file, dan {ai_caches} cache AI telah dihapus.",
    "model_converter_config_title": "1. Pengaturan Konversi",
    "model_converter_source_label": "Folder Model Hasil Fine-Tuning:",
    "model_converter_output_label": "Nama File .gguf Baru (tanpa ekstensi):",
    "model_converter_quant_label": "Metode Kuantisasi:",
    "model_converter_monitor_title": "2. Monitor Konversi",
    "model_converter_start_btn": "Mulai Proses Konversi",
    "agent_command_page_title": "Pusat Komando Agent",
    "agent_available_label": "Agent yang Tersedia",
    "agent_interaction_label": "Interaksi Agent",
    "agent_objective_placeholder": " cari 3 berita terbaru tentang tekhnologi ai dari detik.com  rangkum setiap berita menjadi satu paragraph lalu gabungkan semua rangkuman dan hasilnya kirim ke email saya di sahidinaola@gmail.com ",
    "agent_run_button": "Jalankan Agent",
    "agent_running_button": "Menjalankan...",
    "agent_new_button": "Baru...",
    "agent_edit_button": "Edit...",
    "agent_delete_button": "Hapus",
    "agent_confirm_delete_title": "Konfirmasi Hapus",
    "agent_confirm_delete_msg": "Anda yakin ingin menghapus agen '{agent_name}'?",
    "agent_no_agent_selected_msg": "Pilih salah satu agen dari daftar di sebelah kiri.",
    "agent_no_objective_msg": "Harap masukkan tujuan untuk agen.",
    "agent_dialog_title_new": "Buat Agent Baru",
    "agent_dialog_title_edit": "Edit Agent",
    "agent_dialog_name_label": "Nama Agent:",
    "agent_dialog_desc_label": "Deskripsi:",
    "agent_dialog_brain_label": "Otak (Model GGUF):",
    "agent_dialog_tools_label": "Alat yang Diizinkan (Modul):",
    "duallist_available": "Tersedia",
    "duallist_selected": "Terpilih",
    "menu_open_ai_trainer": "Open AI Trainer",
    "menu_open_model_factory": "Open Model Factory",
    "menu_agent_command_center": "Agent Command Center",
    "menu_developer": "Developer",
    "menu_open_core_editor": "Open Core Workflow Editor",
    "agent_no_agent_selected_title": "No Agent Selected",
    "agent_no_objective_title": "No Objective",
    "recorder_widget_tooltip": "Buka Kontrol Perekam Tutorial",
    "recorder_panel_title": "Tutorial Studio",
    "recorder_select_screen": "Rekam Layar:",
    "recorder_select_mic": "Rekam Suara Dari:",
    "recorder_start_button": "Mulai Rekam",
    "recorder_stop_button": "Berhenti & Simpan",
    "recorder_pause_button": "Jeda",
    "recorder_resume_button": "Lanjutkan",
    "recorder_status_recording": "Merekam...",
    "recorder_save_success_title": "Rekaman Disimpan",
    "recorder_save_success_msg": "Tutorial Anda berhasil disimpan di folder 'Videos/Flowork Tutorials'.",
    "recorder_settings_title": "Pengaturan Perekam Layar",
    "recorder_save_path_label": "Lokasi Penyimpanan Default:",
    "recorder_browse_button": "Cari Folder...",
    "recorder_no_audio": "Tidak Ada Audio / Bisu",
    "recorder_refresh_mics_tooltip": "Segarkan daftar mikrofon",
    "recorder_no_mics_found": "Tidak ada mikrofon yang terdeteksi di sistem Anda.",
    "recorder_mic_query_error": "Gagal memindai mikrofon. Periksa driver audio Anda.",
    "recorder_use_default_mic": "Rekam Audio (gunakan mikrofon default)",
    "recorder_gain_label": "Amplifikasi (Gain):",
    "permission_denied_capability": "Akses Ditolak. Tier lisensi Anda saat ini tidak memberikan izin untuk kemampuan '{capability}'. Harap upgrade paket Anda.",
    "permission_denied_library": "Akses Ditolak. Tier lisensi Anda tidak mengizinkan penggunaan library '{library}' yang dibutuhkan untuk kemampuan '{capability}'.",
    "permission_denied_upgrade_prompt": "Apakah Anda ingin melihat paket yang tersedia untuk melakukan upgrade?",
    "permission_denied_detailed": "Akses Ditolak. Kemampuan '{capability}' memerlukan lisensi tier '{required_tier}', namun tier Anda saat ini adalah '{user_tier}'.",
    "permission_denied_secure_mode": "Akses Ditolak karena mode aman. Harap periksa signature file lisensi.","btn_most_popular": "PALING POPULER",
    "tier_pemula_title": "THE BEGINNER",
    "tier_pemula_tagline": "Nyalakan Api Otomasimu",
    "tier_pemula_desc_detail": "Gerbang awal revolusi kerjamu. Ubah 'klik' manual yang melelahkan menjadi alur kerja cerdas yang berjalan sendiri, 24/7.",
    "tier_profesional_title": "THE PROFESSIONAL",
    "tier_profesional_tagline": "Hancurkan Batasan, Bekerja Lebih Cerdas",
    "tier_profesional_desc_detail": "Buka konektivitas penuh ke dunia luar. Ambil data dari situs paling kompleks dan lacak setiap eksekusi langkah demi langkah.",
    "tier_arsitek_ai_title": "THE AI ARCHITECT",
    "tier_arsitek_ai_tagline": "Di sinilah Keajaiban Sesungguhnya Dimulai",
    "tier_arsitek_ai_desc_detail": "Berikan otak pada otomasimu. Anda menjadi sutradara bagi tim AI yang siap menciptakan gambar, musik, dan menganalisa data untuk Anda.",
    "tier_maestro_title": "THE MAESTRO",
    "tier_maestro_tagline": "Ciptakan Sendiri Aturan Mainnya",
    "tier_maestro_desc_detail": "Untuk para visioner. Rancang modul custom dan kompilasi alur kerja visual menjadi aplikasi mandiri. Anda tidak lagi dibatasi oleh toolbox; Anda yang membuat toolbox.",
    "tier_titan_title": "THE TITAN",
    "tier_titan_tagline": "Skalabilitas & Keamanan Tanpa Kompromi",
    "tier_titan_desc_detail": "Solusi custom untuk perusahaan yang menuntut performa, keamanan, dan dukungan tingkat tertinggi untuk mentransformasi seluruh operasi bisnis.",
    "feature_group_foundation": "Fondasi Otomasi Inti",
    "feature_group_connectivity": "Konektivitas Super",
    "feature_group_intelligence": "Pusat Kecerdasan Buatan (AI)",
    "feature_group_powerhouse": "Fitur Powerhouse",
    "feature_group_creator": "Alat Pencipta (Creator Tools)",
    "feature_group_enterprise": "Skala Perusahaan",
    "ai:provider_access": "Akses AI Provider (Gemini, dll)",
    "ai:local_models": "Jalankan Model AI Lokal (GGUF, dll)",
    "module_generator": "Module Generator (Visual)",
    "btn_upgrade_basic": "Jadi Profesional Sekarang!",
    "btn_upgrade_pro": "Lepaskan Kekuatan AI!",
    "btn_upgrade_architect": "Jadilah Maestro!",
    "web_scraping_advanced": "Advanced Web Scraping (Selenium)",
    "video_processing": "Advanced Video Processing",
    "widget_prompt_sender_name": "Pengirim Prompt",
    "widget_prompt_sender_desc": "Widget dashboard untuk mengirimkan prompt teks ke modul penerima spesifik dalam sebuah alur kerja.",
     "loop_run_label": "Ulangi:",
    "loop_times_label": "kali",
    "loop_status_update": "Menjalankan iterasi {current} dari {total}...",
    "loop_finished": "Perulangan selesai.",
    "loop_stopped": "Perulangan dihentikan oleh pengguna.",
    "enable_sleep_checkbox": "Aktifkan Jeda Antar Iterasi",
    "sleep_type_static_radio": "Jeda Statis (detik)",
    "static_duration_tooltip": "Durasi jeda dalam detik.",
    "sleep_type_random_radio": "Jeda Acak (detik)",
    "random_min_label": "Min:",
    "random_min_tooltip": "Durasi jeda minimum (detik).",
    "random_max_label": "Max:",
    "random_max_tooltip": "Durasi jeda maksimum (detik).",
      "prop_loop_control_title": "Kontrol Loop & Jeda",
    "enable_delay_checkbox": "Jeda Antar Loop",
    "delay_type_static": "Statis",
    "delay_type_random": "Acak",
    "log_delay_static": "Menjeda selama {delay} detik...",
    "log_delay_random": "Menjeda selama durasi acak {delay:.2f} detik...",
    "workflow_management_title": "Manajemen Alur Kerja",
    "execution_control_title": "Kontrol Eksekusi",
    "save_workflow_button": "💾 Simpan",
    "load_workflow_button": "📂 Muat",
    "clear_canvas_button": "🧹 Bersihkan",
    "btn_add_new_tab": "➕ New Tab",
    "btn_run_workflow": "Run Workflow",
    "btn_stop_workflow": "Stop Workflow",
    "btn_pause": "Pause",
    "btn_resume": "Resume",
    "btn_stopping": "Stopping...",
    "tooltip_toggle_sidebar": "Tampilkan/Sembunyikan Panel Toolbox",
    "tooltip_logic_toolbox": "Modul Logika",
    "tooltip_plugin_toolbox": "Plugin Aksi",
    "tooltip_widget_toolbox": "Widget Dashboard",
    "tooltip_log_viewer": "Log Eksekusi",
    "tooltip_prompt_sender": "Pengirim Prompt",
    "pin_dock_tooltip": "Pin panel ini agar tetap terbuka",
    "unpin_dock_tooltip": "Lepas pin panel ini untuk mengaktifkan sembunyi-otomatis",
    "fatal_error_title": "Error Fatal",
    "tab_manager_load_error": "TabManagerService tidak dapat dimuat. Aplikasi tidak dapat dilanjutkan.",
    "service_unavailable_error": "Layanan Tidak Tersedia: {service_name}",
    "select_license_file_title": "Pilih File license.seal Anda",
    "license_seal_filetype": "File Segel Lisensi",
    "status_bar_ready": "Siap.",
    "status_bar_recording": "Merekam layar dan audio...",
    "status_bar_saving": "Menyimpan video, harap tunggu...",
    "recorder_start_error": "Tidak dapat memulai rekaman. Periksa log untuk detail.",
    "recorder_save_error": "Gagal menyimpan rekaman. Periksa log untuk detail.",
    "ai_copilot_working_status": "AI Co-pilot sedang bekerja...",
    "action_failed_title": "Aksi Gagal",
    "license_invalid_format_error": "Format file lisensi tidak valid: blok 'data' tidak ditemukan.",
    "license_process_error": "Tidak dapat memproses file lisensi. Error: {error}",
    "license_activated_title": "Lisensi Diaktifkan",
    "license_restart_required_msg": "Harap restart aplikasi agar perubahan dapat diterapkan.",
    "license_activation_failed_title": "Aktivasi Gagal",
    "badge_tooltip_loop": "Looping aktif: Berjalan {count} kali.",
    "badge_tooltip_retry": "Coba Ulang aktif: Mencoba hingga {count} kali jika gagal.",
    "debugger_title": "Mesin Waktu Debugger",
    "debugger_close_button": "Tutup Debugger",
    "debugger_payload_title": "Payload di Langkah Terpilih",
    "action_modules_title": "Modul Aksi"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\ai_copilot_health_scan.py
# JUMLAH BARIS : 59
#######################################################################

```py
import os
from .base_scanner import BaseScanner
class AICopilotHealthScan(BaseScanner):
    """
    Ensures the entire AI Co-pilot pipeline is correctly wired.
    [UPGRADE] Now provides a file preview on failure for easier debugging.
    [FIXED] Corrected the check string for the on_load hook.
    [FIXED V2] The check for TabManager now correctly verifies that it SETS the preset name in StateManager.
    [FIXED V3] The markdown check is now more flexible to variable name changes.
    """
    def run_scan(self) -> str:
        self.report("\n[SCAN] === Starting AI Co-pilot Health & Integrity Scan ===", "SCAN")
        workflow_executor_path = os.path.join(self.kernel.project_root_path, "flowork_kernel", "services", "workflow_executor_service", "workflow_executor_service.py")
        metrics_logger_path = os.path.join(self.kernel.project_root_path, "plugins", "metrics_logger_plugin", "metrics_logger.py")
        module_manager_path = os.path.join(self.kernel.project_root_path, "flowork_kernel", "services", "module_manager_service", "module_manager_service.py")
        analyzer_path = os.path.join(self.kernel.project_root_path, "flowork_kernel", "services", "ai_analyzer_service", "ai_analyzer_service.py")
        tab_action_handler_path = os.path.join(self.kernel.project_root_path, "flowork_kernel", "ui_shell", "ui_components", "controllers", "TabActionHandler.py")
        checks = [
            (workflow_executor_path, "event_bus.publish(\"NODE_EXECUTION_METRIC\"", "Workflow Executor is publishing detailed metrics."),
            (metrics_logger_path, "event_name=\"NODE_EXECUTION_METRIC\"", "Metrics Logger is subscribing to detailed metrics."),
            (module_manager_path, "if not is_paused and hasattr(module_instance, 'on_load'):", "Module Manager calls the 'on_load' lifecycle hook."),
            (analyzer_path, ".startswith(\"```json\")", "AI Analyzer can clean markdown from AI responses."),
            (tab_action_handler_path, "self.state_manager.set(f\"tab_preset_map::{self.tab.tab_id}\"", "Tab/Action Handler correctly saves the active preset name for the AI to find.")
        ]
        checks_passed = 0
        for file_path, content, description in checks:
            found, file_preview = self._check_file_content(file_path, content)
            if found:
                checks_passed += 1
                self.report(f"  [OK] -> {description}", "OK")
            else:
                error_message = f"  [CRITICAL] -> Regression detected! Check failed: '{description}'. The required code is missing."
                if file_preview:
                    error_message += f"\n    -> File preview for '{os.path.basename(file_path)}' starts with:\n---\n{file_preview}\n---"
                self._register_finding(error_message, context={"file": file_path})
        summary = f"AI Co-pilot Health Scan: {checks_passed}/{len(checks)} critical checks passed."
        self.report(f"[DONE] {summary}", "SUCCESS" if checks_passed == len(checks) else "WARN")
        return summary
    def _check_file_content(self, file_path, content_to_find):
        """Helper to check file content and return a preview on failure."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                if content_to_find in content:
                    return True, None
                else:
                    preview = "\n".join(content.splitlines()[:15])
                    return False, preview
        except FileNotFoundError:
            self._register_finding(f"  [ERROR] -> File not found: {file_path}", context={"file": file_path})
            return False, None
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\base_scanner.py
# JUMLAH BARIS : 38
#######################################################################

```py
class BaseScanner:
    """Base class for all scanners to ensure a consistent structure."""
    def __init__(self, kernel, report_callback, config=None):
        self.kernel = kernel
        self.report = report_callback
        self.loc = kernel.get_service("localization_manager")
        self.config = config if config is not None else {}
        self.critical_count = 0
        self.major_count = 0
        self.minor_count = 0
        self.info_count = 0
    def run_scan(self) -> str:
        """The main method that each scanner must implement."""
        raise NotImplementedError
    def _register_finding(self, message: str, context: dict = None):
        """
        New central method for reporting a finding.
        It reads the severity from the config, reports it, and increments the correct counter.
        It now also passes along a context dictionary.
        """
        severity = self.config.get("severity", "MINOR").upper()
        self.report(message, severity, context)
        if severity == 'CRITICAL':
            self.critical_count += 1
        elif severity == 'MAJOR':
            self.major_count += 1
        elif severity == 'MINOR':
            self.minor_count += 1
        elif severity == 'INFO':
            self.info_count += 1
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\cache_integrity_scan.py
# JUMLAH BARIS : 54
#######################################################################

```py
import os
import json
from .base_scanner import BaseScanner
class CacheIntegrityScan(BaseScanner):
    """
    Ensures that the component discovery caching mechanisms are intact and functional.
    It verifies that managers use the cache and that the cache files are valid.
    """
    def run_scan(self) -> str:
        self.report("\n[SCAN] === Starting Component Cache Integrity Scan ===", "SCAN")
        services_to_check = [
            ("ModuleManager", "flowork_kernel/services/module_manager_service/module_manager_service.py", "module_index.cache"),
            ("WidgetManager", "flowork_kernel/services/widget_manager_service/widget_manager_service.py", "widget_index.cache"),
            ("TriggerManager", "flowork_kernel/services/trigger_manager_service/trigger_manager_service.py", "trigger_index.cache")
        ]
        checks_passed = 0
        total_checks = len(services_to_check) * 2 # Logic check + cache file check for each
        for service_name, service_path_rel, cache_filename in services_to_check:
            service_path_abs = os.path.join(self.kernel.project_root_path, service_path_rel)
            cache_path_abs = os.path.join(self.kernel.data_path, cache_filename)
            if os.path.exists(service_path_abs):
                with open(service_path_abs, 'r', encoding='utf-8') as f:
                    content = f.read()
                if "_is_cache_valid" in content:
                    self.report(f"  [OK] -> {service_name} contains cache validation logic.", "OK")
                    checks_passed += 1
                else:
                    self._register_finding(f"  [CRITICAL] -> {service_name} is missing its `_is_cache_valid` logic. Performance will be degraded.", context={"file": service_path_abs})
            else:
                self._register_finding(f"  [CRITICAL] -> Service file for {service_name} not found at {service_path_rel}.", context={"file": service_path_abs})
            if os.path.exists(cache_path_abs):
                try:
                    with open(cache_path_abs, 'r', encoding='utf-8') as f:
                        json.load(f)
                    self.report(f"  [OK] -> Cache file '{cache_filename}' is valid JSON.", "OK")
                    checks_passed += 1
                except json.JSONDecodeError:
                    self._register_finding(f"  [MAJOR] -> Cache file '{cache_filename}' is corrupted (invalid JSON).", context={"file": cache_path_abs})
                except Exception as e:
                    self._register_finding(f"  [MAJOR] -> Could not read cache file '{cache_filename}': {e}", context={"file": cache_path_abs})
            else:
                self.report(f"  [INFO] -> Cache file '{cache_filename}' does not exist yet. Will be created on next run.", "INFO")
                checks_passed += 1
        summary = f"Cache Integrity Scan: {checks_passed}/{total_checks} checks passed."
        self.report(f"[DONE] {summary}", "SUCCESS" if checks_passed == total_checks else "WARN")
        return summary
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\core_compiler_health_scan.py
# JUMLAH BARIS : 79
#######################################################################

```py
import os
import ast
from .base_scanner import BaseScanner
class CoreCompilerHealthScan(BaseScanner):
    """
    Ensures the CoreCompilerModule's logic is intact and its output is syntactically valid.
    [UPGRADE] Now provides a file preview on failure for easier debugging.
    [FIXED] Corrected the check string for source_workflow logic.
    """
    def run_scan(self) -> str:
        self.report("\n[SCAN] === Starting Core Compiler Health & Integrity Scan ===", "SCAN")
        compiler_path = os.path.join(self.kernel.project_root_path, "modules", "core_compiler_module", "processor.py")
        generated_services_path = os.path.join(self.kernel.project_root_path, "generated_services")
        checks_passed = 0
        total_checks = 2
        found, preview = self._check_file_content(compiler_path, "if service_filename == 'core_lifecycle.flowork':")
        if found:
            checks_passed += 1
            self.report("  [OK] -> Compiler correctly handles 'core_lifecycle.flowork' special case.", "OK")
        else:
            error_message = "  [CRITICAL] -> Compiler is missing the check for 'core_lifecycle.flowork'. This could cause startup errors."
            if preview:
                error_message += f"\n    -> File preview for '{os.path.basename(compiler_path)}' starts with:\n---\n{preview}\n---"
            self._register_finding(error_message, context={"file": compiler_path})
        found, preview = self._check_file_content(compiler_path, "\"source_workflow\": target_preset_path")
        if found:
            checks_passed += 1
            self.report("  [OK] -> Compiler correctly leaves a 'source_workflow' trail for idempotency.", "OK")
        else:
            error_message = "  [CRITICAL] -> Compiler is missing the 'source_workflow' logic. Recompiling will fail."
            if preview:
                error_message += f"\n    -> File preview for '{os.path.basename(compiler_path)}' starts with:\n---\n{preview}\n---"
            self._register_finding(error_message, context={"file": compiler_path})
        self.report("\n[SCAN] --- Scanning Generated Services for Syntax Errors ---", "SCAN")
        if not os.path.isdir(generated_services_path):
            self.report("  [INFO] -> 'generated_services' directory not found. Skipping syntax validation.", "INFO")
        else:
            found_files = 0
            for root, _, files in os.walk(generated_services_path):
                for file in files:
                    if file.endswith("service.py"):
                        found_files += 1
                        total_checks += 1
                        service_path = os.path.join(root, file)
                        try:
                            with open(service_path, 'r', encoding='utf-8') as f:
                                ast.parse(f.read())
                            self.report(f"  [OK] -> Generated file is syntactically valid: {os.path.relpath(service_path, self.kernel.project_root_path)}", "OK")
                            checks_passed += 1
                        except SyntaxError as e:
                            self._register_finding(f"  [CRITICAL] -> Generated file has a SyntaxError: {os.path.relpath(service_path, self.kernel.project_root_path)} | Error: {e}", context={"file": service_path})
                        except Exception as e:
                            self._register_finding(f"  [CRITICAL] -> Could not parse generated file: {os.path.relpath(service_path, self.kernel.project_root_path)} | Error: {e}", context={"file": service_path})
            if found_files == 0:
                self.report("  [INFO] -> No generated 'service.py' files found to validate.", "INFO")
        summary = f"Core Compiler Health Scan: {checks_passed}/{total_checks} checks passed."
        self.report(f"[DONE] {summary}", "SUCCESS" if checks_passed == total_checks else "WARN")
        return summary
    def _check_file_content(self, file_path, content_to_find):
        """Helper to check file content and return a preview on failure."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                if content_to_find in content:
                    return True, None
                else:
                    preview = "\n".join(content.splitlines()[:5])
                    return False, preview
        except FileNotFoundError:
            self._register_finding(f"  [ERROR] -> File not found: {file_path}", "ERROR")
            return False, None
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\core_integrity_scan.py
# JUMLAH BARIS : 40
#######################################################################

```py
import os
from .base_scanner import BaseScanner
class CoreIntegrityScan(BaseScanner):
    """
    Ensures that the IntegrityCheckerService is being called by the StartupService.
    This is a "Doctor Code" check for our "Benteng Baja" feature.
    """
    def run_scan(self) -> str:
        self.report("\n[SCAN] === Starting Core Integrity Vitals Scan ===", "SCAN")
        startup_service_path = os.path.join(self.kernel.project_root_path, "flowork_kernel", "services", "startup_service", "startup_service.py")
        checks_passed = 0
        total_checks = 1
        if self._check_content(startup_service_path, "self.kernel.get_service(\"integrity_checker_service\").verify_core_files()"):
            checks_passed += 1
            self.report("  [OK] -> Vitals check passed: File integrity check is correctly called at startup.", "OK")
        else:
            self._register_finding(
                "  [CRITICAL] -> Regression detected! The 'Benteng Baja' integrity check is missing from StartupService.",
                context={"file": startup_service_path}
            )
        summary = f"Core Integrity Vitals Scan: {checks_passed}/{total_checks} critical checks passed."
        self.report(f"[DONE] {summary}", "SUCCESS" if checks_passed == total_checks else "WARN")
        return summary
    def _check_content(self, file_path, text_to_find):
        """Helper to check if a text exists in a file."""
        if not os.path.exists(file_path):
            return False
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return text_to_find in f.read()
        except Exception:
            return False
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\data_preview_readiness_scan.py
# JUMLAH BARIS : 136
#######################################################################

```py
import os
import ast
import re # ADDED: For more robust class definition finding
from .base_scanner import BaseScanner
from flowork_kernel.api_contract import IDataPreviewer
class DataPreviewReadinessScanCore(BaseScanner):
    """
    Scans modules to find which ones are good candidates for implementing the
    IDataPreviewer interface but haven't done so yet.
    [V2] This version uses a more robust patching mechanism to prevent partial updates.
    It intelligently decides whether to write a full implementation or a template.
    """
    def run_scan(self) -> str:
        self.report("\n[INFO] === Starting DYNAMIC Data Preview Readiness Scan (V2 - Fail-Safe) ===", "INFO")
        module_manager = self.kernel.get_service("module_manager_service")
        if not module_manager:
            self._register_finding("  [ERROR] -> ModuleManagerService not found!", "CRITICAL")
            return "Scan Failed: Core service missing."
        found_issues = 0
        for module_id, data in module_manager.loaded_modules.items():
            if not data.get("instance"): continue
            instance = data["instance"]
            manifest = data.get("manifest", {})
            if isinstance(instance, IDataPreviewer):
                continue
            is_candidate = False
            data_keywords = ["data", "scraper", "variable", "http", "api", "code", "runner", "ai_"]
            if manifest.get("output_schema"):
                is_candidate = True
            if not is_candidate:
                for keyword in data_keywords:
                    if keyword in module_id:
                        is_candidate = True
                        break
            if is_candidate:
                node_name = manifest.get('name', module_id)
                message = (
                    f"  [WARN] -> Module '{node_name}' detected as a candidate for data previews. Attempting to auto-patch..."
                )
                self._register_finding(message, context={"module_id": module_id})
                found_issues += 1
                self._auto_patch_module_v2(data)
        if found_issues == 0:
            self.report("  [OK] -> All candidate modules already support data previews.", "OK")
        summary = f"Data Preview Scan: Attempted to patch/implement {found_issues} modules."
        self.report(f"[DONE] {summary}", "SUCCESS")
        return summary
    def _auto_patch_module_v2(self, module_data):
        """
        [V2] A more robust method to inject the IDataPreviewer interface and method.
        It uses regex for better accuracy and constructs the full file in memory before writing.
        """
        module_id = module_data.get('manifest', {}).get('id')
        entry_point = module_data.get('manifest', {}).get('entry_point')
        module_path = module_data.get('path')
        if not all([module_id, entry_point, module_path]):
            self.report(f"    -> [ERROR] Auto-patching for '{module_id}' failed: missing manifest data.", "ERROR")
            return
        try:
            module_filename, class_name = entry_point.split('.')
            processor_path = os.path.join(module_path, f"{module_filename}.py")
            if not os.path.exists(processor_path):
                self.report(f"    -> [ERROR] Processor file not found at: {processor_path}", "ERROR")
                return
            with open(processor_path, 'r', encoding='utf-8') as f:
                content = f.read()
            if "IDataPreviewer" in content and "def get_data_preview" in content:
                self.report(f"    -> [INFO] Module '{module_id}' seems to be already patched. Skipping.", "INFO")
                return
            patch_type = "template"
            method_template = ""
            if module_id == "set_variable_module":
                patch_type = "full implementation"
                method_template = """
    def get_data_preview(self, config: dict):
        \"\"\"
        Returns the dictionary of variables defined in the config.
        \"\"\"
        variables_to_set = config.get('variables', [])
        preview_data = {var.get('name'): var.get('value') for var in variables_to_set if var.get('name')}
        return preview_data
"""
            else:
                patch_type = "template"
                method_template = """
    def get_data_preview(self, config: dict):
        \"\"\"
        TODO: Implement the data preview logic for this module.
        This method should return a small, representative sample of the data
        that the 'execute' method would produce.
        It should run quickly and have no side effects.
        \"\"\"
        self.logger(f"'get_data_preview' is not yet implemented for {self.module_id}", 'WARN')
        return [{'status': 'preview not implemented'}]
"""
            new_content = ""
            import_line = "from flowork_kernel.api_contract import IDataPreviewer\n"
            if import_line.strip() not in content:
                last_import_idx = content.rfind("\nfrom ")
                if last_import_idx == -1: last_import_idx = content.rfind("\nimport ")
                if last_import_idx != -1:
                    end_of_line = content.find('\n', last_import_idx + 1)
                    new_content = content[:end_of_line+1] + import_line + content[end_of_line+1:]
                else: # No imports found, add at top
                    new_content = import_line + content
            else:
                new_content = content
            class_def_pattern = re.compile(r"class\s+" + re.escape(class_name) + r"(\([^)]*\))?\s*:")
            match = class_def_pattern.search(new_content)
            if not match:
                self.report(f"    -> [ERROR] Could not find class definition for '{class_name}'. Skipping patch.", "ERROR")
                return
            original_class_def = match.group(0)
            existing_parents = match.group(1)
            if existing_parents: # Already has parents, e.g., class MyClass(BaseModule):
                if "IDataPreviewer" not in existing_parents:
                    new_parents = existing_parents.replace(")", ", IDataPreviewer)")
                    modified_class_def = f"class {class_name}{new_parents}:"
                    new_content = new_content.replace(original_class_def, modified_class_def)
            else: # No parents, e.g., class MyClass:
                modified_class_def = f"class {class_name}(IDataPreviewer):"
                new_content = new_content.replace(original_class_def, modified_class_def)
            new_content += method_template
            with open(processor_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
            self.report(f"    -> [SUCCESS] Auto-patched '{os.path.basename(processor_path)}' with a {patch_type} successfully.", "SUCCESS")
        except Exception as e:
            self.report(f"    -> [FATAL] Auto-patching for '{module_id}' failed critically: {e}", "CRITICAL")
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\diagnostics_config.json
# JUMLAH BARIS : 54
#######################################################################

```json
{
    "scanners": {
        "marketplace_integrity": {
            "enabled": true,
            "severity": "CRITICAL",
            "config": {}
        },
        "manifest_mismatch": {
            "enabled": true,
            "severity": "CRITICAL",
            "config": {}
        },
        "phase_one_integrity": {
            "enabled": true,
            "severity": "CRITICAL",
            "config": {}
        },
        "data_preview_readiness": {
            "enabled": true,
            "severity": "MINOR",
            "config": {}
        },
        "cache_integrity": {
            "enabled": true,
            "severity": "MAJOR",
            "config": {}
        },
        "ai_copilot_health": {
            "enabled": true,
            "severity": "CRITICAL",
            "config": {}
        },
        "core_compiler_health": {
            "enabled": true,
            "severity": "CRITICAL",
            "config": {}
        },
        "manifest_completeness": {
            "enabled": true,
            "severity": "MINOR",
            "config": {}
        },
        "tier_attribute": {
            "enabled": true,
            "severity": "MAJOR",
            "config": {}
        },
        "core_integrity": {
            "enabled": true,
            "severity": "CRITICAL",
            "config": {}
        }
    }
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\diagnostics_page.py
# JUMLAH BARIS : 340
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import scrolledtext, BooleanVar, messagebox
import os
import re
import importlib
import inspect
import threading
import time
import json
import sys
from flowork_kernel.ui_shell.custom_widgets.scrolled_frame import ScrolledFrame
from scanners.base_scanner import BaseScanner
class DiagnosticsPage(ttk.Frame):
    """
    The main UI frame for the System Diagnostics tab.
    """
    def __init__(self, parent_notebook, kernel_instance):
        super().__init__(parent_notebook, padding=0)
        self.kernel = kernel_instance
        self.loc = self.kernel.get_service("localization_manager")
        self.scanner_classes = []
        self.scanner_vars = {}
        self.animation_labels = {}
        self.animation_jobs = {}
        self.animation_frames = ['|', '/', '-', '\\']
        self._all_report_entries = []
        self.filter_vars = {
            'CRITICAL': BooleanVar(value=True),
            'MAJOR': BooleanVar(value=True),
            'MINOR': BooleanVar(value=True),
            'INFO': BooleanVar(value=True),
            'SCAN': BooleanVar(value=True),
            'OK': BooleanVar(value=True)
        }
        self.guide_is_pinned = False
        self.hide_guide_job = None
        self.scanner_config = self._load_config()
        self._build_ui()
        self._discover_and_populate_scanners()
        self._populate_guide()
    def _apply_markdown_to_text_widget(self, text_widget, content):
        text_widget.config(state="normal")
        text_widget.delete("1.0", "end")
        parts = re.split(r'(\*\*.*?\*\*)', content)
        for part in parts:
            if part.startswith('**') and part.endswith('**'):
                text_widget.insert("end", part[2:-2], "bold")
            else:
                text_widget.insert("end", part)
        text_widget.config(state="disabled")
    def _populate_guide(self):
        guide_content = self.loc.get("diagnostics_guide_content")
        self._apply_markdown_to_text_widget(self.guide_text, guide_content)
        self.guide_text.tag_configure("bold", font="-size 9 -weight bold")
    def _load_config(self):
        self.config_path = os.path.join(self.kernel.project_root_path, "scanners", 'diagnostics_config.json')
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                config_lines = [line for line in f if not line.strip().startswith('//')]
                config_string = "".join(config_lines)
                config_data = json.loads(config_string)
            self.kernel.write_to_log("Scanner configuration loaded successfully.", "SUCCESS")
            return config_data.get("scanners", {})
        except (FileNotFoundError, json.JSONDecodeError) as e:
            self.kernel.write_to_log(f"Failed to load diagnostics_config.json: {e}. Using defaults.", "ERROR")
            return {}
    def _build_ui(self):
        main_content_frame = ttk.Frame(self, padding=15)
        main_content_frame.place(relx=0, rely=0, relwidth=1, relheight=1)
        paned_window = ttk.PanedWindow(main_content_frame, orient='horizontal')
        paned_window.pack(fill='both', expand=True)
        guide_handle = ttk.Frame(self, width=15, bootstyle="secondary")
        guide_handle.place(relx=0, rely=0, relheight=1, anchor='nw')
        handle_label = ttk.Label(guide_handle, text=">", bootstyle="inverse-secondary", font=("Helvetica", 10, "bold"))
        handle_label.pack(expand=True)
        guide_handle.bind("<Enter>", self._show_guide_panel)
        self.guide_panel = ttk.Frame(self, bootstyle="secondary")
        control_bar = ttk.Frame(self.guide_panel, bootstyle="secondary")
        control_bar.pack(fill='x', padx=5, pady=2)
        self.guide_pin_button = ttk.Button(control_bar, text="📌", bootstyle="light-link", command=self._toggle_pin_guide)
        self.guide_pin_button.pack(side='right')
        guide_frame_inner = ttk.LabelFrame(self.guide_panel, text=self.loc.get('diagnostics_guide_title'), padding=15)
        guide_frame_inner.pack(fill='both', expand=True, padx=5, pady=(0,5))
        guide_frame_inner.columnconfigure(0, weight=1)
        guide_frame_inner.rowconfigure(0, weight=1)
        self.guide_text = scrolledtext.ScrolledText(guide_frame_inner, wrap="word", height=10, state="disabled", font="-size 9")
        self.guide_text.grid(row=0, column=0, sticky="nsew")
        self.guide_panel.bind("<Leave>", self._hide_guide_panel_later)
        self.guide_panel.bind("<Enter>", self._cancel_hide_guide)
        guide_handle.lift()
        left_pane = ttk.Frame(paned_window, padding=10)
        paned_window.add(left_pane, weight=1)
        control_frame = ttk.LabelFrame(left_pane, text=self.loc.get('diagnostics_control_panel_title', fallback="Control Panel"))
        control_frame.pack(fill='both', expand=True)
        control_frame.rowconfigure(1, weight=1)
        control_frame.columnconfigure(0, weight=1)
        header_frame = ttk.Frame(control_frame)
        header_frame.grid(row=0, column=0, sticky='ew', pady=(5,10), padx=5)
        self.select_all_var = BooleanVar(value=True)
        ttk.Checkbutton(header_frame, text=self.loc.get('diagnostics_select_all_toggle', fallback="Select / Deselect All"), variable=self.select_all_var, command=self._toggle_all_scanners).pack(side='left')
        scrolled_list = ScrolledFrame(control_frame)
        scrolled_list.grid(row=1, column=0, sticky='nsew', padx=5)
        self.scanner_list_frame = scrolled_list.scrollable_frame
        button_frame = ttk.Frame(control_frame)
        button_frame.grid(row=2, column=0, sticky='ew', pady=(10,0), padx=5)
        button_frame.columnconfigure((0,1), weight=1)
        self.run_selected_button = ttk.Button(button_frame, text=self.loc.get('diagnostics_run_selected_button', fallback="Run Selected Scanners"), command=lambda: self._start_scan_thread(selected_only=True))
        self.run_selected_button.grid(row=0, column=0, sticky='ew', padx=(0,5))
        self.run_all_button = ttk.Button(button_frame, text=self.loc.get('diagnostics_run_all_button', fallback="Run All Scanners"), command=self._start_scan_thread, bootstyle="success")
        self.run_all_button.grid(row=0, column=1, sticky='ew', padx=(5,0))
        self.save_config_button = ttk.Button(button_frame, text=self.loc.get('diagnostics_save_config_button', fallback="Save Configuration"), command=self._save_scanner_config, bootstyle="primary")
        self.save_config_button.grid(row=1, column=0, sticky='ew', pady=(5,0), padx=(0,5))
        self.copy_results_button = ttk.Button(button_frame, text=self.loc.get("diagnostics_copy_results_button"), command=self._copy_report_to_clipboard, bootstyle="info")
        self.copy_results_button.grid(row=1, column=1, sticky='ew', pady=(5,0), padx=(5,0))
        right_pane = ttk.Frame(paned_window, padding=10)
        paned_window.add(right_pane, weight=3)
        right_pane.rowconfigure(2, weight=1)
        right_pane.columnconfigure(0, weight=1)
        report_frame = ttk.LabelFrame(right_pane, text=self.loc.get('diagnostics_report_panel_title', fallback="Report Panel"))
        report_frame.pack(fill='both', expand=True)
        report_frame.rowconfigure(2, weight=1)
        report_frame.columnconfigure(0, weight=1)
        self.progress = ttk.Progressbar(report_frame, mode='determinate')
        self.progress.grid(row=0, column=0, sticky='ew', padx=10, pady=10)
        filter_controls_frame = ttk.Frame(report_frame)
        filter_controls_frame.grid(row=1, column=0, sticky='ew', padx=10, pady=(0, 10))
        ttk.Label(filter_controls_frame, text=self.loc.get('diagnostics_filter_level_label', fallback="Show Levels:")).pack(side='left', anchor='w', padx=(0, 10))
        filter_options = [("CRITICAL", "danger"), ("MAJOR", "danger"), ("MINOR", "warning"), ("INFO", "info"), ("SCAN", "primary"), ("OK", "success")]
        for text, style in filter_options:
            cb = ttk.Checkbutton(filter_controls_frame, text=text, variable=self.filter_vars.get(text), bootstyle=f"{style}-round-toggle", command=self._apply_filters_to_report)
            cb.pack(side='left', padx=3)
        self.report_text = scrolledtext.ScrolledText(report_frame, wrap='word', state='disabled', font=("Consolas", 9))
        self.report_text.grid(row=2, column=0, sticky='nsew', padx=10, pady=(0,10))
        self._configure_text_tags()
    def _save_scanner_config(self):
        self.kernel.write_to_log("Saving scanner configuration...", "INFO")
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                full_config = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            full_config = {"scanners": {}}
        current_scanners_config = full_config.get("scanners", {})
        for class_name, var in self.scanner_vars.items():
            scanner_id = re.sub(r'(?<!^)(?=[A-Z])', '_', class_name.replace("Core", "").replace("Scan", "")).lower()
            if scanner_id in current_scanners_config:
                current_scanners_config[scanner_id]['enabled'] = var.get()
            else:
                current_scanners_config[scanner_id] = {"enabled": var.get(), "severity": "MINOR", "config": {}}
        full_config["scanners"] = current_scanners_config
        try:
            with open(self.config_path, 'w', encoding='utf-8') as f:
                json.dump(full_config, f, indent=4)
            self.kernel.write_to_log("Scanner configuration saved successfully.", "SUCCESS")
            messagebox.showinfo("Success", "Scanner configuration saved successfully.")
        except Exception as e:
            self.kernel.write_to_log(f"Failed to save scanner configuration: {e}", "ERROR")
            messagebox.showerror("Error", f"Failed to save configuration: {e}")
    def _discover_and_populate_scanners(self):
        for child in self.scanner_list_frame.winfo_children():
            child.destroy()
        self.scanner_classes.clear()
        self.scanner_vars.clear()
        self.animation_labels.clear()
        scanners_dir = os.path.join(self.kernel.project_root_path, 'scanners')
        discovered_classes = []
        if os.path.isdir(scanners_dir):
            if self.kernel.project_root_path not in sys.path:
                sys.path.insert(0, self.kernel.project_root_path)
            for entry in os.scandir(scanners_dir):
                if entry.name.endswith('.py') and not entry.name.startswith('__') and entry.name not in ['diagnostics_page.py']:
                    module_name = f"scanners.{entry.name[:-3]}"
                    try:
                        module = importlib.import_module(module_name)
                        for name, obj in inspect.getmembers(module, inspect.isclass):
                            if issubclass(obj, BaseScanner) and obj is not BaseScanner:
                                discovered_classes.append(obj)
                    except Exception as e:
                        self.kernel.write_to_log(f"DiagnosticsUI: Failed to import scanner from '{entry.name}': {e}", "ERROR")
        discovered_classes.sort(key=lambda x: x.__name__)
        list_counter = 1
        for scanner_class in discovered_classes:
            class_name = scanner_class.__name__
            scanner_id = re.sub(r'(?<!^)(?=[A-Z])', '_', class_name.replace("Core", "").replace("Scan", "")).lower()
            is_enabled_from_config = self.scanner_config.get(scanner_id, {}).get("enabled", True)
            self.scanner_classes.append(scanner_class)
            display_name = re.sub(r'([a-z0-9])([A-Z])', r'\1 \2', class_name.replace("Core", "")).replace("Scan", " Scan")
            item_frame = ttk.Frame(self.scanner_list_frame)
            item_frame.pack(fill='x', padx=10, pady=2)
            number_label = ttk.Label(item_frame, text=f"{list_counter}.", width=4, anchor='w')
            number_label.pack(side='left')
            var = BooleanVar(value=is_enabled_from_config)
            self.scanner_vars[class_name] = var
            checkbutton = ttk.Checkbutton(item_frame, text=display_name, variable=var)
            checkbutton.pack(side='left')
            animation_label = ttk.Label(item_frame, text="", width=3, bootstyle="info")
            animation_label.pack(side='left', padx=(5, 0))
            self.animation_labels[class_name] = animation_label
            list_counter += 1
    def _toggle_all_scanners(self):
        is_checked = self.select_all_var.get()
        for var in self.scanner_vars.values():
            var.set(is_checked)
    def _configure_text_tags(self):
        theme_manager = self.kernel.get_service("theme_manager")
        if not theme_manager: return
        colors = theme_manager.get_colors()
        self.report_text.config(background=colors.get('dark', '#333'), foreground=colors.get('fg', 'white'))
        style = ttk.Style.get_instance()
        critical_bg = style.colors.get('danger')
        tags_to_configure = {
            "CRITICAL": {'foreground': colors.get('light'), 'background': critical_bg, 'font': ('Consolas', 9, 'bold')},
            "MAJOR": {'foreground': colors.get('danger')}, "MINOR": {'foreground': colors.get('warning')},
            "INFO": {'foreground': colors.get('fg')}, "SUCCESS": {'foreground': colors.get('success')},
            "OK": {'foreground': colors.get('success')}, "SCAN": {'foreground': colors.get('info')},
            "DEBUG": {'foreground': colors.get('secondary')}
        }
        for tag, config in tags_to_configure.items():
            self.report_text.tag_config(tag, **config)
    def _add_report_line(self, message, level="INFO", context=None):
        if not self.winfo_exists(): return
        self._all_report_entries.append({'message': message, 'level': level.upper(), 'context': context or {}})
        self._apply_filters_to_report()
    def _apply_filters_to_report(self):
        if not self.winfo_exists(): return
        levels_to_show = {level for level, var in self.filter_vars.items() if var.get()}
        self.report_text.config(state='normal')
        self.report_text.delete('1.0', 'end')
        for entry in self._all_report_entries:
            if entry['level'] in levels_to_show:
                self.report_text.insert('end', f"{entry['message']}\n", (entry['level'],))
        self.report_text.see('end')
        self.report_text.config(state='disabled')
        self.update_idletasks()
    def _copy_report_to_clipboard(self):
        try:
            content = self.report_text.get("1.0", "end-1c")
            if content.strip():
                self.clipboard_clear()
                self.clipboard_append(content)
                self.kernel.write_to_log(self.loc.get("diagnostics_log_copied_success"), "SUCCESS")
        except Exception as e:
            self.kernel.write_to_log(f"Failed to copy diagnostics report: {e}", "ERROR")
    def _clear_animations(self):
        for label in self.animation_labels.values():
            label.config(text="")
    def _start_animation(self, class_name):
        if class_name in self.animation_jobs:
            self.after_cancel(self.animation_jobs[class_name])
        self._update_animation_frame(class_name, 0)
    def _update_animation_frame(self, class_name, frame_index):
        if class_name in self.animation_labels:
            label = self.animation_labels[class_name]
            if label.winfo_exists():
                label.config(text=f" {self.animation_frames[frame_index]}", bootstyle="info")
                next_frame_index = (frame_index + 1) % len(self.animation_frames)
                job_id = self.after(150, self._update_animation_frame, class_name, next_frame_index)
                self.animation_jobs[class_name] = job_id
    def _stop_animation(self, class_name):
        if class_name in self.animation_jobs:
            self.after_cancel(self.animation_jobs[class_name])
            del self.animation_jobs[class_name]
        if class_name in self.animation_labels:
            label = self.animation_labels[class_name]
            if label.winfo_exists():
                label.config(text="✓", bootstyle="success")
    def _start_scan_thread(self, selected_only=False):
        self.run_selected_button.config(state="disabled")
        self.run_all_button.config(state="disabled")
        self.save_config_button.config(state="disabled")
        self.progress['value'] = 0
        self._all_report_entries.clear()
        self._apply_filters_to_report()
        self._clear_animations()
        scanners_to_run = []
        if selected_only:
            for scanner_class in self.scanner_classes:
                if self.scanner_vars[scanner_class.__name__].get():
                    scanners_to_run.append(scanner_class)
        else:
            for scanner_class in self.scanner_classes:
                scanner_id = re.sub(r'(?<!^)(?=[A-Z])', '_', scanner_class.__name__.replace("Core", "").replace("Scan", "")).lower()
                if self.scanner_config.get(scanner_id, {}).get("enabled", True):
                     scanners_to_run.append(scanner_class)
        if not scanners_to_run:
            self.run_selected_button.config(state="normal")
            self.run_all_button.config(state="normal")
            self.save_config_button.config(state="normal")
            return
        def scan_target():
            total_scanners = len(scanners_to_run)
            self.progress['maximum'] = total_scanners
            total_counts = {'CRITICAL': 0, 'MAJOR': 0, 'MINOR': 0, 'INFO': 0}
            for i, scanner_class in enumerate(scanners_to_run):
                if not self.winfo_exists(): break
                class_name = scanner_class.__name__
                self.after(0, self._start_animation, class_name)
                scanner_id = re.sub(r'(?<!^)(?=[A-Z])', '_', class_name.replace("Core", "").replace("Scan", "")).lower()
                scanner_specific_config = self.scanner_config.get(scanner_id, {})
                instance = scanner_class(self.kernel, lambda msg, lvl, context=None: self.after(0, self._add_report_line, msg, lvl, context), config=scanner_specific_config)
                instance.run_scan()
                self.after(0, self._stop_animation, class_name)
                total_counts['CRITICAL'] += getattr(instance, 'critical_count', 0)
                total_counts['MAJOR'] += getattr(instance, 'major_count', 0)
                total_counts['MINOR'] += getattr(instance, 'minor_count', 0)
                total_counts['INFO'] += getattr(instance, 'info_count', 0)
                self.after(0, lambda i=i: self.progress.config(value=i + 1))
                time.sleep(0.05)
            summary_parts = [f"{count} {level}" for level, count in total_counts.items() if count > 0]
            final_summary = f"Scan Complete. Total findings: {', '.join(summary_parts) if summary_parts else '0'}."
            self.after(0, self._add_report_line, f"\n{'='*60}\n{final_summary}\n{'='*60}", "SUCCESS")
            if self.winfo_exists():
                self.after(0, lambda: self.run_selected_button.config(state="normal"))
                self.after(0, lambda: self.run_all_button.config(state="normal"))
                self.after(0, lambda: self.save_config_button.config(state="normal"))
        threading.Thread(target=scan_target, daemon=True).start()
    def _toggle_pin_guide(self):
        self.guide_is_pinned = not self.guide_is_pinned
        pin_char = "📌"
        self.guide_pin_button.config(text=pin_char)
        if not self.guide_is_pinned:
            self._hide_guide_panel_later()
    def _show_guide_panel(self, event=None):
        self._cancel_hide_guide()
        self.guide_panel.place(in_=self, relx=0, rely=0, relheight=1.0, anchor='nw', width=350)
        self.guide_panel.lift()
    def _hide_guide_panel_later(self, event=None):
        if not self.guide_is_pinned:
            self.hide_guide_job = self.after(300, lambda: self.guide_panel.place_forget())
    def _cancel_hide_guide(self, event=None):
        if self.hide_guide_job:
            self.after_cancel(self.hide_guide_job)
            self.hide_guide_job = None
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\license_and_integrity_scan.py
# JUMLAH BARIS : 74
#######################################################################

```py
import os
import re
from .base_scanner import BaseScanner
class PhaseOneIntegrityScan(BaseScanner):
    """
    Scans the UI layer to enforce the rules of Phase 1: Total Independence.
    This "Doctor Code" scanner not only finds violations but also attempts to
    auto-patch them by replacing direct kernel calls with their ApiClient equivalents.
    """
    def run_scan(self) -> str:
        self.report("\n[SCAN] === Starting Phase 1: Independence Integrity Scan (Doctor Code Mode) ===", "SCAN")
        ui_paths = [
            os.path.join(self.kernel.project_root_path, "flowork_kernel", "ui_shell"),
            os.path.join(self.kernel.project_root_path, "widgets"),
            os.path.join(self.kernel.project_root_path, "plugins")
        ]
        illegal_pattern = re.compile(r"self\.kernel\.get_service\([\"']([\w_]+)[\"']\)\.([\w_]+)\((.*)\)")
        files_scanned = 0
        total_violations_found = 0
        total_violations_healed = 0
        for path in ui_paths:
            if not os.path.isdir(path):
                continue
            for root, _, files in os.walk(path):
                if 'system_diagnostics_plugin' in root:
                    continue
                for file in files:
                    if file.endswith(".py"):
                        file_path = os.path.join(root, file)
                        files_scanned += 1
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                original_content = f.read()
                            content_to_patch = original_content
                            patches_made_in_file = 0
                            matches = list(illegal_pattern.finditer(original_content))
                            if matches:
                                for match in matches:
                                    total_violations_found += 1
                                    line_num = original_content.count('\n', 0, match.start()) + 1
                                    full_match_text = match.group(0)
                                    self.report(f"  [CRITICAL] -> Found violation in '{os.path.relpath(file_path, self.kernel.project_root_path)}' on line {line_num}:", "CRITICAL", context={"file": file_path, "line": line_num})
                                    self.report(f"    -> Code: {full_match_text}", "DEBUG")
                                    healed_code = None # Forcing manual fix for now
                                    if healed_code:
                                        self.report(f"    -> [HEALED] Auto-patched to: self.{healed_code}", "SUCCESS")
                                        content_to_patch = patched_content
                                        total_violations_healed += 1
                                        patches_made_in_file += 1
                                    else:
                                        self.report("    -> [MANUAL FIX NEEDED] Could not automatically determine the ApiClient equivalent.", "MAJOR")
                        except Exception as e:
                            self.report(f"  [ERROR] -> Could not read or process file: {file_path}. Reason: {e}", "CRITICAL")
        if total_violations_found == 0:
            self.report(f"  [OK] -> Scan complete. No violations found in {files_scanned} scanned files. All UI components are independent.", "OK")
        summary = f"Phase 1 Integrity Scan complete. Scanned {files_scanned} files. Found {total_violations_found} violations. Auto-healed {total_violations_healed}."
        self.report(f"[DONE] {summary}", "SUCCESS" if total_violations_found == total_violations_healed else "WARN")
        return summary
    def _auto_patch_file(self, file_path, current_content, match):
        """
        The core healing logic. Takes the file content and a regex match,
        and returns the patched content if successful.
        NOTE: This is a complex and potentially risky function. It is disabled by default in this version
        to prefer manual, controlled fixes.
        """
        return None, current_content
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\manifest.json
# JUMLAH BARIS : 20
#######################################################################

```json
{
    "id": "flowork_core_ui",
    "name": "Flowork Core UI",
    "version": "1.0",
    "icon_file": "icon.png",
    "author": "Awenk Audico",
    "email": "Contributor@teetah.art",
    "website": "www.teetah.art",
    "description": "Menyediakan semua antarmuka manajemen inti untuk Flowork.",
    "type": "PLUGIN",
    "entry_point": "core_ui_provider.CoreUIProvider",
    "requires_services": [
        "kernel",
        "loc",
        "logger"
    ],
    "permissions": [
        "ui_provider"
    ]
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\manifest_completeness_scan.py
# JUMLAH BARIS : 75
#######################################################################

```py
import os
import json
from collections import OrderedDict
from .base_scanner import BaseScanner
class ManifestCompletenessScanCore(BaseScanner):
    """
    Scans all component manifests to ensure they contain essential metadata.
    [V2] This version doesn't just add missing fields, it also REBUILDS the
    manifest to enforce a standard, readable key order.
    """
    REQUIRED_FIELDS = {
        "icon_file": "icon.png",
        "author": "Flowork Contributor",
        "email": "Contributor@teetah.art",
        "website": "www.teetah.art"
    }
    IDEAL_KEY_ORDER = [
        "id", "name", "version", "icon_file", "author", "email", "website",
        "description", "type", "entry_point"
    ]
    def run_scan(self) -> str:
        self.report("\n[INFO] === Starting Manifest Completeness & Order Scan (V2) ===", "INFO")
        module_manager = self.kernel.get_service("module_manager_service")
        widget_manager = self.kernel.get_service("widget_manager_service")
        if not module_manager or not widget_manager:
            self._register_finding("  [ERROR] -> Core services not found!", "CRITICAL")
            return "Scan Failed: Core service missing."
        all_components = {**module_manager.loaded_modules, **widget_manager.loaded_widgets}
        patched_files_count = 0
        for component_id, data in all_components.items():
            component_path = data.get("path")
            if not component_path: continue
            manifest_path = os.path.join(component_path, 'manifest.json')
            if not os.path.exists(manifest_path): continue
            try:
                with open(manifest_path, 'r', encoding='utf-8') as f:
                    original_manifest_data = json.load(f)
                current_manifest = original_manifest_data.copy()
                keys_to_add = []
                for key, default_value in self.REQUIRED_FIELDS.items():
                    if key not in current_manifest:
                        keys_to_add.append(key)
                        current_manifest[key] = default_value
                reordered_manifest = OrderedDict()
                for key in self.IDEAL_KEY_ORDER:
                    if key in current_manifest:
                        reordered_manifest[key] = current_manifest.pop(key)
                for key, value in current_manifest.items():
                    reordered_manifest[key] = value
                if keys_to_add or list(reordered_manifest.keys()) != list(original_manifest_data.keys()):
                    self.report(f"----------------------------------------\n[SCAN] Analyzing manifest for: '{component_id}'", "SCAN")
                    with open(manifest_path, 'w', encoding='utf-8') as f:
                        json.dump(reordered_manifest, f, indent=4, ensure_ascii=False)
                    action_log = "tidied up key order."
                    if keys_to_add:
                        action_log = f"added missing keys: {', '.join(keys_to_add)} and tidied up order."
                    message = (f"  [WARN] -> Patched manifest for '{component_id}': {action_log}")
                    self._register_finding(message, context={"component_id": component_id})
                    patched_files_count += 1
            except Exception as e:
                self.report(f"----------------------------------------\n[SCAN] Analyzing manifest for: '{component_id}'", "SCAN")
                self._register_finding(f"  [ERROR] -> Could not process manifest for '{component_id}': {e}", "ERROR")
        if patched_files_count == 0:
            self.report("  [OK] -> All component manifests are already complete and well-ordered.", "OK")
        summary = f"Manifest Scan: {patched_files_count} manifests were patched for completeness or consistency."
        self.report(f"[DONE] {summary}", "SUCCESS")
        return summary
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\manifest_mismatch_scan.py
# JUMLAH BARIS : 77
#######################################################################

```py
import os
import json
from .base_scanner import BaseScanner
class ManifestMismatchScan(BaseScanner):
    """
    Scans for discrepancies between the files on disk and the entries in the
    core_integrity.json manifest. This helps detect untracked or missing files.
    """
    def run_scan(self) -> str:
        self.report("\n[SCAN] === Starting Manifest vs. Filesystem Mismatch Scan ===", "SCAN")
        manifest_path = os.path.join(self.kernel.project_root_path, "core_integrity.json")
        if not os.path.exists(manifest_path):
            self._register_finding(
                "  [CRITICAL] -> core_integrity.json manifest file is missing. Cannot perform scan."
            )
            return "Scan failed: Manifest file not found."
        try:
            with open(manifest_path, 'r', encoding='utf-8') as f:
                manifest_files = set(json.load(f).keys())
        except json.JSONDecodeError:
            self._register_finding(
                "  [CRITICAL] -> core_integrity.json is corrupted and cannot be parsed as JSON.",
                context={"file": manifest_path}
            )
            return "Scan failed: Manifest file is corrupted."
        core_dirs_to_scan = [
            "flowork_kernel", "modules", "plugins", "widgets", "ai_providers",
            "triggers", "core_services", "formatters", "themes", "locales"
        ]
        ignore_list = ["__pycache__", ".pyc", "node_modules", ".git", "temp_uploads", "data", "logs", "core_integrity.json"]
        disk_files = set()
        for item in os.listdir(self.kernel.project_root_path):
            item_path = os.path.join(self.kernel.project_root_path, item)
            if os.path.isfile(item_path) and not any(ignored in item for ignored in ignore_list):
                 relative_path = os.path.relpath(item_path, self.kernel.project_root_path).replace(os.sep, '/')
                 disk_files.add(relative_path)
        for core_dir in core_dirs_to_scan:
            full_dir_path = os.path.join(self.kernel.project_root_path, core_dir)
            if not os.path.isdir(full_dir_path):
                continue
            for root, dirs, files in os.walk(full_dir_path):
                dirs[:] = [d for d in dirs if d not in ignore_list]
                for file in files:
                    if any(ignored in file for ignored in ignore_list):
                        continue
                    file_path = os.path.join(root, file)
                    relative_path = os.path.relpath(file_path, self.kernel.project_root_path).replace(os.sep, '/')
                    disk_files.add(relative_path)
        untracked_files = disk_files - manifest_files
        missing_files = manifest_files - disk_files
        if untracked_files:
            for file_path in sorted(list(untracked_files)):
                self._register_finding(
                    f"  [MAJOR] -> Untracked file found on disk but not in manifest: {file_path}. Run generate_integrity_manifest.py to fix.",
                    context={"file": file_path}
                )
        if missing_files:
            for file_path in sorted(list(missing_files)):
                self._register_finding(
                    f"  [CRITICAL] -> Missing file! Listed in manifest but not found on disk: {file_path}.",
                    context={"file": file_path}
                )
        if not untracked_files and not missing_files:
            self.report("  [OK] -> Manifest is perfectly in sync with the filesystem.", "OK")
            summary = "Manifest Integrity Scan: Passed. All files match."
        else:
            summary = f"Manifest Integrity Scan: Found {len(untracked_files)} untracked and {len(missing_files)} missing files."
        self.report(f"[DONE] {summary}", "SUCCESS" if not (untracked_files or missing_files) else "WARN")
        return summary
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\marketplace_integrity_scan.py
# JUMLAH BARIS : 47
#######################################################################

```py
import os
from .base_scanner import BaseScanner
class MarketplaceIntegrityScan(BaseScanner):
    """
    Ensures the Marketplace UI correctly delegates the upload process to the backend
    services, following the decoupled architecture principles.
    This scanner acts as a regression test for the contribution feature's architecture.
    """
    def run_scan(self) -> str:
        self.report("\n[SCAN] === Starting Marketplace Contribution Architecture Scan ===", "SCAN")
        marketplace_page_path = os.path.join(self.kernel.project_root_path, "plugins", "flowork_core_ui", "marketplace_page.py")
        api_client_path = os.path.join(self.kernel.project_root_path, "flowork_kernel", "api_client.py")
        api_server_path = os.path.join(self.kernel.project_root_path, "flowork_kernel", "services", "api_server_service", "api_server_service.py")
        addon_service_path = os.path.join(self.kernel.project_root_path, "flowork_kernel", "services", "community_addon_service", "community_addon_service.py")
        checks = [
            (marketplace_page_path, "self.api_client.upload_component", "Marketplace UI correctly delegates upload to ApiClient."),
            (api_client_path, "requests.post(f\"{self.base_url}/addons/upload\"", "ApiClient correctly calls the /addons/upload endpoint."),
            (api_server_path, "addon_service.upload_component(comp_type, component_id)", "ApiServer correctly routes the request to CommunityAddonService."),
            (addon_service_path, "variable_manager.get_variable('GITHUB_UPLOAD_TOKEN')", "CommunityAddonService handles fetching the GitHub API token."),
            (addon_service_path, "diagnostics_plugin.scan_single_component_and_get_status", "CommunityAddonService handles the pre-flight scan.")
        ]
        checks_passed = 0
        for file_path, check_string, description in checks:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                if check_string in content:
                    checks_passed += 1
                    self.report(f"  [OK] -> {description}", "OK")
                else:
                    self._register_finding(
                        f"  [CRITICAL] -> Architectural Regression! Check failed: '{description}'. The required logic is missing from '{os.path.basename(file_path)}'.",
                        context={"file": file_path}
                    )
            except FileNotFoundError:
                self._register_finding(f"  [CRITICAL] -> Required file for architecture check not found: {os.path.basename(file_path)}", "CRITICAL")
        summary = f"Marketplace Architecture Scan: {checks_passed}/{len(checks)} critical architectural checks passed."
        self.report(f"[DONE] {summary}", "SUCCESS" if checks_passed == len(checks) else "WARN")
        return summary
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\phase_one_integrity_scan.py
# JUMLAH BARIS : 112
#######################################################################

```py
import os
import re
from .base_scanner import BaseScanner
class PhaseOneIntegrityScan(BaseScanner):
    """
    Scans the UI layer to enforce the rules of Phase 1: Total Independence.
    This "Doctor Code" scanner not only finds violations but also attempts to
    auto-patch them by replacing direct kernel calls with their ApiClient equivalents.
    """
    def run_scan(self) -> str:
        self.report("\n[SCAN] === Starting Phase 1: Independence Integrity Scan (Doctor Code Mode) ===", "SCAN")
        ui_paths = [
            os.path.join(self.kernel.project_root_path, "flowork_kernel", "ui_shell"),
            os.path.join(self.kernel.project_root_path, "widgets"),
            os.path.join(self.kernel.project_root_path, "plugins")
        ]
        illegal_pattern = re.compile(r"self\.kernel\.get_service\([\"']([\w_]+)[\"']\)\.([\w_]+)\((.*)\)")
        files_scanned = 0
        total_violations_found = 0
        total_violations_healed = 0
        for path in ui_paths:
            if not os.path.isdir(path):
                continue
            for root, _, files in os.walk(path):
                if 'system_diagnostics_plugin' in root:
                    continue
                for file in files:
                    if file.endswith(".py"):
                        file_path = os.path.join(root, file)
                        files_scanned += 1
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                original_content = f.read()
                            content_to_patch = original_content
                            patches_made_in_file = 0
                            matches = list(illegal_pattern.finditer(original_content))
                            if matches:
                                for match in matches:
                                    total_violations_found += 1
                                    line_num = original_content.count('\n', 0, match.start()) + 1
                                    full_match_text = match.group(0)
                                    self.report(f"  [CRITICAL] -> Found violation in '{os.path.relpath(file_path, self.kernel.project_root_path)}' on line {line_num}:", "CRITICAL", context={"file": file_path, "line": line_num})
                                    self.report(f"    -> Code: {full_match_text}", "DEBUG")
                                    healed_code, patched_content = self._auto_patch_file(file_path, content_to_patch, match)
                                    if healed_code:
                                        self.report(f"    -> [HEALED] Auto-patched to: self.{healed_code}", "SUCCESS")
                                        content_to_patch = patched_content
                                        total_violations_healed += 1
                                        patches_made_in_file += 1
                                    else:
                                        self.report("    -> [MANUAL FIX NEEDED] Could not automatically determine the ApiClient equivalent.", "MAJOR")
                            if patches_made_in_file > 0:
                                with open(file_path, 'w', encoding='utf-8') as f:
                                    f.write(content_to_patch)
                                self.report(f"  -> Saved {patches_made_in_file} patch(es) to '{os.path.basename(file_path)}'.", "INFO")
                        except Exception as e:
                            self.report(f"  [ERROR] -> Could not read or process file: {file_path}. Reason: {e}", "CRITICAL")
        summary = f"Phase 1 Integrity Scan complete. Scanned {files_scanned} files. Found {total_violations_found} violations. Auto-healed {total_violations_healed}."
        self.report(f"[DONE] {summary}", "SUCCESS" if total_violations_found == total_violations_healed else "WARN")
        return summary
    def _auto_patch_file(self, file_path, current_content, match):
        """
        The core healing logic. Takes the file content and a regex match,
        and returns the patched content if successful.
        """
        service_name = match.group(1)
        method_name = match.group(2)
        arguments = match.group(3)
        service_to_api_map = {
            ("preset_manager_service", "get_preset_list"): "get_presets()",
            ("preset_manager_service", "get_preset_data"): f"get_preset_data({arguments})",
            ("module_manager_service", "get_manifest"): f"get_components('modules', {arguments})", # This is an approximation
            ("localization_manager", "get_setting"): f"get_all_settings()", # API gets all settings
        }
        api_equivalent_key = (service_name, method_name)
        if api_equivalent_key not in service_to_api_map:
            return None, current_content # Cannot heal automatically
        api_call = service_to_api_map[api_equivalent_key]
        new_code = f"api_client.{api_call}" # Assuming the instance is named self.api_client
        line_start_index = current_content.rfind('\n', 0, match.start()) + 1
        line_end_index = current_content.find('\n', match.end())
        line_content = current_content[line_start_index:line_end_index]
        assignment_match = re.match(r"(\s*)(([\w\s,]+)\s*=\s*)", line_content)
        if assignment_match:
            prefix = assignment_match.group(1) + assignment_match.group(2)
            new_line = prefix + f"self.{new_code}"
        else:
            prefix = re.match(r"(\s*)", line_content).group(1)
            new_line = prefix + f"self.{new_code}"
        patched_content = current_content.replace(match.group(0), new_code) # Use the simpler replacement for now
        import_str = "from flowork_kernel.api_client import ApiClient"
        if import_str not in patched_content:
            patched_content = import_str + "\n" + patched_content
        init_pattern = re.compile(r"def\s+__init__\(self,[^)]*\):")
        init_match = init_pattern.search(patched_content)
        instantiation_str = "self.api_client = ApiClient()"
        if init_match and instantiation_str not in patched_content:
            init_end = init_match.end()
            first_line_break = patched_content.find('\n', init_end)
            indentation_match = re.search(r"(\n\s+)", patched_content[first_line_break:])
            indentation = indentation_match.group(1) if indentation_match else "\n        "
            injection_point = first_line_break + 1
            patched_content = patched_content[:injection_point] + indentation + instantiation_str + patched_content[injection_point:]
        return new_code, patched_content
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\processor.py
# JUMLAH BARIS : 143
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import Text, scrolledtext, messagebox
import threading
import time
import queue
import os
import re
import json
import importlib
import inspect
from flowork_kernel.api_contract import BaseUIProvider, BaseModule
from .base_scanner import BaseScanner
from .diagnostics_page import DiagnosticsPage
class SystemDiagnosticsUIProvider(BaseUIProvider, BaseModule):
    TIER = "free"  # ADDED BY SCANNER: Default tier
    """
    Mendaftarkan halaman Diagnostik ke UI utama Flowork.
    Menjadi koordinator untuk semua jenis scan.
    """
    _BENTENG_BAJA_ID = "0xDIAGNOSTICS_CORE_COMPONENT"
    def __init__(self, module_id, services):
        super().__init__(module_id, services)
    def execute(self, payload, config, status_updater, ui_callback, mode='EXECUTE'):
        return payload
    def get_ui_tabs(self):
        """
        Provides the Diagnostics Page as a new main tab to the Kernel.
        """
        self.logger("SystemDiagnosticsPlugin: Providing 'DiagnosticsPage' to the main UI.", "DEBUG") # English Log
        return [
            {
                'key': 'system_diagnostics',
                'title': self.loc.get('diagnostics_tab_title', fallback="Diagnostik Sistem"),
                'frame_class': DiagnosticsPage
            }
        ]
    def get_menu_items(self):
        """
        Adds a menu item to open the diagnostics tab.
        """
        return [
            {
                "parent": self.loc.get('menu_help', fallback="Bantuan"),
                "add_separator": True,
                "label": self.loc.get('diagnostics_tab_title', fallback="Diagnostik Sistem"),
                "command": lambda: self.kernel.get_service("tab_manager_service").open_managed_tab('system_diagnostics')
            }
        ]
    def scan_single_component_and_get_status(self, component_path: str) -> (bool, str):
        """
        Runs all relevant scans on a single component directory and returns a simple pass/fail status.
        """
        self.logger(f"DIAGNOSTICS: Performing targeted scan on path: {component_path}", "INFO") # English Log
        all_scanners = self._discover_scanners()
        scanners_to_run = all_scanners
        all_findings = []
        def report_handler(message, level, context=None):
            if level in ["CRITICAL", "MAJOR", "MINOR"]:
                all_findings.append({"level": level, "message": message})
        for scanner_class in scanners_to_run:
            try:
                scanner_instance = scanner_class(self.kernel, report_handler)
                if hasattr(scanner_instance, 'set_target_path'):
                    scanner_instance.set_target_path(component_path)
                scanner_instance.run_scan()
            except Exception as e:
                all_findings.append({"level": "CRITICAL", "message": f"Scanner {scanner_class.__name__} failed: {e}"})
        critical_or_major_issues = [f for f in all_findings if f['level'] in ['CRITICAL', 'MAJOR']]
        if not critical_or_major_issues:
            return True, "All critical and major checks passed."
        else:
            report = "\n".join([f"- {f['level']}: {f['message']}" for f in critical_or_major_issues])
            return False, f"Scan failed with the following issues:\n{report}"
    def _discover_scanners(self):
        """Helper to discover all available scanner classes."""
        all_scanners = []
        scanners_dir = os.path.join(self.kernel.project_root_path, 'scanners')
        if os.path.isdir(scanners_dir):
            for entry in os.scandir(scanners_dir):
                if entry.name.endswith('.py') and not entry.name.startswith('__'):
                    module_name = f"scanners.{entry.name[:-3]}"
                    try:
                        module = importlib.import_module(module_name)
                        for name, obj in inspect.getmembers(module, inspect.isclass):
                            if issubclass(obj, BaseScanner) and obj is not BaseScanner:
                                all_scanners.append(obj)
                    except Exception as e:
                        self.logger(f"Diagnostics: Failed to import scanner from '{entry.name}': {e}", "ERROR") # English Log
                        pass
        return all_scanners
    def start_scan_headless(self, scan_id: str, target_scanner_id: str = None) -> dict:
        """
        Runs all or a specific scanner module synchronously and returns a dictionary with the results.
        This is designed to be called by an API endpoint.
        """
        log_target = 'ALL' if not target_scanner_id else target_scanner_id.upper()
        self.logger(f"API-DIAG: Starting Headless Scan for ID: {scan_id} (Target: {log_target})", "INFO") # English Log
        report_lines = []
        def headless_report_handler(message, level, context=None): # Added context to match signature
            report_lines.append(f"[{level}] {message}")
        summaries = []
        all_scanners = self._discover_scanners()
        if not all_scanners:
            headless_report_handler("Tidak ada modul scanner yang ditemukan.", "ERROR")
        scanners_to_run = []
        if target_scanner_id:
            found = False
            for scanner_class in all_scanners:
                class_id = re.sub(r'([a-z0-9])([A-Z])', r'\1_\2', scanner_class.__name__.replace("Core", "")).lower()
                class_id = class_id.replace("_scan", "")
                if class_id == target_scanner_id:
                    scanners_to_run.append(scanner_class)
                    found = True
                    break
            if not found:
                headless_report_handler(f"Scanner dengan ID '{target_scanner_id}' tidak ditemukan.", "ERROR")
        else:
            scanners_to_run = all_scanners
        for scanner_class in scanners_to_run:
            try:
                scanner_instance = scanner_class(self.kernel, headless_report_handler)
                summary = scanner_instance.run_scan()
                summaries.append(summary)
            except Exception as e:
                summary = f"FATAL ERROR while running {scanner_class.__name__}: {e}"
                summaries.append(summary)
                headless_report_handler(summary, "ERROR")
        full_report_str = "\n".join(report_lines)
        final_summary = "\n".join(summaries)
        result_data = {
            "scan_id": scan_id, "status": "completed", "timestamp": time.time(),
            "summary": final_summary, "full_log": full_report_str
        }
        self.logger(f"API-DIAG: Scan {scan_id} selesai. Mengembalikan hasil.", "SUCCESS")
        return result_data
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\tier_attribute_scan.py
# JUMLAH BARIS : 53
#######################################################################

```py
import os
import re
from .base_scanner import BaseScanner
class TierAttributeScanCore(BaseScanner):
    """
    Ensures that every component's main class has a TIER attribute.
    This is critical for controlling access to free vs. premium features at the code level.
    [V3 - FINAL] This version NO LONGER auto-patches files. It only reports the issue,
    adhering to the principle that a diagnostic tool should not modify source code.
    """
    def run_scan(self) -> str:
        self.report("\n[INFO] === Starting Tier Attribute Scan (V3 - Reporting Mode) ===", "INFO")
        module_manager = self.kernel.get_service("module_manager_service")
        widget_manager = self.kernel.get_service("widget_manager_service")
        if not module_manager or not widget_manager:
            self._register_finding("  [ERROR] -> Core services (ModuleManager, WidgetManager) not found!", "CRITICAL")
            return "Scan Failed: Core service missing."
        all_components = {**module_manager.loaded_modules, **widget_manager.loaded_widgets}
        missing_tier_count = 0
        for component_id, data in all_components.items():
            manifest = data.get("manifest", {})
            entry_point = manifest.get("entry_point")
            component_path = data.get("path")
            if not all([entry_point, component_path]):
                continue
            try:
                module_filename, class_name = entry_point.split('.')
                processor_path = os.path.join(component_path, f"{module_filename}.py")
                if not os.path.exists(processor_path):
                    continue
                with open(processor_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                tier_pattern = re.compile(rf"class\s+{re.escape(class_name)}[^:]*:\s*\n\s*TIER\s*=")
                if not tier_pattern.search(content):
                    message = (f"  [MAJOR] -> Module '{component_id}' is missing the required 'TIER' class attribute.")
                    self._register_finding(message, context={"component_id": component_id, "file": processor_path})
                    missing_tier_count += 1
            except Exception as e:
                self.report(f"----------------------------------------\n[SCAN] Analyzing code for: '{component_id}'", "SCAN")
                self._register_finding(f"  [ERROR] -> Could not process processor file for '{component_id}': {e}", "ERROR")
        if missing_tier_count == 0:
            self.report("  [OK] -> All components have a TIER attribute.", "OK")
        summary = f"Tier Attribute Scan: Found {missing_tier_count} components missing the TIER attribute."
        self.report(f"[DONE] {summary}", "SUCCESS" if missing_tier_count == 0 else "WARN")
        return summary
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\locales\en.json
# JUMLAH BARIS : 8
#######################################################################

```json
{
    "diagnostics_tab_title": "System Diagnostics",
    "diagnostics_copy_results_button": "Copy Scan Results",
    "diagnostics_log_copied_success": "SUCCESS: Diagnostics report copied to clipboard.",
    "scan_title_generic_exception": "Starting Generic Exception Raise Scan",
    "scan_title_unaudited_action": "Starting Unaudited Critical Action Scan",
    "scan_title_phase_one_integrity": "Starting Phase 1: Independence Integrity Scan"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scanners\locales\id.json
# JUMLAH BARIS : 8
#######################################################################

```json
{
    "diagnostics_tab_title": "Diagnostik Sistem",
    "diagnostics_copy_results_button": "Salin Hasil Scan",
    "diagnostics_log_copied_success": "SUKSES: Laporan diagnostik disalin ke clipboard.",
    "scan_title_generic_exception": "Memulai Pemindaian Pengecualian Generik",
    "scan_title_unaudited_action": "Memulai Pemindaian Aksi Kritis Tanpa Audit",
    "scan_title_phase_one_integrity": "Memulai Pemindaian Integritas Fase 1"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scripts\bootstrap.py
# JUMLAH BARIS : 60
#######################################################################

```py
import subprocess
import sys
import os
import time
def main():
    """
    This script is the user-facing dependency installer.
    It reads the requirements.txt file and uses the bundled python's pip
    to install all necessary libraries.
    """
    project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    python_exe = os.path.join(project_root, "python", "python.exe")
    requirements_file = os.path.join(project_root, "requirements.txt")
    first_run_lock_file = os.path.join(project_root, "data", ".first_run_complete")
    print("--- Flowork First-Time Setup ---")
    if not os.path.exists(python_exe):
        print(f"[FATAL] Bundled Python not found at: {python_exe}")
        return
    if not os.path.exists(requirements_file):
        print(f"[FATAL] requirements.txt not found at: {requirements_file}")
        return
    print(f"[INFO] Installing dependencies from {os.path.basename(requirements_file)}...")
    print("[INFO] This may take several minutes depending on your internet speed. Please be patient.")
    try:
        command = [
            python_exe, "-m", "pip", "install",
            "--no-cache-dir", # Ensures fresh downloads
            "--no-warn-script-location",
            "-r", requirements_file
        ]
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, encoding='utf-8', errors='replace')
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                print(f"  {output.strip()}")
        if process.returncode != 0:
            raise subprocess.CalledProcessError(process.returncode, command)
        print("\n[SUCCESS] All libraries installed successfully!")
        os.makedirs(os.path.dirname(first_run_lock_file), exist_ok=True)
        with open(first_run_lock_file, 'w') as f:
            f.write(str(time.time()))
        print("[SUCCESS] First-time setup is complete.")
    except Exception as e:
        print(f"\n[FATAL ERROR] An error occurred during library installation: {e}")
        print("Please check your internet connection and try running the launcher again.")
        if os.path.exists(first_run_lock_file):
            os.remove(first_run_lock_file)
        input("\nPress Enter to exit...")
if __name__ == "__main__":
    main()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scripts\build_engine.py
# JUMLAH BARIS : 145
#######################################################################

```py
import os
import sys
import subprocess
import shutil
import time
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
COMPILATION_MAP = {
    "flowork_kernel/services":                            ".service",
    "flowork_kernel/kernel_logic.py":                     ".kernel",
    "flowork_kernel/api_contract.py":                     ".kernel",
    "flowork_kernel/core/permission_hook.py":             ".kernel",
    "flowork_kernel/execution/CheckpointManager.py":      ".kernel",
    "flowork_kernel/execution/LoopHandler.py":            ".kernel",
    "flowork_kernel/execution/RetryHandler.py":           ".kernel",
    "flowork_kernel/execution/VariableResolver.py":       ".kernel",
    "flowork_kernel/ui_shell/authentication_dialog.py":   ".kernel",
    "flowork_kernel/ui_shell/main_window.py":             ".kernel",
    "flowork_kernel/ui_shell/ui_components/menubar_manager.py": ".kernel",
    "plugins/flowork_core_ui/marketplace_page.py":        ".aola",
    "plugins/flowork_core_ui/pricing_page.py":            ".aola",
    "plugins/flowork_core_ui/settings_components/license_management_frame.py": ".aola",
    "ai_providers/text/gemini_provider/core/GeminiConnection.py":           ".ai",
    "ai_providers/text/chatgpt_provider/core/ChatGPTConnection.py":       ".ai",
    "launcher.py":                                        ".flow",
    "pre_launcher.py":                                    ".flow"
}
EXCLUDE_LIST = [
    "auto_compiler_service.py",
    "startup_service.py",
    "integrity_checker_service.py",
    "license_manager_service.py",
    os.path.join(PROJECT_ROOT, "flowork_kernel", "kernel.py"),
    os.path.join(PROJECT_ROOT, "flowork_kernel", "api_client.py"),
    os.path.join(PROJECT_ROOT, "scripts", "build_engine.py")
]
NUITKA_BASE_COMMAND = [
    sys.executable,
    "-m", "nuitka",
    "--module",
    "--remove-output",
    "--windows-console-mode=disable",
    "--lto=yes",
    "--python-flag=-OO",
    "--include-package=scanners"
]
def compile_file(file_path, target_extension):
    """Compiles a single Python file and then deletes the source .py and .pyi files."""
    rel_path = os.path.relpath(file_path, PROJECT_ROOT)
    print(f"  -> Compiling: {rel_path} -> {target_extension}")
    is_launcher_stub = os.path.basename(file_path) in ["launcher.py", "pre_launcher.py"]
    if is_launcher_stub:
        temp_dir = os.path.join(PROJECT_ROOT, "temp_build")
        os.makedirs(temp_dir, exist_ok=True)
        temp_file_path = os.path.join(temp_dir, os.path.basename(file_path))
        shutil.copy2(file_path, temp_file_path)
        path_to_compile = temp_file_path
        output_dir = os.path.dirname(file_path)
    else:
        path_to_compile = file_path
        output_dir = os.path.dirname(file_path)
    command = NUITKA_BASE_COMMAND + [f"--output-dir={output_dir}", path_to_compile]
    try:
        subprocess.run(command, check=True, capture_output=True, text=True, cwd=PROJECT_ROOT, shell=True)
        original_filename_base = os.path.splitext(os.path.basename(path_to_compile))[0]
        compiled_ext = ".pyd" if sys.platform == "win32" else ".so"
        target_file = os.path.join(output_dir, f"{original_filename_base}{target_extension}")
        generated_file = None
        for file in os.listdir(output_dir):
            if file.startswith(original_filename_base) and file.endswith(compiled_ext):
                generated_file = os.path.join(output_dir, file)
                break
        if generated_file and os.path.exists(generated_file):
            if os.path.exists(target_file):
                os.remove(target_file)
            os.rename(generated_file, target_file)
            print(f"  [SUCCESS] Created: {os.path.basename(target_file)}")
            if not is_launcher_stub:
                try:
                    pyi_file = os.path.splitext(file_path)[0] + '.pyi'
                    if os.path.exists(pyi_file):
                        os.remove(pyi_file)
                    os.remove(file_path)
                except OSError as e:
                    print(f"  [WARNING] Could not delete source/stub files for '{rel_path}': {e}")
            return True
        else:
            print(f"  [ERROR] Nuitka did not produce the expected output file for '{rel_path}'")
            return False
    except subprocess.CalledProcessError as e:
        print(f"  [FATAL] Nuitka compilation FAILED for '{rel_path}'.")
        print(f"  --- Nuitka Error Output ---\n{e.stderr}\n  ---------------------------")
        return False
    except Exception as e:
        print(f"  [FATAL] An unexpected error occurred during compilation of '{rel_path}': {e}")
        return False
    finally:
        if 'temp_dir' in locals() and os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)
def main():
    print("--- Flowork Multi-Target Build Engine (with Source Deletion) ---")
    files_to_compile = []
    absolute_exclude_set = {os.path.abspath(p) for p in EXCLUDE_LIST}
    for path, ext in COMPILATION_MAP.items():
        full_path = os.path.join(PROJECT_ROOT, path)
        if os.path.isdir(full_path):
            for root, _, files in os.walk(full_path):
                for file in files:
                    file_abs_path = os.path.abspath(os.path.join(root, file))
                    if file.endswith('.py') and not file.startswith('__') and file_abs_path not in absolute_exclude_set:
                        files_to_compile.append((file_abs_path, ext))
        elif os.path.isfile(full_path):
            if os.path.abspath(full_path) not in absolute_exclude_set:
                files_to_compile.append((full_path, ext))
    if not files_to_compile:
        print("  -> No files found to compile based on the map.")
        return
    success_count = 0
    fail_count = 0
    start_time = time.time()
    print(f"\n[INFO] Found {len(files_to_compile)} files to compile...")
    for file_path, target_ext in sorted(files_to_compile, key=lambda x: x[0]):
        if compile_file(file_path, target_ext):
            success_count += 1
        else:
            fail_count += 1
    end_time = time.time()
    duration = end_time - start_time
    print("\n--- Build Summary ---")
    print(f"  Total time: {duration:.2f} seconds")
    print(f"  Successfully compiled: {success_count} files")
    print(f"  Failed to compile: {fail_count} files")
    if fail_count > 0:
        print("\n[WARNING] Some services failed to compile. The application may be unstable.")
    else:
        print("\n[SUCCESS] All targeted files compiled successfully!")
if __name__ == "__main__":
    main()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scripts\dependency_audit.py
# JUMLAH BARIS : 123
#######################################################################

```py
import os
import re
import ast
try:
    import toml
except ImportError:
    print("ERROR: 'toml' library is not installed. Please run 'poetry install' in your terminal.") # English log
    exit()
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
COMPONENT_BASE_DIRS = ['modules', 'plugins', 'widgets', 'triggers', 'ai_providers', 'formatters']
def get_global_dependencies():
    """
    Reads pyproject.toml to get a list of global dependencies and their correct versions.
    This acts as the master dictionary for the auditor.
    """
    pyproject_path = os.path.join(PROJECT_ROOT, 'pyproject.toml')
    if not os.path.exists(pyproject_path):
        print("[ERROR] pyproject.toml not found!") # English log
        return {}, {}
    print("[INFO] Reading global dependencies from pyproject.toml...") # English log
    with open(pyproject_path, 'r', encoding='utf-8') as f:
        data = toml.load(f)
    deps = data.get('tool', {}).get('poetry', {}).get('dependencies', {})
    dep_map = {}
    for pkg, version_info in deps.items():
        if pkg.lower() == 'python':
            continue
        if isinstance(version_info, dict):
            dep_map[pkg] = f"{pkg}{version_info.get('version', '*')}"
        else:
            dep_map[pkg] = f"{pkg}{version_info}"
    import_to_package_map = {
        "bs4": "beautifulsoup4",
        "PIL": "pillow",
        "google.generativeai": "google-generativeai",
        "selenium": "selenium",
        "webdriver_manager": "webdriver-manager",
        "dotenv": "python-dotenv",
        "mss": "mss",
        "pyaudio": "PyAudio",
        "torch": "torch",
        "torchvision": "torchvision",
        "torchaudio": "torchaudio",
        "transformers": "transformers",
        "diffusers": "diffusers",
        "accelerate": "accelerate",
        "safetensors": "safetensors",
        "sentence_transformers": "sentence-transformers",
        "llama_cpp": "llama-cpp-python",
        "pandas": "pandas",
        "openpyxl": "openpyxl" # Added openpyxl for excel module
    }
    print(f"[SUCCESS] Found {len(dep_map)} global packages.") # English log
    return dep_map, import_to_package_map
def find_imports_in_file(file_path):
    """Parses a Python file using AST and returns a set of imported top-level modules."""
    imports = set()
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            tree = ast.parse(content)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        imports.add(alias.name.split('.')[0])
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        imports.add(node.module.split('.')[0])
    except Exception as e:
        print(f"  [WARN] Could not parse {os.path.basename(file_path)}: {e}") # English log
        pass
    return imports
def main():
    print("--- Starting Dependency Audit & Auto-Fix Script ---") # English log
    global_deps, import_map = get_global_dependencies()
    fixed_components = 0
    for base_dir in COMPONENT_BASE_DIRS:
        full_base_path = os.path.join(PROJECT_ROOT, base_dir)
        if not os.path.isdir(full_base_path):
            continue
        print(f"\n--- Scanning Directory: '{base_dir}' ---") # English log
        for component_name in os.listdir(full_base_path):
            component_path = os.path.join(full_base_path, component_name)
            if not os.path.isdir(component_path) or component_name == '__pycache__':
                continue
            found_deps_for_component = set()
            for root, _, files in os.walk(component_path):
                for file in files:
                    if file.endswith('.py'):
                        file_path = os.path.join(root, file)
                        imports = find_imports_in_file(file_path)
                        for imp in imports:
                            package_name = import_map.get(imp, imp)
                            if package_name in global_deps:
                                found_deps_for_component.add(package_name)
            if found_deps_for_component:
                print(f"[FIXING] -> Component '{component_name}' has undeclared/missing dependencies.") # English log
                fixed_components += 1
                requirements_path = os.path.join(component_path, 'requirements.txt')
                try:
                    with open(requirements_path, 'w', encoding='utf-8') as f:
                        for dep_name in sorted(list(found_deps_for_component)):
                            full_dep_string = global_deps[dep_name]
                            f.write(f"{full_dep_string}\n")
                            print(f"    -> Added '{full_dep_string}' to its new requirements.txt") # English log
                    print(f"[SUCCESS] -> Created/Updated requirements.txt for '{component_name}'.") # English log
                except IOError as e:
                    print(f"[ERROR] -> Could not write requirements.txt for '{component_name}': {e}") # English log
    print("\n--- Audit Complete ---") # English log
    if fixed_components > 0:
        print(f"[SUCCESS] {fixed_components} components were auto-fixed with a new 'requirements.txt'.") # English log
    else:
        print("[SUCCESS] All components appear to have their dependencies in order.") # English log
if __name__ == "__main__":
    main()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scripts\generate_docs.py
# JUMLAH BARIS : 245
#######################################################################

```py
import os
import json
import shutil
import re
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
LANGUAGES = ['id', 'en']
DEFAULT_LANG = 'en'
COMPONENT_DIRS = ['modules', 'plugins', 'widgets', 'triggers', 'ai_providers']
DOCS_DIR = os.path.join(PROJECT_ROOT, 'docs')
def ensure_packages_are_importable():
    print("[INFO] Ensuring component directories are importable...")
    for comp_dir in COMPONENT_DIRS:
        init_path = os.path.join(PROJECT_ROOT, comp_dir, '__init__.py')
        if not os.path.exists(init_path):
            try:
                with open(init_path, 'w') as f:
                    pass
                print(f"  -> Created: {os.path.relpath(init_path, PROJECT_ROOT)}")
            except Exception as e:
                print(f"  [WARNING] Could not create __init__.py in '{comp_dir}': {e}")
        full_comp_dir_path = os.path.join(PROJECT_ROOT, comp_dir)
        if os.path.isdir(full_comp_dir_path):
            for item_name in os.listdir(full_comp_dir_path):
                item_path = os.path.join(full_comp_dir_path, item_name)
                if os.path.isdir(item_path):
                    sub_init_path = os.path.join(item_path, '__init__.py')
                    if not os.path.exists(sub_init_path):
                        try:
                            with open(sub_init_path, 'w') as f:
                                pass
                        except Exception as e:
                            print(f"  [WARNING] Could not create __init__.py in '{item_path}': {e}")
def load_translations(lang_code: str) -> dict:
    translations = {}
    for dir_path, _, filenames in os.walk(PROJECT_ROOT):
        if 'locales' in dir_path:
            lang_file = os.path.join(dir_path, f"{lang_code}.json")
            if os.path.exists(lang_file):
                try:
                    with open(lang_file, 'r', encoding='utf-8') as f:
                        translations.update(json.load(f))
                except json.JSONDecodeError:
                    print(f"[WARNING] Could not parse JSON from: {lang_file}")
    return translations
def _generate_markdown_table(headers, rows):
    header_line = "| " + " | ".join(headers) + " |"
    separator_line = "| " + " | ".join(["---"] * len(headers)) + " |"
    row_lines = []
    for row in rows:
        cleaned_row = [str(cell).replace('|', '\\|').replace('\n', '<br>') for cell in row]
        row_lines.append("| " + " | ".join(cleaned_row) + " |")
    return "\n".join([header_line, separator_line] + row_lines)
def generate_component_doc(component_dir: str, component_id: str, manifest: dict, lang: str, translations: dict) -> dict:
    name = translations.get(manifest.get('name_key'), manifest.get('name', component_id))
    description = translations.get(manifest.get('description_key'), manifest.get('description', ''))
    tutorial = translations.get(manifest.get('tutorial_key'), '')
    entry_point = manifest.get('entry_point', '')
    tier = manifest.get('tier', 'free').capitalize()
    version = manifest.get('version', '1.0')
    author = manifest.get('author', 'N/A')
    md_content = f"# {name}\n\n"
    md_content += f"> {description}\n\n"
    meta_headers = ["Attribute", "Value"]
    meta_rows = [
        ["ID", f"`{component_id}`"],
        ["Tier", tier],
        ["Version", version],
        ["Author", author]
    ]
    md_content += "## Metadata\n\n"
    md_content += _generate_markdown_table(meta_headers, meta_rows) + "\n\n"
    if tutorial:
        md_content += f"## How to Use\n{tutorial}\n\n"
    properties = manifest.get('properties', [])
    if properties:
        prop_headers = ["ID (`config`)", "Label", "Type", "Default Value"]
        prop_rows = []
        for prop in properties:
            prop_id = prop.get('id', 'N/A')
            prop_label_key = prop.get('label', '')
            prop_label = translations.get(prop_label_key, prop_label_key)
            prop_type = prop.get('type', 'string')
            prop_default = prop.get('default', '')
            prop_rows.append([f"`{prop_id}`", prop_label, f"`{prop_type}`", f"`{prop_default}`"])
        md_content += "## Configuration Properties\n\n"
        md_content += _generate_markdown_table(prop_headers, prop_rows) + "\n\n"
    output_ports = manifest.get('output_ports', [])
    if output_ports:
        port_headers = ["Port Name", "Display Name"]
        port_rows = []
        for port in output_ports:
            port_name = port.get('name', 'N/A')
            port_display_key = port.get('display_name', '')
            port_display = translations.get(port_display_key, port_display_key)
            port_rows.append([f"`{port_name}`", port_display])
        md_content += "## Output Ports\n\n"
        md_content += _generate_markdown_table(port_headers, port_rows) + "\n\n"
    output_schema = manifest.get('output_schema', [])
    if output_schema:
        if isinstance(output_schema, list) and all(isinstance(item, dict) for item in output_schema):
            schema_headers = ["Payload Path (`data.key`)", "Data Type", "Description"]
            schema_rows = []
            for schema in output_schema:
                schema_name = schema.get('name', 'N/A')
                schema_type = schema.get('type', 'any')
                schema_desc = schema.get('description', '')
                schema_rows.append([f"`{schema_name}`", f"`{schema_type}`", schema_desc])
            md_content += "## Output Data Schema\n\nThis module adds the following keys to `payload['data']`:\n\n"
            md_content += _generate_markdown_table(schema_headers, schema_rows) + "\n\n"
        else:
            md_content += "## Output Data Schema\n\nThis module has a non-standard output schema:\n\n"
            md_content += f"```json\n{json.dumps(output_schema, indent=2)}\n```\n\n"
    python_path_for_docstring = ""
    if entry_point:
        processor_module_path = entry_point.split('.')[0]
        python_path_for_docstring = f"{component_dir}.{component_id}.{processor_module_path}"
        md_content += f"## API Reference\n\n::: {python_path_for_docstring}\n"
    lang_path_segment = "" if lang == DEFAULT_LANG else lang
    doc_filename = f"{component_id}.md"
    output_path = os.path.join(DOCS_DIR, lang_path_segment, 'reference', component_dir, doc_filename)
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(md_content)
    nav_path = os.path.join('reference', component_dir, doc_filename).replace('\\', '/')
    return {name: nav_path}
def main():
    print("[INFO] Starting automatic documentation generation...")
    ensure_packages_are_importable()
    if os.path.exists(DOCS_DIR):
        shutil.rmtree(DOCS_DIR)
    os.makedirs(DOCS_DIR)
    print(f"[INFO] Cleaned up and recreated docs directory at: {DOCS_DIR}")
    nav_paths = {comp_dir: [] for comp_dir in COMPONENT_DIRS}
    for lang in LANGUAGES:
        print(f"--- Generating for language: '{lang}' ---")
        translations = load_translations(lang)
        lang_path_segment = "" if lang == DEFAULT_LANG else lang
        lang_dir = os.path.join(DOCS_DIR, lang_path_segment)
        os.makedirs(lang_dir, exist_ok=True)
        guides_dir = os.path.join(lang_dir, 'guides')
        os.makedirs(guides_dir, exist_ok=True)
        with open(os.path.join(lang_dir, 'index.md'), 'w', encoding='utf-8') as f:
            f.write(f'# {translations.get("doc_homepage_title", "Flowork Documentation")}')
        for comp_dir in COMPONENT_DIRS:
            full_path = os.path.join(PROJECT_ROOT, comp_dir)
            if not os.path.isdir(full_path):
                continue
            for component_id in sorted(os.listdir(full_path)):
                component_path = os.path.join(full_path, component_id)
                if os.path.isdir(component_path) and component_id != '__pycache__':
                    manifest_path = os.path.join(component_path, 'manifest.json')
                    if os.path.exists(manifest_path):
                        with open(manifest_path, 'r', encoding='utf-8') as f:
                            manifest = json.load(f)
                        nav_entry = generate_component_doc(comp_dir, component_id, manifest, lang, translations)
                        if lang == DEFAULT_LANG:
                            nav_paths[comp_dir].append(nav_entry)
    print("--- Generating mkdocs.yml configuration ---")
    config_lines = [
        "# This file is auto-generated by scripts/generate_docs.py",
        "# Do not edit manually.",
        "",
        "site_name: Flowork - Documentation",
        "site_url: https://www.teetah.art/flowork/docs/",
        "repo_url: https://github.com/FLOWORK-gif/FLOWORK",
        "repo_name: FLOWORK-gif/FLOWORK",
        "",
        "theme:",
        f"  name: material",
        f"  language: {DEFAULT_LANG}",
        "  features:",
        "    - navigation.tabs",
        "    - navigation.sections",
        "    - content.code.copy",
        "    - search.suggest",
        "  palette:",
        "    scheme: slate",
        "    primary: indigo",
        "    accent: blue",
        "",
        "extra:",
        "  alternate:"
    ]
    for lang in LANGUAGES:
        lang_name = "Bahasa Indonesia" if lang == "id" else "English"
        link = f"./{lang}/"
        config_lines.append(f"    - name: {lang_name}")
        config_lines.append(f"      link: {link}")
        config_lines.append(f"      lang: {lang}")
    config_lines.append("")
    config_lines.append("nav:")
    config_lines.append("  - Home: index.md")
    config_lines.append("  - API Guides:")
    config_lines.append("    - Introduction: guides/introduction.md")
    config_lines.append("    - Getting Started: guides/getting-started.md")
    config_lines.append("    - Authentication: guides/authentication.md")
    config_lines.append("    - Practical Scenarios: guides/scenarios.md")
    config_lines.append("    - Best Practices: guides/best-practices.md")
    config_lines.append("  - Component Reference:")
    config_lines.append("    - Introduction: reference/index.md")
    for comp_dir, nav_entries in nav_paths.items():
        if nav_entries:
            dir_name_pretty = comp_dir.replace('_', ' ').title()
            config_lines.append(f"    - {dir_name_pretty}:")
            for entry in sorted(nav_entries, key=lambda x: list(x.keys())[0]):
                for name, path in entry.items():
                    safe_name = name.replace("'", "''")
                    config_lines.append(f"      - '{safe_name}': {path}")
    config_lines.extend([
        "",
        "plugins:",
        "  - search",
        "  - mkdocstrings:",
        "      handlers:",
        "        python:",
        "          options:",
        "            show_source: false",
        "            docstring_style: google",
        "            show_root_heading: true",
        "            members_order: source",
        "            # [PERBAIKAN] Memindahkan 'paths' ke dalam 'extra' untuk mengikuti standar baru",
        "            extra:",
        "              paths: [., modules, plugins, widgets, triggers, ai_providers]"
    ])
    mkdocs_config = "\n".join(config_lines)
    with open(os.path.join(PROJECT_ROOT, 'mkdocs.yml'), 'w', encoding='utf-8') as f:
        f.write(mkdocs_config)
    for lang in LANGUAGES:
        lang_path_segment = "" if lang == DEFAULT_LANG else lang
        ref_index_path = os.path.join(DOCS_DIR, lang_path_segment, 'reference', 'index.md')
        os.makedirs(os.path.dirname(ref_index_path), exist_ok=True)
        with open(ref_index_path, 'w', encoding='utf-8') as f:
            f.write("# Component Reference\n\nThis section provides a detailed, auto-generated reference for every component available in Flowork.")
    print("\n[SUCCESS] Documentation generation complete!")
    print("To view your documentation, run 'poetry run mkdocs serve' in your terminal.")
if __name__ == "__main__":
    main()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\scripts\setup.py
# JUMLAH BARIS : 119
#######################################################################

```py
import os
import sys
import subprocess
import shutil
import hashlib
import json
import stat
import time
LIBS_FOLDER = "libs"
VENV_FOLDER = ".venv"
PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
LOCK_FILE_PATH = os.path.join(PROJECT_ROOT, "poetry.lock")
STATE_FILE_PATH = os.path.join(PROJECT_ROOT, "data", "dependency_state.json")
def verbose_rmtree(path):
    """
    (MODIFIED) rmtree version that is more informative and resilient.
    It now returns True on success and False on failure.
    """
    path = os.path.abspath(path)
    if not os.path.exists(path):
        return True # Considered a success if it doesn't exist
    time.sleep(0.5)
    had_error = False
    for root, dirs, files in os.walk(path, topdown=False):
        for name in files:
            filepath = os.path.join(root, name)
            try:
                os.chmod(filepath, stat.S_IWRITE)
                os.unlink(filepath)
            except OSError:
                had_error = True
        for name in dirs:
            dirpath = os.path.join(root, name)
            try:
                shutil.rmtree(dirpath)
            except OSError:
                had_error = True
    try:
        shutil.rmtree(path)
    except OSError:
         had_error = True
    return not had_error
def run_command(command, message):
    """
    (MODIFIED) Runs a command and now ensures it's completely silent when run from the main app.
    """
    creation_flags = 0
    if sys.platform == "win32":
        creation_flags = subprocess.CREATE_NO_WINDOW
    try:
        process = subprocess.Popen(
            command,
            cwd=PROJECT_ROOT,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE, # (MODIFIED) Capture stderr as well
            text=True,
            encoding='utf-8',
            errors='replace',
            shell=True,
            creationflags=creation_flags # (ADDED) Apply the silent flag
        )
        stdout, stderr = process.communicate()
        if process.returncode != 0:
            return False
        return True
    except (FileNotFoundError, subprocess.CalledProcessError):
        return False
def get_lock_hash():
    if not os.path.exists(LOCK_FILE_PATH): return None
    return hashlib.md5(open(LOCK_FILE_PATH,'rb').read()).hexdigest()
def get_last_install_hash():
    if not os.path.exists(STATE_FILE_PATH): return None
    try:
        with open(STATE_FILE_PATH, 'r') as f:
            return json.load(f).get('lock_hash')
    except (IOError, json.JSONDecodeError):
        return None
def save_current_install_hash(lock_hash):
    os.makedirs(os.path.dirname(STATE_FILE_PATH), exist_ok=True)
    with open(STATE_FILE_PATH, 'w') as f:
        json.dump({'lock_hash': lock_hash}, f)
def main():
    os.chdir(PROJECT_ROOT)
    current_hash = get_lock_hash()
    last_hash = get_last_install_hash()
    if current_hash == last_hash and os.path.isdir(LIBS_FOLDER):
        return
    verbose_rmtree(os.path.join(PROJECT_ROOT, LIBS_FOLDER))
    venv_path = os.path.join(PROJECT_ROOT, VENV_FOLDER)
    if os.path.exists(venv_path):
        success = verbose_rmtree(venv_path)
        if not success:
            sys.exit(1)
    if not run_command(['poetry', 'config', 'virtualenvs.in-project', 'true'], "Setting up Poetry..."):
        return
    if not run_command(['poetry', 'install'], f"Installing dependencies..."):
        return
    temp_req_file = "temp_requirements.txt"
    if not run_command(['poetry', 'export', '-f', 'requirements.txt', '--output', temp_req_file, '--without-hashes'], "Exporting dependencies..."):
        return
    pip_install_cmd = ['poetry', 'run', 'pip', 'install', '--target', LIBS_FOLDER, '-r', temp_req_file]
    if not run_command(pip_install_cmd, f"Populating '{LIBS_FOLDER}'..."):
        if os.path.exists(temp_req_file): os.remove(temp_req_file)
        return
    if os.path.exists(temp_req_file):
        os.remove(temp_req_file)
    new_hash = get_lock_hash()
    if new_hash:
        save_current_install_hash(new_hash)
if __name__ == "__main__":
    main()
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\themes\flowork_default.json
# JUMLAH BARIS : 22
#######################################################################

```json
{
  "name": "flowork_default",
  "author": "Flowork Team",
  "colors": {
    "primary": "#001f3f",
    "secondary": "#F5F5DC",
    "success": "#39CCCC",
    "info": "#007bff",
    "warning": "#FFDC00",
    "danger": "#FF4136",
    "light": "#F8F9FA",
    "dark": "#343A40",
    "bg": "#001f3f",
    "fg": "#FDFD96",
    "selectbg": "#007bff",
    "selectfg": "#FFFFFF",
    "border": "#adb5bd",
    "inputfg": "#343A40",
    "inputbg": "#FFFFFF",
    "active": "#39CCCC"
  }
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\themes\ocean_dark.json
# JUMLAH BARIS : 18
#######################################################################

```json
{
  "name": "Ocean Dark",
  "colors": {
    "primary": "#007bff",
    "secondary": "#6c757d",
    "success": "#28a745",
    "info": "#17a2b8",
    "warning": "#ffc107",
    "danger": "#dc3545",
    "light": "#f8f9fa",
    "dark": "#343a40",
    "bg": "#2c3e50",
    "fg": "#ecf0f1",
    "selectbg": "#0056b3",
    "selectfg": "#ffffff",
    "border": "#4a6279"
  }
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\themes\tema_cerah.json
# JUMLAH BARIS : 18
#######################################################################

```json
{
  "name": "Tema Cerah",
  "colors": {
    "primary": "#2196F3",
    "secondary": "#9E9E9E",
    "success": "#8BC34A",
    "info": "#00BCD4",
    "warning": "#FFC107",
    "danger": "#FF5722",
    "light": "#fcfcfc",
    "dark": "#616161",
    "bg": "#f0f0f0",
    "fg": "#333333",
    "selectbg": "#03A9F4",
    "selectfg": "#ffffff",
    "border": "#BDBDBD"
  }
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\themes\tema_elegan.json
# JUMLAH BARIS : 18
#######################################################################

```json
{
  "name": "Tema Elegan",
  "colors": {
    "primary": "#673AB7",
    "secondary": "#B39DDB",
    "success": "#81C784",
    "info": "#64B5F6",
    "warning": "#FFD54F",
    "danger": "#E57373",
    "light": "#F5F5F5",
    "dark": "#424242",
    "bg": "#EEEEEE",
    "fg": "#424242",
    "selectbg": "#7E57C2",
    "selectfg": "#FFFFFF",
    "border": "#9575CD"
  }
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\themes\tema_hyper.json
# JUMLAH BARIS : 18
#######################################################################

```json
{
  "name": "Tema Hyper",
  "colors": {
    "primary": "#FF00FF",
    "secondary": "#00FFFF",
    "success": "#00FF00",
    "info": "#00AAFF",
    "warning": "#FFD700",
    "danger": "#FF0000",
    "light": "#222222",
    "dark": "#000000",
    "bg": "#121212",
    "fg": "#E0E0FF",
    "selectbg": "#4A004A",
    "selectfg": "#FFFFFF",
    "border": "#550055"
  }
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\themes\tema_mewah.json
# JUMLAH BARIS : 18
#######################################################################

```json
{
  "name": "Tema Mewah",
  "colors": {
    "primary": "#b3884b",
    "secondary": "#5a5250",
    "success": "#4CAF50",
    "info": "#607D8B",
    "warning": "#FF9800",
    "danger": "#F44336",
    "light": "#f0e4d0",
    "dark": "#2c2c2c",
    "bg": "#1a1a1a",
    "fg": "#e0e0e0",
    "selectbg": "#8c6e3d",
    "selectfg": "#ffffff",
    "border": "#795548"
  }
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\themes\tema_netral.json
# JUMLAH BARIS : 18
#######################################################################

```json
{
  "name": "Tema Netral",
  "colors": {
    "primary": "#78909C",
    "secondary": "#B0BEC5",
    "success": "#A5D6A7",
    "info": "#90CAF9",
    "warning": "#FFEB3B",
    "danger": "#EF9A9A",
    "light": "#eceff1",
    "dark": "#455A64",
    "bg": "#CFD8DC",
    "fg": "#37474F",
    "selectbg": "#607D8B",
    "selectfg": "#ffffff",
    "border": "#78909C"
  }
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\cron_trigger\config_ui.py
# JUMLAH BARIS : 139
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, Frame
class CronConfigUI(ttk.Frame):
    """
    User-friendly Cronjob Configuration UI that translates simple inputs
    into a cron string automatically.
    """
    def __init__(self, parent, loc, initial_config):
        super().__init__(parent)
        self.loc = loc
        self.schedule_type_var = StringVar(value='daily') # Default to daily
        self.vars = {
            'every_x_minutes': StringVar(value='5'),
            'hourly_minute': StringVar(value='0'),
            'daily_hour': StringVar(value='9'),
            'daily_minute': StringVar(value='0'),
            'weekly_days': {i: ttk.BooleanVar(value=False) for i in range(7)}, # 0=Monday, 6=Sunday
            'weekly_hour': StringVar(value='9'),
            'weekly_minute': StringVar(value='0'),
        }
        self._parse_initial_config(initial_config.get('cron_string', '0 9 * * *'))
        self._create_widgets()
        self._on_schedule_type_change()
    def _create_widgets(self):
        """Creates all UI widgets."""
        type_frame = ttk.LabelFrame(self, text=self.loc.get('cron_ui_schedule_type', fallback="Schedule Type"))
        type_frame.pack(fill='x', expand=True, pady=(0, 10))
        ttk.Radiobutton(type_frame, text=self.loc.get('cron_ui_every_x_minutes', fallback="Every X Minutes"),
                        variable=self.schedule_type_var, value='minutes', command=self._on_schedule_type_change).pack(anchor='w', padx=5)
        ttk.Radiobutton(type_frame, text=self.loc.get('cron_ui_every_hour', fallback="Every Hour"),
                        variable=self.schedule_type_var, value='hourly', command=self._on_schedule_type_change).pack(anchor='w', padx=5)
        ttk.Radiobutton(type_frame, text=self.loc.get('cron_ui_daily', fallback="Daily"),
                        variable=self.schedule_type_var, value='daily', command=self._on_schedule_type_change).pack(anchor='w', padx=5)
        ttk.Radiobutton(type_frame, text=self.loc.get('cron_ui_weekly', fallback="Weekly"),
                        variable=self.schedule_type_var, value='weekly', command=self._on_schedule_type_change).pack(anchor='w', padx=5)
        self.details_frame = ttk.Frame(self)
        self.details_frame.pack(fill='x', expand=True, pady=10)
    def _on_schedule_type_change(self):
        """Displays the UI appropriate for the selected schedule type."""
        for widget in self.details_frame.winfo_children():
            widget.destroy()
        schedule_type = self.schedule_type_var.get()
        if schedule_type == 'minutes':
            self._create_minutes_ui()
        elif schedule_type == 'hourly':
            self._create_hourly_ui()
        elif schedule_type == 'daily':
            self._create_daily_ui()
        elif schedule_type == 'weekly':
            self._create_weekly_ui()
    def _create_minutes_ui(self):
        """UI for 'Every X Minutes' schedule."""
        frame = self.details_frame
        ttk.Label(frame, text=self.loc.get('cron_ui_run_every', fallback="Run every")).pack(side='left', padx=(0, 5))
        ttk.Entry(frame, textvariable=self.vars['every_x_minutes'], width=5).pack(side='left')
        ttk.Label(frame, text=self.loc.get('cron_ui_minutes_label', fallback="minutes")).pack(side='left', padx=5)
    def _create_hourly_ui(self):
        """UI for 'Every Hour' schedule."""
        frame = self.details_frame
        ttk.Label(frame, text=self.loc.get('cron_ui_run_at_minute', fallback="Run at minute:")).pack(side='left', padx=(0, 5))
        ttk.Entry(frame, textvariable=self.vars['hourly_minute'], width=5).pack(side='left')
    def _create_daily_ui(self):
        """UI for 'Daily' schedule."""
        frame = self.details_frame
        ttk.Label(frame, text=self.loc.get('cron_ui_run_at_time', fallback="Run at time:")).pack(side='left', padx=(0, 5))
        ttk.Entry(frame, textvariable=self.vars['daily_hour'], width=5).pack(side='left')
        ttk.Label(frame, text=":").pack(side='left', padx=2)
        ttk.Entry(frame, textvariable=self.vars['daily_minute'], width=5).pack(side='left')
    def _create_weekly_ui(self):
        """UI for 'Weekly' schedule."""
        frame = self.details_frame
        days_frame = ttk.Frame(frame)
        days_frame.pack(fill='x', pady=(0,10))
        days = [
            self.loc.get('day_mon', fallback="Mon"), self.loc.get('day_tue', fallback="Tue"),
            self.loc.get('day_wed', fallback="Wed"), self.loc.get('day_thu', fallback="Thu"),
            self.loc.get('day_fri', fallback="Fri"), self.loc.get('day_sat', fallback="Sat"),
            self.loc.get('day_sun', fallback="Sun")
        ]
        for i, day_text in enumerate(days):
            ttk.Checkbutton(days_frame, text=day_text, variable=self.vars['weekly_days'][i]).pack(side='left', expand=True)
        time_frame = ttk.Frame(frame)
        time_frame.pack(fill='x')
        ttk.Label(time_frame, text=self.loc.get('cron_ui_run_at_time', fallback="Run at time:")).pack(side='left', padx=(0, 5))
        ttk.Entry(time_frame, textvariable=self.vars['weekly_hour'], width=5).pack(side='left')
        ttk.Label(time_frame, text=":").pack(side='left', padx=2)
        ttk.Entry(time_frame, textvariable=self.vars['weekly_minute'], width=5).pack(side='left')
    def _parse_initial_config(self, cron_string):
        """Tries to parse the cron string to pre-fill the UI."""
        parts = cron_string.split()
        if len(parts) != 5: return
        minute, hour, day_month, month, day_week = parts
        if day_week != '*' and day_month == '*' and month == '*':
            self.schedule_type_var.set('weekly')
            self.vars['weekly_hour'].set(hour if hour != '*' else '9')
            self.vars['weekly_minute'].set(minute if minute != '*' else '0')
            selected_days = day_week.split(',')
            for i in range(7):
                if str(i) in selected_days:
                    self.vars['weekly_days'][i].set(True)
        elif minute.startswith('*/'):
            self.schedule_type_var.set('minutes')
            self.vars['every_x_minutes'].set(minute[2:])
        elif hour == '*' and day_month == '*' and month == '*':
            self.schedule_type_var.set('hourly')
            self.vars['hourly_minute'].set(minute)
        else: # Default to Daily
            self.schedule_type_var.set('daily')
            self.vars['daily_hour'].set(hour if hour != '*' else '9')
            self.vars['daily_minute'].set(minute if minute != '*' else '0')
    def get_config(self):
        """Builds the cron string from the UI inputs."""
        schedule_type = self.schedule_type_var.get()
        cron_string = "* * * * *" # Default
        if schedule_type == 'minutes':
            minute = self.vars['every_x_minutes'].get()
            cron_string = f"*/{minute} * * * *"
        elif schedule_type == 'hourly':
            minute = self.vars['hourly_minute'].get()
            cron_string = f"{minute} * * * *"
        elif schedule_type == 'daily':
            hour = self.vars['daily_hour'].get()
            minute = self.vars['daily_minute'].get()
            cron_string = f"{minute} {hour} * * *"
        elif schedule_type == 'weekly':
            hour = self.vars['weekly_hour'].get()
            minute = self.vars['weekly_minute'].get()
            days = [str(i) for i, var in self.vars['weekly_days'].items() if var.get()]
            day_string = ",".join(days) if days else '*'
            cron_string = f"{minute} {hour} * * {day_string}"
        return {"cron_string": cron_string}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\cron_trigger\manifest.json
# JUMLAH BARIS : 10
#######################################################################

```json
{
    "id": "cron_trigger",
    "name_key": "cron_trigger_name",
    "description_key": "cron_trigger_desc",
    "tutorial_key": "cron_trigger_tutorial",
    "version": "1.0",
    "author": "Awenk Audico",
    "type": "BACKGROUND_TRIGGER",
    "config_ui_entry_point": "config_ui.CronConfigUI"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\cron_trigger\locales\en.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "cron_trigger_name": "Time Trigger (Cron)",
    "cron_trigger_desc": "Automatically executes a workflow based on a very specific and recurring time schedule. This is the backbone for all scheduled tasks, from daily reports to weekly maintenance.",
    "cron_trigger_tutorial": "**Concept:**\nCron is an industry-standard task scheduler. You define the execution time using a pattern (e.g., 'every day at 5 PM', 'every Monday').\n\n**How to Use:**\n1. Drag & drop this trigger to the right panel to create a new Rule.\n2. In the editor window, use the interactive UI to set your schedule. Choose between 'Every X Minutes', 'Hourly', 'Daily', or 'Weekly'.\n3. Select the 'Preset to Run' from the dropdown list.\n4. Ensure 'Enable This Rule' is checked, then Save.\n\n**Optimization Examples:**\n- **Daily Reports:** Set to run 'Daily' at '09:00' to send a sales report email.\n- **Data Sync:** Schedule to run 'Every 30 Minutes' to fetch the latest data from an API."
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\cron_trigger\locales\id.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "cron_trigger_name": "Pemicu Waktu (Cron)",
    "cron_trigger_desc": "Menjalankan alur kerja secara otomatis berdasarkan jadwal waktu yang sangat spesifik dan berulang. Ini adalah tulang punggung untuk semua tugas terjadwal, mulai dari laporan harian hingga maintenance mingguan.",
    "cron_trigger_tutorial": "**Konsep:**\nCron adalah penjadwal tugas standar industri. Anda mendefinisikan waktu eksekusi menggunakan pola (misal: 'setiap jam 5 sore', 'setiap hari Senin').\n\n**Cara Penggunaan:**\n1. Drag & drop trigger ini ke panel kanan untuk membuat Aturan baru.\n2. Di jendela editor, gunakan UI interaktif untuk mengatur jadwal. Pilih antara 'Setiap X Menit', 'Setiap Jam', 'Harian', atau 'Mingguan'.\n3. Pilih 'Preset yang Akan Dijalankan' dari daftar dropdown.\n4. Pastikan 'Aktifkan Aturan Ini' dicentang, lalu Simpan.\n\n**Contoh Optimasi:**\n- **Laporan Harian:** Atur untuk berjalan 'Harian' pada jam '09:00' untuk mengirim email laporan penjualan.\n- **Sinkronisasi Data:** Jadwalkan untuk berjalan 'Setiap 30 Menit' untuk mengambil data terbaru dari sebuah API."
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\event_bus_trigger\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "d5615b91ea518b89dbffb7d0ca1140e3d8436eb40f186b1829b6e00116639bb2",
    "manifest_hash": "8927b581f6676195156cf7d72a7e2cd694037d854f015c6365614a97c9fa56a0",
    "timestamp": 1757229901.4015968
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\event_bus_trigger\config_ui.py
# JUMLAH BARIS : 24
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar
class EventBusConfigUI(ttk.Frame):
    """UI untuk mengkonfigurasi pemicu Event Bus."""
    def __init__(self, parent, loc, initial_config):
        super().__init__(parent)
        self.loc = loc
        self.event_name_var = StringVar(value=initial_config.get('event_name', ''))
        ttk.Label(self, text=self.loc.get('eventbus_label_event_name', fallback="Nama Event:")).pack(anchor='w')
        ttk.Entry(self, textvariable=self.event_name_var, width=50).pack(fill='x', expand=True, pady=(0, 5))
        ttk.Label(self, text=self.loc.get('eventbus_help_text', fallback="Nama event yang akan didengarkan dari sistem."), style='secondary.TLabel').pack(anchor='w')
    def get_config(self):
        """Mengembalikan konfigurasi yang telah diatur oleh pengguna."""
        return {
            "event_name": self.event_name_var.get()
        }
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\event_bus_trigger\listener.py
# JUMLAH BARIS : 57
#######################################################################

```py
from flowork_kernel.core import build_security
from flowork_kernel.api_contract import BaseTriggerListener
class EventBusListener(BaseTriggerListener):
    """
    Listener that listens for specific events on the internal Flowork Event Bus.
    """
    def __init__(self, trigger_id: str, config: dict, services: dict, **kwargs):
        build_security.perform_runtime_check(__file__)
        super().__init__(trigger_id, config, services, **kwargs)
        self.logger(f"EventBusListener instance created for rule_id: {self.rule_id}", "DEBUG")
        self.event_name_to_listen = self.config.get("event_name", "")
        self.event_bus = getattr(self, 'event_bus', None)
    def start(self):
        """
        Subscribes to the specified event on the Event Bus.
        """
        if not self.event_name_to_listen:
            self.logger(f"Event Bus Trigger '{self.rule_id}': Event name not configured. Trigger will not start.", "ERROR")
            return
        if not self.event_bus:
            self.logger(f"Event Bus Trigger '{self.rule_id}': Event Bus service is not available. Trigger failed.", "ERROR")
            return
        subscriber_id = f"trigger_listener_{self.rule_id}"
        self.event_bus.subscribe(self.event_name_to_listen, subscriber_id, self._handle_internal_event)
        self.is_running = True
        self.logger(f"Event Bus Trigger '{self.rule_id}': Started listening for event '{self.event_name_to_listen}'.", "INFO")
    def stop(self):
        """
        Unsubscribes from the Event Bus.
        (Conceptually, as EventBus currently lacks an unsubscribe method).
        """
        if self.is_running:
            self.is_running = False
            self.logger(f"Event Bus Trigger '{self.rule_id}': Subscription to event '{self.event_name_to_listen}' stopped (conceptually).", "INFO")
    def _handle_internal_event(self, event_data_from_bus: dict):
        """
        This method is automatically called by the EventBus when the event occurs.
        """
        if not self.is_running:
            return
        event_data_to_report = {
            "trigger_id": self.trigger_id,
            "rule_id": self.rule_id,
            "event_type": "event_bus_received",
            "source_event_name": self.event_name_to_listen,
            "source_event_data": event_data_from_bus
        }
        self._on_event(event_data_to_report)
_UNUSED_SIGNATURE = 'B3Ba%m#rDeKa' # Embedded Signature
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\event_bus_trigger\listener.py.tmp.py
# JUMLAH BARIS : 57
#######################################################################

```py
from flowork_kernel.core import build_security
from flowork_kernel.api_contract import BaseTriggerListener
class EventBusListener(BaseTriggerListener):
    """
    Listener that listens for specific events on the internal Flowork Event Bus.
    """
    def __init__(self, trigger_id: str, config: dict, services: dict, **kwargs):
        build_security.perform_runtime_check(__file__)
        super().__init__(trigger_id, config, services, **kwargs)
        self.logger(f"EventBusListener instance created for rule_id: {self.rule_id}", "DEBUG")
        self.event_name_to_listen = self.config.get("event_name", "")
        self.event_bus = getattr(self, 'event_bus', None)
    def start(self):
        """
        Subscribes to the specified event on the Event Bus.
        """
        if not self.event_name_to_listen:
            self.logger(f"Event Bus Trigger '{self.rule_id}': Event name not configured. Trigger will not start.", "ERROR")
            return
        if not self.event_bus:
            self.logger(f"Event Bus Trigger '{self.rule_id}': Event Bus service is not available. Trigger failed.", "ERROR")
            return
        subscriber_id = f"trigger_listener_{self.rule_id}"
        self.event_bus.subscribe(self.event_name_to_listen, subscriber_id, self._handle_internal_event)
        self.is_running = True
        self.logger(f"Event Bus Trigger '{self.rule_id}': Started listening for event '{self.event_name_to_listen}'.", "INFO")
    def stop(self):
        """
        Unsubscribes from the Event Bus.
        (Conceptually, as EventBus currently lacks an unsubscribe method).
        """
        if self.is_running:
            self.is_running = False
            self.logger(f"Event Bus Trigger '{self.rule_id}': Subscription to event '{self.event_name_to_listen}' stopped (conceptually).", "INFO")
    def _handle_internal_event(self, event_data_from_bus: dict):
        """
        This method is automatically called by the EventBus when the event occurs.
        """
        if not self.is_running:
            return
        event_data_to_report = {
            "trigger_id": self.trigger_id,
            "rule_id": self.rule_id,
            "event_type": "event_bus_received",
            "source_event_name": self.event_name_to_listen,
            "source_event_data": event_data_from_bus
        }
        self._on_event(event_data_to_report)
_UNUSED_SIGNATURE = 'B3Ba%m#rDeKa' # Embedded Signature
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\event_bus_trigger\manifest.json
# JUMLAH BARIS : 14
#######################################################################

```json
{
    "id": "event_bus_trigger",
    "name_key": "event_bus_trigger_name",
    "description_key": "event_bus_trigger_desc",
    "tutorial_key": "event_bus_trigger_tutorial",
    "version": "1.0.0",
    "author": "Flowork Core",
    "entry_point": "listener.EventBusListener",
    "config_ui_entry_point": "config_ui.EventBusConfigUI",
    "requires_services": [
        "logger",
        "event_bus"
    ]
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\event_bus_trigger\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "d5615b91ea518b89dbffb7d0ca1140e3d8436eb40f186b1829b6e00116639bb2",
    "manifest_hash": "8927b581f6676195156cf7d72a7e2cd694037d854f015c6365614a97c9fa56a0",
    "timestamp": 1757204752.623946
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\event_bus_trigger\locales\en.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "event_bus_trigger_name": "Internal Event Bus Trigger",
    "event_bus_trigger_desc": "Creates reactive workflows. This trigger listens for 'signals' or 'events' published by other modules, allowing you to build interconnected and intelligent systems.",
    "event_bus_trigger_tutorial": "**Concept:**\nThe Event Bus is a central message board. One module (the 'Publisher') can shout a message (an event), and this trigger (the 'Subscriber') will hear it if it's interested in the message topic.\n\n**How to Use:**\n1. In one workflow, use the 'Publish Event' module to send a signal when an important task is complete. Give the event a clear name, e.g., `PROCESS_A_COMPLETE`.\n2. In the Trigger Manager page, create a new Rule using this trigger.\n3. In its properties, enter the exact same event name (`PROCESS_A_COMPLETE`).\n4. Select another workflow that you want to run in response.\n\n**Optimization Examples:**\n- **Chained Workflows:** Automatically run the 'Process B' workflow ONLY IF the 'Process A' workflow has completed successfully and published an event.\n- **Centralized Notifications:** Several different workflows can publish a `SEND_CRITICAL_NOTIFICATION` event, and a single workflow triggered by this event is responsible for sending it to Telegram."
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\event_bus_trigger\locales\id.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "event_bus_trigger_name": "Pemicu Event Bus Internal",
    "event_bus_trigger_desc": "Menciptakan alur kerja yang reaktif. Trigger ini mendengarkan 'sinyal' atau 'event' yang diterbitkan oleh modul lain, memungkinkan Anda membuat sistem yang saling terhubung dan cerdas.",
    "event_bus_trigger_tutorial": "**Konsep:**\nEvent Bus adalah papan pengumuman sentral. Satu modul ('Publisher') bisa meneriakkan sebuah pesan (event), dan trigger ini ('Subscriber') akan mendengarnya jika tertarik dengan topik pesan tersebut.\n\n**Cara Penggunaan:**\n1. Dalam satu workflow, gunakan modul 'Publish Event' untuk mengirim sinyal saat tugas penting selesai. Beri nama event yang jelas, misal: `PROSES_A_SELESAI`.\n2. Di halaman Trigger Manager, buat Aturan baru menggunakan trigger ini.\n3. Di propertinya, masukkan nama event yang sama persis (`PROSES_A_SELESAI`).\n4. Pilih workflow lain yang ingin Anda jalankan sebagai respons.\n\n**Contoh Optimasi:**\n- **Workflow Berantai:** Jalankan alur 'Proses B' secara otomatis HANYA JIKA alur 'Proses A' telah selesai dengan sukses dan mengirim event.\n- **Notifikasi Terpusat:** Beberapa workflow bisa menerbitkan event `KIRIM_NOTIFIKASI_PENTING`, dan satu workflow yang dipicu oleh event ini bertugas mengirimkannya ke Telegram."
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\file_system_trigger\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "8b94379d057556decf14231716d7b5f87e7357f012a8216e90c2370cfddca21e",
    "manifest_hash": "43700abb5699167beeefb995becda3434fc410f3fd62f2242feed36effa7777d",
    "timestamp": 1757229906.2888064
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\file_system_trigger\config_ui.py
# JUMLAH BARIS : 42
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, BooleanVar, filedialog
class FileSystemConfigUI(ttk.Frame):
    """UI untuk mengkonfigurasi pemicu File System."""
    def __init__(self, parent, loc, initial_config):
        super().__init__(parent)
        self.loc = loc
        self.path_var = StringVar(value=initial_config.get('path_to_watch', ''))
        self.event_created_var = BooleanVar(value=initial_config.get('on_created', True))
        self.event_modified_var = BooleanVar(value=initial_config.get('on_modified', True))
        self.event_deleted_var = BooleanVar(value=initial_config.get('on_deleted', False))
        path_frame = ttk.Frame(self)
        path_frame.pack(fill='x', expand=True, pady=(0, 10))
        ttk.Label(path_frame, text=self.loc.get('filesystem_label_path', fallback="Folder/File untuk Dipantau:")).pack(anchor='w')
        entry_frame = ttk.Frame(path_frame)
        entry_frame.pack(fill='x', expand=True)
        ttk.Entry(entry_frame, textvariable=self.path_var).pack(side='left', fill='x', expand=True)
        ttk.Button(entry_frame, text="...", command=self._browse_path, width=4).pack(side='left', padx=(5,0))
        event_frame = ttk.LabelFrame(self, text=self.loc.get('filesystem_label_events', fallback="Jenis Kejadian"))
        event_frame.pack(fill='x', expand=True)
        ttk.Checkbutton(event_frame, text=self.loc.get('filesystem_event_created', fallback="Saat Dibuat"), variable=self.event_created_var).pack(anchor='w', padx=5)
        ttk.Checkbutton(event_frame, text=self.loc.get('filesystem_event_modified', fallback="Saat Diubah"), variable=self.event_modified_var).pack(anchor='w', padx=5)
        ttk.Checkbutton(event_frame, text=self.loc.get('filesystem_event_deleted', fallback="Saat Dihapus"), variable=self.event_deleted_var).pack(anchor='w', padx=5)
    def _browse_path(self):
        path = filedialog.askdirectory()
        if path:
            self.path_var.set(path)
    def get_config(self):
        return {
            "path_to_watch": self.path_var.get(),
            "on_created": self.event_created_var.get(),
            "on_modified": self.event_modified_var.get(),
            "on_deleted": self.event_deleted_var.get()
        }
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\file_system_trigger\listener.py
# JUMLAH BARIS : 81
#######################################################################

```py
from flowork_kernel.core import build_security
import time
import os
import threading
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileModifiedEvent, FileCreatedEvent, FileDeletedEvent, FileMovedEvent
from flowork_kernel.api_contract import BaseTriggerListener
class _InternalEventHandler(FileSystemEventHandler):
    """Kelas internal untuk menangani event dari watchdog dan meneruskannya."""
    def __init__(self, listener_instance):
        build_security.perform_runtime_check(__file__)
        self.listener = listener_instance
    def on_any_event(self, event):
        if event.is_directory:
            return
        event_type = "unknown"
        if isinstance(event, FileCreatedEvent):
            event_type = "created"
        elif isinstance(event, FileModifiedEvent):
            event_type = "modified"
        elif isinstance(event, FileDeletedEvent):
            event_type = "deleted"
        elif isinstance(event, FileMovedEvent):
            event_type = "moved"
        event_data = {
            "trigger_id": self.listener.trigger_id,
            "rule_id": self.listener.rule_id, # Sertakan ID aturan untuk identifikasi
            "event_type": event_type,
            "src_path": event.src_path
        }
        if isinstance(event, FileMovedEvent):
            event_data["dest_path"] = event.dest_path
        self.listener._on_event(event_data)
class FileSystemListener(BaseTriggerListener):
    """
    Listener that monitors file system changes (created, modified, deleted).
    """
    def __init__(self, trigger_id: str, config: dict, services: dict, **kwargs):
        super().__init__(trigger_id, config, services, **kwargs)
        self.logger(f"FileSystemListener instance created for rule_id: {self.rule_id}", "DEBUG")
        self._observer = None
        self.path_to_watch = self.config.get("path_to_watch")
        self.events_to_watch = self.config.get("events_to_watch", []) # (COMMENT) This key seems unused, might be a future feature.
    def start(self):
        """Starts the file system monitoring thread."""
        if not self.path_to_watch or not os.path.isdir(self.path_to_watch):
            self.logger(f"File Trigger '{self.rule_id}': Path '{self.path_to_watch}' is invalid or not a directory. Trigger will not start.", "ERROR")
            return
        self.is_running = True
        event_handler = _InternalEventHandler(self)
        self._observer = Observer()
        self._observer.schedule(event_handler, self.path_to_watch, recursive=True)
        self.thread = threading.Thread(target=self._run_observer, daemon=True)
        self.thread.start()
        self.logger(f"File Trigger '{self.rule_id}': Started monitoring folder '{self.path_to_watch}'.", "INFO")
    def _run_observer(self):
        """Internal method run by the thread."""
        try:
            self._observer.start()
            while self.is_running:
                time.sleep(1)
        finally:
            if self._observer.is_alive():
                self._observer.stop()
            self._observer.join()
    def stop(self):
        """Stops the monitoring."""
        if self.is_running:
            self.is_running = False
            if self._observer and self._observer.is_alive():
                self._observer.stop()
            self.logger(f"File Trigger '{self.rule_id}': Monitoring stopped.", "INFO")
_UNUSED_SIGNATURE = 'B3Ba%m#rDeKa' # Embedded Signature
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\file_system_trigger\manifest.json
# JUMLAH BARIS : 11
#######################################################################

```json
{
    "id": "file_system_trigger",
    "name_key": "file_system_trigger_name",
    "description_key": "file_system_trigger_desc",
    "tutorial_key": "file_system_trigger_tutorial",
    "version": "1.0",
    "author": "Awenk Audico",
    "type": "LISTENER_TRIGGER",
    "entry_point": "listener.FileSystemListener",
    "config_ui_entry_point": "config_ui.FileSystemConfigUI"
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\file_system_trigger\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "8b94379d057556decf14231716d7b5f87e7357f012a8216e90c2370cfddca21e",
    "manifest_hash": "43700abb5699167beeefb995becda3434fc410f3fd62f2242feed36effa7777d",
    "timestamp": 1757204757.149419
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\file_system_trigger\locales\en.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "file_system_trigger_name": "File System Trigger",
    "file_system_trigger_desc": "Monitors a folder and automatically reacts to file activity. This trigger is your system's eyes and ears within the file explorer, ready to act on new files, changes, or deletions.",
    "file_system_trigger_tutorial": "**Concept:**\nThis trigger uses a 'watchdog' to monitor a directory. When a specified activity occurs (e.g., a new file appears), it will immediately trigger a preset.\n\n**How to Use:**\n1. Drag & drop this trigger to the right.\n2. Click 'Browse...' to select the folder you want to watch.\n3. Check the relevant event types: 'On Created', 'On Modified', or 'On Deleted'. You can select more than one.\n4. Specify the Preset to be executed.\n\n**Optimization Examples:**\n- **Automated ETL:** Monitor an 'uploads' folder. Every time a new CSV file arrives, automatically run a workflow to read, process, and insert its data into a database.\n- **Image Conversion:** Watch a 'raw_images' folder. For every new .PNG file, trigger a workflow to convert it to .JPG and move it to another folder."
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\file_system_trigger\locales\id.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "file_system_trigger_name": "Pemicu Perubahan File",
    "file_system_trigger_desc": "Mengawasi sebuah folder dan bereaksi secara otomatis terhadap aktivitas file. Trigger ini adalah mata dan telinga sistem Anda di dalam file explorer, siap bertindak saat ada file baru, perubahan, atau penghapusan.",
    "file_system_trigger_tutorial": "**Konsep:**\nTrigger ini menggunakan 'watchdog' untuk memantau sebuah direktori. Saat aktivitas yang Anda tentukan terjadi (misal: file baru muncul), ia akan langsung memicu preset.\n\n**Cara Penggunaan:**\n1. Drag & drop trigger ini ke kanan.\n2. Klik 'Browse...' untuk memilih folder yang ingin Anda awasi.\n3. Centang jenis kejadian yang relevan: 'Saat Dibuat', 'Saat Diubah', atau 'Saat Dihapus'. Anda bisa memilih lebih dari satu.\n4. Tentukan Preset yang akan dieksekusi.\n\n**Contoh Optimasi:**\n- **ETL Otomatis:** Pantau folder 'uploads'. Setiap kali ada file CSV baru masuk, otomatis jalankan workflow untuk membaca, memproses, dan memasukkan datanya ke database.\n- **Konversi Gambar:** Awasi folder 'gambar_mentah'. Setiap ada file .PNG baru, picu workflow untuk mengkonversinya menjadi .JPG dan memindahkannya ke folder lain."
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\process_trigger\build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "59bc406b753af211de0d21eb0e61f74cb0089bfc4836126888f3a2722c6713cf",
    "manifest_hash": "c1954938e01ac346ed63342eb3ec896dca98f0b1fc9f024f601e456fa12d5f48",
    "timestamp": 1757229911.4001672
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\process_trigger\config_ui.py
# JUMLAH BARIS : 33
#######################################################################

```py
import ttkbootstrap as ttk
from tkinter import StringVar, BooleanVar
class ProcessConfigUI(ttk.Frame):
    """UI untuk mengkonfigurasi pemicu Proses."""
    def __init__(self, parent, loc, initial_config):
        super().__init__(parent)
        self.loc = loc
        self.process_name_var = StringVar(value=initial_config.get('process_name', ''))
        self.on_start_var = BooleanVar(value=initial_config.get('on_start', True))
        self.on_stop_var = BooleanVar(value=initial_config.get('on_stop', True))
        content_frame = ttk.Frame(self)
        content_frame.pack(fill='both', expand=True)
        ttk.Label(content_frame, text=self.loc.get('process_label_name', fallback="Nama Proses (e.g., notepad.exe):")).pack(anchor='w', pady=(0,2))
        ttk.Entry(content_frame, textvariable=self.process_name_var).pack(fill='x', expand=True, pady=(0,10))
        event_frame = ttk.LabelFrame(content_frame, text=self.loc.get('process_label_events', fallback="Picu Saat"))
        event_frame.pack(fill='x', expand=True, pady=(5,0))
        ttk.Checkbutton(event_frame, text=self.loc.get('process_event_started', fallback="Proses Dimulai"), variable=self.on_start_var).pack(anchor='w', padx=5, pady=(5,2))
        ttk.Checkbutton(event_frame, text=self.loc.get('process_event_stopped', fallback="Proses Berhenti"), variable=self.on_stop_var).pack(anchor='w', padx=5, pady=(2,5))
    def get_config(self):
        """Mengembalikan konfigurasi yang telah diatur oleh pengguna."""
        return {
            "process_name": self.process_name_var.get(),
            "on_start": self.on_start_var.get(),
            "on_stop": self.on_stop_var.get()
        }
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\process_trigger\listener.py
# JUMLAH BARIS : 75
#######################################################################

```py
from flowork_kernel.core import build_security
import time
import threading
import psutil
from flowork_kernel.api_contract import BaseTriggerListener
class ProcessListener(BaseTriggerListener):
    """
    Listener that monitors for a specific process starting or stopping.
    """
    def __init__(self, trigger_id: str, config: dict, services: dict, **kwargs):
        build_security.perform_runtime_check(__file__)
        super().__init__(trigger_id, config, services, **kwargs)
        self.logger(f"ProcessListener instance created for rule_id: {self.rule_id}", "DEBUG") # English Log
        self.process_name = self.config.get("process_name")
        self.on_start = self.config.get("on_start", True)
        self.on_stop = self.config.get("on_stop", True)
        self.poll_interval = 5 # (COMMENT) Check every 5 seconds
        self.known_pids = set()
        self.thread = None
    def _find_pids_by_name(self):
        """Finds all PIDs for a given process name."""
        return {p.pid for p in psutil.process_iter(['name']) if p.info['name'].lower() == self.process_name.lower()}
    def start(self):
        """Starts the process monitoring thread."""
        if not self.process_name:
            self.logger(f"Process Trigger '{self.rule_id}': Process name is not configured. Trigger will not start.", "ERROR") # English Log
            return
        self.is_running = True
        self.known_pids = self._find_pids_by_name()
        self.logger(f"Process Trigger '{self.rule_id}': Initial scan found PIDs {self.known_pids} for '{self.process_name}'.", "INFO") # English Log
        self.thread = threading.Thread(target=self._monitor_process, daemon=True)
        self.thread.start()
        self.logger(f"Process Trigger '{self.rule_id}': Started monitoring for process '{self.process_name}'.", "SUCCESS") # English Log
    def _monitor_process(self):
        """The core monitoring loop that runs in a background thread."""
        while self.is_running:
            current_pids = self._find_pids_by_name()
            newly_started_pids = current_pids - self.known_pids
            if self.on_start and newly_started_pids:
                for pid in newly_started_pids:
                    self.logger(f"Process '{self.process_name}' (PID: {pid}) detected as STARTED.", "INFO") # English Log
                    event_data = {
                        "event_type": "process_started",
                        "process_name": self.process_name,
                        "pid": pid
                    }
                    self._on_event(event_data)
            stopped_pids = self.known_pids - current_pids
            if self.on_stop and stopped_pids:
                for pid in stopped_pids:
                    self.logger(f"Process '{self.process_name}' (PID: {pid}) detected as STOPPED.", "INFO") # English Log
                    event_data = {
                        "event_type": "process_stopped",
                        "process_name": self.process_name,
                        "pid": pid
                    }
                    self._on_event(event_data)
            self.known_pids = current_pids
            time.sleep(self.poll_interval)
    def stop(self):
        """Stops the monitoring thread."""
        if self.is_running:
            self.is_running = False
            if self.thread and self.thread.is_alive():
                self.thread.join(timeout=2)
            self.logger(f"Process Trigger '{self.rule_id}': Monitoring stopped.", "INFO") # English Log
_UNUSED_SIGNATURE = 'B3Ba%m#rDeKa' # Embedded Signature
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\process_trigger\manifest.json
# JUMLAH BARIS : 12
#######################################################################

```json
{
    "id": "process_trigger",
    "name_key": "process_trigger_name",
    "description_key": "process_trigger_desc",
    "tutorial_key": "process_trigger_tutorial",
    "version": "1.0",
    "author": "Awenk Audico",
    "type": "LISTENER_TRIGGER",
    "entry_point": "listener.ProcessListener",
    "config_ui_entry_point": "config_ui.ProcessConfigUI",
    "requires_services": ["logger"]
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\process_trigger\TES_build_fingerprint.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "source_hash": "59bc406b753af211de0d21eb0e61f74cb0089bfc4836126888f3a2722c6713cf",
    "manifest_hash": "c1954938e01ac346ed63342eb3ec896dca98f0b1fc9f024f601e456fa12d5f48",
    "timestamp": 1757204761.8844101
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\process_trigger\locales\en.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "process_trigger_name": "Application Process Trigger",
    "process_trigger_desc": "A unique trigger that monitors other applications running on your computer. You can create automations that react to when a program, game, or other service is opened or closed.",
    "process_trigger_tutorial": "**Concept:**\nThis trigger periodically checks the list of running processes on your operating system. If the process name you specify appears (starts) or disappears (stops), it will trigger a preset.\n\n**How to Use:**\n1. Create a new Rule.\n2. Enter the process name of the application, including its extension (e.g., `notepad.exe`, `chrome.exe`, `Spotify.exe`). You can see process names in the Task Manager (Windows) or Activity Monitor (Mac).\n3. Choose whether to trigger when the process 'Starts' or 'Stops'.\n4. Select the Preset to run.\n\n**Optimization Examples:**\n- **Gaming Mode:** When `valorant.exe` starts, trigger a workflow to mute notifications, open Discord, and dim your room lights.\n- **Productivity Mode:** When `Photoshop.exe` starts, run a preset that opens your last project folder and plays a focus playlist on Spotify."
}
```

#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE https://github.com/FLOWORK-gif/FLOWORK
# File NAME : C:\FLOWORK\triggers\process_trigger\locales\id.json
# JUMLAH BARIS : 5
#######################################################################

```json
{
    "process_trigger_name": "Pemicu Proses Aplikasi",
    "process_trigger_desc": "Pemicu unik yang mengawasi aplikasi lain yang berjalan di komputer Anda. Anda bisa membuat otomasi yang bereaksi terhadap kapan sebuah program, game, atau service lain dibuka atau ditutup.",
    "process_trigger_tutorial": "**Konsep:**\nSecara berkala, trigger ini akan memeriksa daftar proses yang sedang berjalan di sistem operasi Anda. Jika nama proses yang Anda tentukan muncul (dimulai) atau menghilang (berhenti), ia akan memicu preset.\n\n**Cara Penggunaan:**\n1. Buat Aturan baru.\n2. Masukkan nama proses aplikasi, termasuk ekstensinya (misal: `notepad.exe`, `chrome.exe`, `Spotify.exe`). Anda bisa melihat nama proses di Task Manager (Windows) atau Activity Monitor (Mac).\n3. Pilih apakah akan memicu saat proses 'Dimulai' atau 'Berhenti'.\n4. Pilih Preset yang akan dijalankan.\n\n**Contoh Optimasi:**\n- **Gaming Mode:** Saat `valorant.exe` dimulai, picu workflow untuk mematikan notifikasi, membuka Discord, dan meredupkan lampu kamar.\n- **Productivity Mode:** Saat `Photoshop.exe` dimulai, jalankan preset yang membuka folder proyek terakhir dan memutar playlist fokus di Spotify."
}
```