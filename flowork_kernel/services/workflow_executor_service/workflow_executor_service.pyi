# This file was generated by Nuitka

# Stubs included by default
from __future__ import annotations
from base_service import BaseService
from flowork_kernel.api_contract import LoopConfig
from flowork_kernel.exceptions import PermissionDeniedError
from flowork_kernel.execution.VariableResolver import VariableResolver
from flowork_kernel.ui_shell.workflow_editor_tab import WorkflowEditorTab
from queue import Queue
from typing import Any
from typing_extensions import Self
import json
import logging
import os
import psutil
import queue
import random
import re
import sys
import threading
import time
import traceback
import uuid

class WorkflowExecutorService(BaseService):
    def __init__(self: Self, kernel: Any, service_id: str) -> None: ...
    def trigger_workflow_from_node(self: Self, target_node_id: str, payload: dict) -> Any: ...
    def _wait_for_canvas_manager(self: Self, tab_id: Any, target_node_id: Any, payload: Any, workflow_data: Any, attempt: Any) -> Any: ...
    def _start_remote_workflow_on_ui_thread(self: Self, target_tab_widget: Any, target_node_id: Any, payload: Any, workflow_data: Any) -> Any: ...
    def _record_connection_event(self: Self, context_id: Any, connection_id: Any, payload: Any) -> Any: ...
    def get_connection_history(self: Self, context_id: Any, connection_id: Any) -> Any: ...
    def get_current_context_id(self: Self) -> Any: ...
    def _get_fresh_settings(self: Self) -> Any: ...
    def _execute_global_error_handler(self: Self, original_error: Any, failed_workflow_id: Any) -> Any: ...
    def execute_workflow(self: Self, nodes: Any, connections: Any, initial_payload: Any, logger: Any, status_updater: Any, highlighter: Any, ui_callback: Any, workflow_context_id: Any, mode: Any, job_status_updater: Any, on_complete: Any, start_node_id: Any) -> Any: ...
    def execute_workflow_synchronous(self: Self, nodes: Any, connections: Any, initial_payload: Any, logger: Any, status_updater: Any, highlighter: Any, ui_callback: Any, workflow_context_id: Any, mode: Any, job_status_updater: Any, on_complete: Any, start_node_id: Any) -> Any: ...
    def stop_execution(self: Self) -> Any: ...
    def pause_execution(self: Self) -> Any: ...
    def resume_execution(self: Self) -> Any: ...
    def _run_all_flows(self: Self, start_nodes: Any, nodes: Any, connections: Any, log: Any, update_status: Any, highlight: Any, run_on_ui: Any, initial_payload: Any, workflow_context_id: Any, mode: Any) -> Any: ...
    def _run_all_flows_sequentially(self: Self, start_nodes: Any, nodes: Any, connections: Any, log: Any, update_status: Any, highlight: Any, run_on_ui: Any, initial_payload: Any, workflow_context_id: Any, mode: Any) -> Any: ...
    def _find_and_execute_next_nodes(self: Self, current_node_id: Any, execution_result: Any, nodes: Any, connections: Any, log: Any, update_status: Any, highlight: Any, run_on_ui: Any, workflow_context_id: Any, mode: str) -> Any: ...
    def _traverse_and_execute(self: Self, current_node_id: Any, nodes: Any, connections: Any, payload: Any, log: Any, update_status: Any, highlight: Any, run_on_ui: Any, workflow_context_id: Any, mode: Any) -> Any: ...


__name__ = ...



# Modules used internally, to allow implicit dependencies to be seen:
import json
import time
import threading
import logging
import re
import os
import uuid
import random
import sys
import psutil
import traceback
import queue
import flowork_kernel
import flowork_kernel.api_contract
import flowork_kernel.execution
import flowork_kernel.execution.VariableResolver
import flowork_kernel.exceptions
import flowork_kernel.ui_shell
import flowork_kernel.ui_shell.workflow_editor_tab
import ntpath