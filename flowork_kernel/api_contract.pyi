# This file was generated by Nuitka

# Stubs included by default
from __future__ import annotations
from abc import ABC, abstractmethod
from tkinter import StringVar, ttk
from typing import Any, Callable, Dict, List, Tuple
from typing_extensions import Self

class BaseBrainProvider(ABC):
    def __init__(self: Self, module_id: str, services: dict) -> None: ...
    def get_provider_name(self: Self) -> str: ...
    def is_ready(self: Self) -> tuple[bool, str]: ...
    def think(self: Self, objective: str, tools_string: str, history: list, last_observation: str) -> dict: ...
    def get_manifest(self: Self) -> dict: ...

class BaseAIProvider(ABC):
    def __init__(self: Self, kernel: Any, manifest: dict) -> None: ...
    def get_provider_name(self: Self) -> str: ...
    def generate_response(self: Self, prompt: str) -> dict: ...
    def is_ready(self: Self) -> tuple[bool, str]: ...
    def get_manifest(self: Self) -> dict: ...

class IDataPreviewer(ABC):
    def get_data_preview(self: Self, config: Dict[str, Any]) -> Any: ...

class IDynamicOutputSchema(ABC):
    def get_dynamic_output_schema(self: Self, current_config: Dict[str, Any]) -> List[Dict[str, Any]]: ...

class IExecutable(ABC):
    def execute(self: Self, payload: Dict, config: Dict, status_updater: Callable, ui_callback: Callable, mode: str) -> Any: ...

class IConfigurableUI(ABC):
    def create_properties_ui(self: Self, parent_frame: Any, get_current_config: Any, available_vars: Any) -> Any: ...

class IDynamicPorts(ABC):
    def get_dynamic_ports(self: Self, current_config: Any) -> Any: ...

class BaseModule:
    def __init__(self: Self, module_id: str, services: Dict[str, Any]) -> None: ...
    def on_install(self: Self) -> Any: ...
    def on_load(self: Self) -> Any: ...
    def on_canvas_load(self: Self, node_id: str) -> Any: ...
    def on_unload(self: Self) -> Any: ...
    def validate(self: Self, config: Dict[str, Any], connected_input_ports: List[str]) -> Tuple[bool, str]: ...
    def pause_workflow(self: Self) -> Any: ...
    def resume_workflow(self: Self) -> Any: ...
    def request_manual_approval(self: Self, message: str, callback: Callable[[str], None]) -> Any: ...
    def publish_event(self: Self, event_name: str, event_data: Dict[str, Any]) -> Any: ...

class BaseUIProvider:
    def get_ui_tabs(self: Self) -> List[Dict[str, Any]]: ...
    def get_menu_items(self: Self) -> List[Dict[str, Any]]: ...

class BaseDashboardWidget:
    def __init__(self: Self, parent: Any, coordinator_tab: Any, kernel: Any, widget_id: str) -> None: ...
    def on_widget_load(self: Self) -> Any: ...
    def on_widget_destroy(self: Self) -> Any: ...
    def refresh_content(self: Self) -> Any: ...
    def get_widget_state(self: Self) -> dict: ...
    def load_widget_state(self: Self, state: dict) -> Any: ...

class LoopConfig:
    def __init__(self: Self, loop_type: str, iterations: int, condition_var: str, condition_op: str, condition_val: Any, enable_sleep: bool, sleep_type: str, static_duration: int, random_min: int, random_max: int) -> None: ...
    def to_dict(self: Self) -> Dict[str, Any]: ...
    @staticmethod
    def from_dict(data: Dict[str, Any]) -> Any: ...

class EnumVarWrapper:
    def __init__(self: Self, string_var: StringVar, label_to_value_map: Dict[str, str], value_to_label_map: Dict[str, str]) -> None: ...
    def get(self: Self) -> Any: ...
    def set(self: Self, value: Any) -> Any: ...
    def trace_add(self: Self, mode: Any, callback: Any) -> Any: ...

class BaseTriggerListener:
    def __init__(self: Self, trigger_id: str, config: Dict[str, Any], services: Dict[str, Any]) -> None: ...
    def set_callback(self: Self, callback: Callable[[Dict[str, Any]], None]) -> Any: ...
    def start(self: Self) -> Any: ...
    def stop(self: Self) -> Any: ...
    def _on_event(self: Self, event_data: Dict[str, Any]) -> Any: ...


__name__ = ...



# Modules used internally, to allow implicit dependencies to be seen:
import typing
import tkinter
import tkinter.StringVar
import tkinter.ttk
import abc